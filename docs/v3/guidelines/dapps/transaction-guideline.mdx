import { BlockMath, InlineMath } from 'react-katex';
import 'katex/dist/katex.min.css';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# Interact with transactions

## Как мне выяснить что моя транзакция выполнилась успешно с помощью метода API?
//TODO briefing: what you will learn in this guide

## Терминология

### Общие термины
#### Актор и модель актора

**Актор** — это абстрактная модель поведения, формализованная как вычислительный объект, который реагирует на входящие сообщения, изменяет своё состояние, создаёт новых акторов и отправляет сообщения другим.
Акторы изолированы: они не имеют доступа к состоянию друг друга и взаимодействуют только через сообщения.

Другими словами:

Актор — это независимая сущность, у которой есть состояние и поведение. Акторы обмениваются сообщениями для взаимодействия.

![](/img/docs/blockchain-fundamentals/actor.svg)

Каждый актор может:

* Изменять свое состояние.
* Отправлять сообщения другим акторам.
* Порождать новых акторов.


**Акторная модель** — это модель параллельных вычислений, в которой система описывается как совокупность акторов, взаимодействующих через передачу сообщений.

Ключевые свойства модели:

* изоляция акторов;
* асинхронность коммуникаций;
* любая вычислительная абстракция может быть реализована как актор.

Модель используется для точного описания и анализа распределённых систем. Например:
* электронная почта может быть смоделирована как система акторов: пользователи представлены как акторы, адреса электронной почты — как адреса акторов;
* веб-сервисы с конечными точками (например, SOAP) можно интерпретировать как акторов, обрабатывающих сообщения по своему адресу.


В TON все активные сущности — это акторы. 
Аккаунт - это актор который опредялется следующими свойствами.

- Общее состояние аккаунта (ID, balance, status)
- Состояние (data)
- Поведение (code)

Любой аккаунт в блокчейне определен по-крайней мере (адресом, балансом и статусом).

* (ID1, 0, unexist)
* (ID2, 10, uninit)
* (ID3, -0.5, frozen)

![](/img/docs/blockchain-fundamentals/account.svg)

Аккаунт у которого помимо общего состояния аккаунта определено его состояние и поведение называют смарт-контрактом.

Разница между аккаунтом и смарт-контрактом
* Аккаунт — актор содержащий общее состояние (т.е., баланс, адресс, состояние) и опционально код и состояние.
  * (ID1, 0, unexist)
  * (ID2, 2, inited, data, code)

* Смарт-контракт — актор с обязательно заполненным кодом и состоянием, определяющим его уникальное поведение.
  * (ID2, 2, inited, data, code)

![](/img/docs/blockchain-fundamentals/smart_contract.svg)


#### Структура сущностей в TON Блокчейне

![](/img/docs/blockchain-fundamentals/structure.svg)


#### Асинхронность

В TON контракты (акторы) не вызывают друг друга напрямую. Вместо этого они отправляют сообщения, каждое из которых обрабатывается отдельно и независимо. Вся коммуникация происходит через сообщения, и она асинхронна.

**Асинхронность** — это свойство взаимодействия, при котором отправка сообщения не требует немедленной готовности получателя.

* Отправитель не ожидает ответа немедленно — он просто отправляет сообщение.
* Получатель может обработать сообщение позже, когда дойдет очередь.
* Если результат важен, получатель должен явно отправить новое сообщение в ответ — иначе отправитель ничего не узнает.

Это отличие от синхронных моделей, где можно вызвать → получить ответ → продолжить логику. В TON результат может прийти только в виде нового сообщения, и только если его отправили явно.

![](/img/docs/blockchain-fundamentals/actors_msging.svg)


### Структура и взаимодействия акторов в TON
#### Аккаунт

Раннее мы проговорили, что аккаунт это актор описанный свойствами:
- Общее состояние аккаунта (ID, balance, status)
- Состояние (data)
- Поведение (code)

В действительности данные расположены несколько сложнее, однако логически различие аккаунта и смарт контракта останется таким же.
Для описания структуры данных в TON используется TL-B схемы, которые определяют маску расположения данных побитово. 
Рассмотрим как описан аккаунт


Структура аккаунт определена несколькоими вложенными объектами:

```tlb
account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```
* адрес `MsgAddressInt`,
* баланс `CurrencyCollection`,
* состояние `AccountState`, определяющее его поведение.
* время последней применённой транзакции у аккаунта (logical time) `last_trans_lt`,
* статистику хранилища `StorageInfo`

<details>

  ```tlb

  account_none$0 = Account;
  account$1 addr:MsgAddressInt storage_stat:StorageInfo
  storage:AccountStorage = Account;

  account_storage$_ last_trans_lt:uint64
  balance:CurrencyCollection state:AccountState
  = AccountStorage;

  account_uninit$00 = AccountState;
  account_active$1 _:StateInit = AccountState;
  account_frozen$01 state_hash:bits256 = AccountState;

  acc_state_uninit$00 = AccountStatus;
  acc_state_frozen$01 = AccountStatus;
  acc_state_active$10 = AccountStatus;
  acc_state_nonexist$11 = AccountStatus;


  _ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

  ```

</details>

Уточним согласно TL-B схеме, какие свойства относятся к общему состоянию аккаунта:

- Общее состояние аккаунта
- ID -> `MsgAddressInt`
- balance -> `CurrencyCollection`
- status -> `AccountState`
- `last_trans_lt` - тоже часть общего состояния


В то время, как  cостояние (data) и поведение (code) определяется в поле `state:AccountState`.

Рассмотрим подробнее общее состояние аккаунта и как оно определяется в данных.

#### Состояние аккаунта

В TON определяется состояния аккаунта (`AccountState`):

| Состояние  | TL-B код | Описание                                                                                                                                   |
| ---------- | -------- |--------------------------------------------------------------------------------------------------------------------------------------------|
| `uninit`   | `00`     | Аккаунт существует, но не содержит кода и данных. Может иметь баланс, но ещё не активирован.                                               |
| `frozen`   | `01`     | Аккаунт заморожен, состояние(код и данные) удалены, но сохранён хэш его состояния. Он не может использоваться, но может быть восстановлен. |
| `active`   | `10`     | Аккаунт содержит `StateInit` с кодом и данными. Это активный смарт-контракт, готовый обрабатывать сообщения.                               |


```tlb
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;
```



#### Смарт контракт

Смарт-контракт — актор с обязательно заполненным кодом и состоянием, определяющим его уникальное поведение.
Если перевести на язык конкретных данных, получаем:
* Смарт-контракт в TON — это `Account`, находящийся в активном состоянии `AccountState = active`
* В `StateInit` инициализированно поле `code`.
* В `StateInit` инициализированно поле `data`.

Наличие `code` и `data` в `StateInit` делает аккаунт исполняемым и определяет его как смарт-контракт.


#### Адрес

Адрес в TON — это уникальный идентификатор аккаунта или смарт контракта, необходимый для взаимодействия между участниками сети. Он состоит из следующих компонентов:

* WorkChain ID — 32-битное знаковое целое число, определяющее WorkChain, к которой принадлежит аккаунт (например, -1 для MasterChain, 0 для BaseChain).
* Account ID — 256-битный хэш структуры `StateInit`, которая содержит начальное состояние контракта: `code`, `data` и (опционально) `library`.

Адрес определяется:

<BlockMath math="{Address} := ({workchain\_id},{account\_id})" />, где <BlockMath math= "{account\_id}:= {SHA256(BoC(StateInit))}" />, где BoC (bag of cells) это специальный формат сериализации данных в TON.

Такой адрес соответствует определённому начальному состоянию контракта и может быть вычислен до его реального развёртывания. Это позволяет использовать его до фактической инициализации — например, для приёма токенов или подготовки взаимодействий.


:::important
Адрес зависит только от `StateInit`. Даже незначительное изменение кода, данных или библиотеки приводит к полностью новому `account_id`.
При этом `StateInit` описывает *только начальную конфигурацию* контракта — не включая баланс, текущие данные, очередь сообщений и другие параметры, которые могут изменяться во времени.
Эти изменения **не влияют** на адрес. При этом валидаторы перепроверяют адрес отправителя при обработке сообщения и, если он некорректен, заменяют его на корректный.
:::



#### Message feature

Сообщение это набор инструкций по желаемым действиям к одному актору.

#### Transaction feature

Транзакция — это обновление состояния аккаунта в блокчейне, инициированное входящим сообщением и, при необходимости, завершающееся отправкой одного или нескольких исходящих сообщений.

Транзакция в TON нужна для того, чтобы изменить состояние аккаунта в ответ на входящее сообщение и, при необходимости, продолжить взаимодействие с другими аккаунтами через исходящие сообщения.

#### Асинхронная природа транзакций

В TON все аккаунты взаимодействуют исключительно посредством **сообщений** — это основа коммуникации между акторами. Каждое сообщение становится частью транзакции, которая описывает полную историию чем каким сообщением было инциировано, как изменилось состояние и были ли отправлены новые сообщения.

Транзакции в сети обрабатываются **асинхронно**, что означает, что вызовы и изменения состояния аккаунтов происходят независимо друг от друга во времени.

#### AccountChain

**AccountChain** — это цепочка транзакций, выполненных на одном аккаунте в TON-блокчейне. Она представляет собой линейную последовательность: `Tx1 → Tx2 → Tx3 → …`, где каждая транзакция ссылается на предыдущую. Для удобства обработки и достижения консенсуса транзакции группируются в блоки — например, `[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]`. В блоках также содержатся очереди входящих и исходящих сообщений, фиксирующие все события и изменения состояния аккаунта за данный период.

Другими словами, AccountChain представляет собой «микро-блокчейн» одного аккаунта. Он хранит и упорядочивает всю историю операций и взаимодействий аккаунта, обеспечивая прозрачность и прослеживаемость.

В масштабе всей сети множество таких цепочек объединяются в ShardChain (или просто «шард»), который отвечает за обработку группы аккаунтов. Эта абстракция введена для удобства группировки логических элементов (AccounChain) на физических носителях (ShardChain ←→  Validator).


#### ShardChain

ShardChain — это блокчейн, объединяющий множество AccountChain-ов, то есть индивидуальных цепочек транзакций разных аккаунтов. Если AccountChain описывает историю операций одного аккаунта, то ShardChain отвечает за обработку и хранение данных целой группы аккаунтов с одинаковым бинарным префиксом в их адресах (например, все адреса начинаются с `0b00101`).

ShardChain можно представить как «горизонтальный» блокчейн, составленный из ShardBlocks, каждый из которых агрегирует AccountBlocks — блоки отдельных аккаунтов. ShardChain-ы также участвуют в маршрутизации сообщений между аккаунтами, гарантируя их доставку и соблюдение порядка: если одно сообщение было отправлено раньше другого, оно и прибудет раньше.

Таким образом, ShardChain — это ключевая структурная единица TON, которая обеспечивает параллельную обработку транзакций в масштабируемой и детерминированной архитектуре.


#### WorkChain

WorkChain — это самостоятельный блокчейн внутри TON, объединяющий множество ShardChain-ов (шардов). В отличие от шарда, WorkChain может иметь свои собственные правила. (пояснить)

TON поддерживает до 2³² WorkChain'ов, каждый из которых может быть разбит на 2⁶⁰ шардов.

#### Type of WorkChain: MasterChain and BaseChain

MasterChain — главный координирующий блокчейн. Он содержит:
* параметры протокола,
* список валидаторов и их стейки,
* аккаунтчейны валидторов
* мета-информацию о всех активных WorkChain’ах и ShardChain’ах,
* хэши последних блоков всех других цепочек.

MasterChain важен для функционирования всей сети, но из-за высокой стоимости используется для системных целей. На самом деле для обеспечения стабильности и отсутствия спама, здесь намеренно установленые высокие цены на газ.

BaseChain — основная рабочая цепочка, предназначенная для ежедневных транзакций и смарт-контрактов. Она недорогая и подходит для обычных пользователей и разработчиков.

Таким образом, из-за наличия ShardChain-ов, WorkChain-ов мы можем сказать, что TON блокчейн это блокчейн блокчейнов, то есть, цепочка связанных блоков, где каждый следующий блок ссылается на предыдущий через хэш.

![](/img/docs/blockchain-fundamentals/chains_of_chains.svg)

Таким образом, из-за наличия ShardChain-ов, WorkChain-ов мы можем сказать, что TON блокчейн это блокчейн блокчейнов, то есть, епочка связанных блоков, где каждый следующий блок ссылается на предыдущий через хэш.

#### Testnet and Mainnet

#### Mainnet (основная сеть)

Mainnet — это настоящая сеть, где:

* все транзакции реальны и необратимы;
* используются настоящие токены (например, реальные Toncoin);
* любые действия (переводы, запуск смарт-контрактов) влияют на основной блокчейн.

Все пользователи и проекты, которые работают “в продакшене”, используют именно Mainnet.

#### Testnet (тестовая сеть)

Testnet — это песочница для разработчиков, копия основной сети, но без риска. В ней:

* используются тестовые монеты, которые не имеют ценности;
* можно свободно тестировать контракты, транзакции, DApps и ошибки;
* блокчейн может быть сброшен или изменён в любой момент.

Testnet нужен, чтобы безопасно разрабатывать и отлаживать проекты, прежде чем запускать их в основной сети.

## Сообщения

В блокчейне TON сообщение — это фундаментальная единица взаимодействия между аккаунтами (смарт контрактами). Все действия, изменения состояния и выполнение логики в системе происходят через отправку и получение сообщений. Сообщения можно сравнить с запросами, отправляемыми на сервер.

## Transaction and message real life examples

Представьте город в котором функционирует городска почта и люди-акторы не покидают своих домов. Для общения люди могут принимать сообщение с запросом на какую-либо работу, делать работу внутри дома, и прикладывать отчет о проделанной работе, отправлять другому жителю.
Каждый человек будет выходить к почтовому ющику забирать ровно одно входящее письмо и затем запираться наглухо дома, пока не выполнят работу о которой их попросили.
В процессе их работы могут приходить новый письма но их это не отвелчет. Также, если внутри дома, в процессе работы они поймут что им не хватает какой-то информации, они не могут прерваться для уточнения. В таком случае, человеку, потребуется признать что работа невыполнима, и в лучшем случае он отправит обратно обрывки исходных инструкций и остатки незатраченных средств.
Если же работа прошла успешно человек, согласно изначальному запросу может отчитаться отправив новые сообщения от себя или просто уложить на хранения у себя в доме изготовленные по запросу изделия. После этого человек выходит проверять входящую почту, и берет очередное входящее сообщение.


Теперь представим, что на каждый эпизод работы человек ведет подробный журнал. Чтобы разделять свой труд и удобно хранить историю, он каждую выполненную работу он опишет как транзакцию. В его случае транзакция будет содержать в себе основание для работы - полная опись входящего сообещния, запись о том что за изделие он изготовил и куда его уложил, и опционально информацию о проделанной работе отправленная другому человеку.

Сообщения доставляемые по почте между жителями домов это Internal сообщения. Если же мы отправим сообщение с другого города о котором мы мало что знаем, на там четко указан получатель этого города. Это особое входящее внешнее сообщение -external in сообщение.
External in и External out сообщения глобально выполняют одинаковую функцию для акторов, однако каждый актор по разному ведет себя с этими сообщениями, а иногда и вовсе может не воспринять сообщение извне. (Очень закрытый от внешнего мира человек)

#### Message structure TL-B

Теперь о данных в сообщении. Мы уже говорили что и в external, и internal сообщениях могут содержаться какие-то данные. Но как именно эти данные передавать? В TON все данные представлены в виде ячеек. Для того чтобы закодировать данные в ячейку, существует общепринятый стандарт для описания сериализации этих данных – TL-B (Type Language - Binary).

## Particular message structure

```
message$_ {X:Type} info:CommonMsgInfo
init:(Maybe (Either StateInit ^StateInit))
body:(Either X ^X) = Message X;
```

* `info: CommonMsgInfo` — содержит метаданные сообщения.
* `init: (Maybe (Either StateInit ^StateInit))` — необязательные данные, используемые для инициализации аккаунта или обновления его состояния.
* `body: (Either X ^X)` — основное содержимое (полезная нагрузка) сообщения, которое может быть либо непосредственными данными, либо ссылкой на данные.

* Headers fields (CommonMsgInfo)


### Типы сообщений

Всего есть три типа сообщений:
- internal
- external incoming
- external outgoing


### Internal

Internal сообщение — это сообщение, отправленное от одного смарт-контракта другому внутри блокчейна TON. Когда смарт-контракт получает внутреннее сообщение, он знает:

* сколько монет TON прикреплено к сообщению,
* кто отправитель этого сообщения.
* блокчейн гарантирует целостность этой информации, что позволяет смарт-контракту безопасно ей доверять и использовать.

**TL-B:**

```
//internal message
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
src:MsgAddressInt dest:MsgAddressInt
value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

### External incoming

Прежде чем смарт-контракты смогут взаимодействовать друг с другом, отправляя внутренние сообщения, они должны быть активированы или профинансированы. Но как смарт-контракты получают свои первые Toncoin?

Некоторые сообщения поступают в систему извне блокчейна — то есть они не создаются существующими аккаунтами внутри сети. Такие сообщения называются *external incoming* сообщениями.

External incoming — это точка входа во внешний мир для блокчейна TON. Любой пользователь может отправить произвольные данные любому смарт-контракту, и уже контракт решает, как с ними обращаться.

Обычно они поступают от:

* пользователей — например, при отправке транзакции из кошелька;
* валидаторов или off-chain сервисов;
* ботов или скриптов — для автоматизации взаимодействия.

Хотя external-in сообщения редко используются в основной логике смарт-контрактов, они важны для кошельков. Почти каждое пользовательское действие в TON — например, отправка TON или взаимодействие с DEX — начинается с внешнего входящего сообщения от кошелька пользователя. После этого сам кошелек отправляет внутренние сообщения другим контрактам.

**TL-B:**
```
//external incoming message
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt
import_fee:Grams = CommonMsgInfo;

```

### External outgoing

External outgoing сообщения (external-out messages), также известные как events (события) — это особый тип сообщений, создаваемых смарт-контрактами, которые не доставляются конкретному получателю. Вместо этого они служат как логи или сигналы, которые можно отслеживать вне блокчейна.

Хотя такие сообщения редко используются в основной логике работы блокчейна, они играют важную роль в следующих задачах:

* индексация и мониторинг состояния блокчейна;
* запуск off-chain процессов, таких как уведомления внешних сервисов или обновление пользовательского интерфейса.

Например, смарт-контракт децентрализованной биржи (DEX) может сгенерировать внешнее исходящее сообщение после успешного обмена токенов — чтобы уведомить внешние сервисы или пользователей об этом событии.

**TL-B:**
```
//external outgoing message
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```


External message examples and typical using
Internal message examples and typical using

Message value


#### Bounce of messages

Bounce message — это сообщение, которое автоматически отправляется обратно отправителю при неудачной транзакции. Например, если смарт-контракт получателя не существует или завершил выполнение с ошибкой.
Оно позволяет не просто зафиксировать ошибку, но и обработать её: отправитель может получить уведомление о проблеме и выполнить нужные действия, например, вернуть токены или показать пользователю сообщение об ошибке.

Большинство внутренних сообщений между смарт-контрактами должны быть bounceable, т.е. с установленным флагом `bounce`, чтобы при ошибке:

* Сообщение возвращалось отправителю,
* Оставшиеся средства (за вычетом комиссий) возвращались назад.

В свою очередь, cмарт-контракты обязаны:

* Проверять флаг `bounced` во входящих сообщениях,
* Либо игнорировать такие сообщения (завершение с кодом 0),
* Либо обрабатывать ошибку.

:::important
Cодержимое bounce-сообщения нельзя исполнять как обычный запрос — оно используется только для уведомления об ошибке.
:::

Address with flags as field of a message


External message is an initiation of Action

Define that we need build internal message and wrap this in external message.
* Serializators for messages. (Message builders)
* Types of message descriptors
* Дополнительные стандарты с TL-B (https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md)

#### Создание сообщение по TL-B

```
increase#34a3ff12 query_id:uint64 amount:uint32 = InternalMsgBody;
```

```
decrease#e4d5986b query_id:uint64 amount:uint32 = InternalMsgBody;
```

Это схема описывает 2 сообщения (сами данные). Когда мы работаем с сообщением, то тело сообщения и количество прикрепленных к нему TON – это два самых важных параметра.

В теле сообщения есть два конвенциональных поля – opcode и query_id. opcode – это 32-битное число означающее тип операции, а query_id – 64-битное число, которое смарт-контракт никак не должен использовать, и нужное лишь для удобства внешним сервисам.

Так в коде чтобы собрать тело сообщения

```
function generateMessageBody(amount: bigint): Cell {
const op = 0x34a3ff12;
const queryId = randomUint64();
const body = beginCell()
.storeUint(op, 32)
.storeUint(queryId, 64)
.storeUint(amount, 32)
.endCell();

    return body;
}
```
  * Build message serializer according to TL-B
  * Ресиверы в коде  (https://github.com/ton-blockchain/highload-wallet-contract-v3)
  * Build message serializer according to source code
  * Assembler (blockchain explorer preview/ https://tonviewer.com/EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1?section=code )

## Хэши в TON Blockchain

Хэши играют критически важную роль в экосистеме TON, обеспечивая идентификацию и верификацию данных на всех уровнях блокчейна. Понимание того, как работают хэши, поможет вам эффективно отслеживать транзакции, верифицировать сообщения и интегрировать ваши приложения с TON.

### Что такое хэш?

В контексте TON хэш — это уникальный криптографический отпечаток данных, вычисленный с помощью алгоритма SHA-256. Каждая ячейка (Cell), сообщение или транзакция имеют свой уникальный хэш, который служит их цифровой подписью.

### Представление данных в TON
Все данные в TON хранятся в ячечейках. Концпетуально это структура содержащая 1023 бита и 4 ссылки на другие ячейки. Серилизованные деревья ячеек запаковываются по единому стандарту ячеек 


В Tl-B это структура Bag of cells (BoC):

```tlb


serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1) 
  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }
  size:(## 3) { size <= 4 }
  off_bytes:(## 8) { off_bytes <= 8 } 
  cells:(##(size * 8)) 
  roots:(##(size * 8)) { roots >= 1 }
  absent:(##(size * 8)) { roots + absent <= cells }
  tot_cells_size:(##(off_bytes * 8))
  root_list:(roots * ##(size * 8))
  index:has_idx?(cells * ##(off_bytes * 8))
  cell_data:(tot_cells_size * [ uint8 ])
  crc32c:has_crc32c?uint32
  = BagOfCells;

```

Подробное понимание этой схемы не требуется, так как в инструментах разработки TON, SDK уже реализованы хелперы которые выстраивают эту структуру за разработчика.


### Типы хэшей в TON

:::info Важно
Хэши в TON необратимы — по хэшу нельзя восстановить исходные данные. Однако они детерминированы — одни и те же данные всегда дают одинаковый хэш.
:::

#### Хэш тела сообщения

Хэш тела сообщения — это уникальный идентификатор содержимого вашего сообщения. Он вычисляется от ячейки, содержащей данные сообщения.

Тело сообщения, это часть сообщения, котора лежит в элементе `body:(Either X ^X)`:

```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

```

Разберем пример тела сообщения с комментарием "Hello, TON!" и вычислим его хэш.

```typescript
import { beginCell } from '@ton/core';

// Создаем тело сообщения для увеличения счетчика
const messageBody = beginCell()
        .storeUint(0, 32) // op code
        .storeStringTail("Hello TON!")
        .endCell();

console.log("Message Body Hash:", messageBody.hash().toString("hex"));
```

**Когда использовать хэш тела сообщения:**
- Для проверки целостности данных
- При отладке и логировании операций
- Для дедупликации сообщений в вашем приложении

#### Хэш полного сообщения

Полное сообщение включает не только тело, но и заголовки с метаданными (отправитель, получатель, сумма, комиссии).
Его хэш — это уникальный идентификатор всего сообщения.

Например, для Internal message, это структура `Message X` определенная следующим TL-B

```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

  
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

**Практический пример:**

```typescript
import { storeMessage, beginCell, internal, Address } from '@ton/ton';
import { toNano } from '@ton/core';

// Создаем внутреннее сообщение
const internalMessage = internal({
  to: Address.parse('EQB...'), // адрес получателя
  value: toNano('0.1'),        // 0.1 TON
  body: messageBody             // тело сообщения из предыдущего примера
});

// Получаем хэш полного сообщения
const messageCell = beginCell()
  .store(storeMessage(internalMessage))
  .endCell();

const fullMessageHash = messageCell.hash();
console.log('Full Message Hash:', fullMessageHash.toString('hex'));
// Вывод: Full Message Hash: f1e2d3c4b5a6987...
```

**Когда использовать хэш полного сообщения:**
- Для отслеживания конкретных сообщений в блокчейне
- При работе с API TON Center для поиска транзакций
- Для верификации того, что сообщение не было изменено

#### Хэш транзакции

Хэш транзакции — это уникальный идентификатор всей транзакции.
Хэш транзакции зависит от всех данных в ней, таких как входящие и исходящие сообщения, изменения состояния и комиссии. Эти данные появляются только после выполнения транзакции и хеш тоже может быть вычислен после её записи в блокчейне.

**Практический пример получения хэша транзакции:**

```typescript
import { TonClient } from '@ton/ton';
import { Address } from '@ton/core';

const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
  apiKey: 'your-api-key'
});

const transactions = await client.getTransactions(
  Address.parse('EQB...'),
  { limit: 10 }
);

for (const tx of transactions) {
  const txHash = tx.hash();
  console.log('Transaction Hash:', txHash.toString('hex'));

  // Также можем получить хэш входящего сообщения
  if (tx.inMessage) {
    const inMsgCell = beginCell()
      .store(storeMessage(tx.inMessage))
      .endCell();
    const inMsgHash = inMsgCell.hash();
    console.log('Incoming Message Hash:', inMsgHash.toString('hex'));
  }
}
```

#### Нормализованный хэш сообщения

Нормализация это понятия стандартизации которое сводит разные представления к единой форме. Сообщение в разных интерфейсах определялось в соответствии с TL-B, но все же иногда происходили коллизии где структуру представляли разным способом.
Чтобы решить эту проблему в экосистеме был проработан стандарт, который поможет всем одинакого расчитывать хэш.
Нормализация подробно определена в стандарте [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467).

**Проблема, которую решает нормализация:**

Функционально идентичные сообщения могут быть софрмированы разным способом для полей `src`, `import_fee` и `init`. Таким образом появляется проблема различных хешей, для фактически одинакового набора данных. Это усложняет отслеживание транзакций и дедупликацию.

**Как работает нормализация:**

Нормализованный хэш вычисляется путем стандартизации следующих полей external-in сообщения:

1. **Source Address (`src`)**: Устанавливается в `addr_none$00`
2. **Import Fee (`import_fee`)**: Устанавливается в `0`
3. **InitState (`init`)**: Устанавливается в пустое значение
4. **Body**: Всегда сохраняется как ссылка

**Практический пример вычисления нормализованного (Normilized hash) хэша:**

```typescript
import { toNano, beginCell, Cell, Address } from "@ton/core";

function normalizeExternalMessage(destAddress: Address, bodyCell: Cell): Cell {
    try {
        const normalizedExtMessage = beginCell()
            .storeUint(0b10, 2) // ext_msg prefix (10 in binary)
            .storeUint(0, 2) // src -> addr_none (НОРМАЛИЗАЦИЯ!)
            .storeAddress(destAddress) // Address.parse(destAddress.toString({ bounceable: false })) если пытаться использовать .address из WalletContractV4
            .storeCoins(0) // import_fee:Grams -> 0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(false) // init:(Maybe (Either StateInit ^StateInit)) -> nothing$0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(true) // body:(Either X ^X) -> right$1 (НОРМАЛИЗАЦИЯ!)
            .storeRef(bodyCell) // Store body as reference (НОРМАЛИЗАЦИЯ!)
            .endCell();

        return normalizedExtMessage;
    } catch (error: any) {
        console.error("❌ Error in normalization:", error.message);
        throw error;
    }
}

// Пример использования
const messageBody = beginCell()
  .storeUint(0, 32) // opcode для простого перевода
  .storeStringTail('Normalized hash example')
  .endCell();

const destinationAddress = Address.parse('EQB...');
const normalizedExternalMessage = normalizeExternalMessage(destinationAddress, messageBody);
const normalizedHash = normalizedExternalMessage.hash().toString("hex");

console.log('Normalized Message Hash:', normalizedHash);
```


**Практический пример вычисления ненормализованного (Non-normilized hash) хэша:**

```typescript
import { toNano, beginCell, Cell, Address, external, internal } from '@ton/ton';

// 1. Создание тела сообщения
const messageBody = beginCell()
    .storeUint(0, 32) // op code
    .storeStringTail("Hello TON!")
    .endCell();

// 2. Создание intenal message через wrapper
const internalMessage = internal({
    to: walletAddress,
    value: toNano("0.01"),
    body: messageBody
});
// 3. Создание external message через wrapper
const externalMessage = await contract.createTransfer({
    seqno,
    secretKey: keyPair.secretKey,
    messages: [internalMessage]
});

const originalHash = externalMessage.hash().toString("hex");
console.log("\nNon-normalized External Message Hash:", originalHash);

```

Этот алгоритм может быть любым отличным от нормализованного. Если отсутствие нормализации стало проблемой проекта который был ранее разарботан, то правильно сделать миграцию на нормолизованные хеши во всем проекте.


### Отправка сообщения и проверка факта отправки

Один из наиболее важных сценариев — это отправить сообщение и убедиться, что оно было обработано блокчейном.

**Пошаговый процесс:**

```typescript
import { WalletContractV4, internal, TonClient } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';
import { Address, toNano, beginCell } from '@ton/core';

async function sendAndVerifyMessage() {
  // 1. Создаем клиент и кошелек
  const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC'
  });

  const mnemonic = 'your mnemonic words here';
  const keyPair = await mnemonicToPrivateKey(mnemonic.split(' '));
  const wallet = client.open(WalletContractV4.create({
    publicKey: keyPair.publicKey,
    workchain: 0
  }));

  // 2. Создаем сообщение с комментарием
  const messageBody = beginCell()
    .storeUint(0, 32)           // opcode для простого перевода
    .storeStringTail('Hello TON!')
    .endCell();

  // 3. Отправляем транзакцию
  const seqno = await wallet.getSeqno();
  await wallet.sendTransfer({
    secretKey: keyPair.secretKey,
    seqno,
    messages: [internal({
      to: Address.parse('EQB...'),
      value: toNano('0.01'),
      body: messageBody
    })]
  });

  // 4. Проверяем факт отправки через некоторое время
  await new Promise(resolve => setTimeout(resolve, 10000)); // ждем 10 секунд

  const newSeqno = await wallet.getSeqno();
  if (newSeqno > seqno) {
    console.log('Транзакция успешно обработана!');

    // 5. Находим нашу транзакцию и получаем её хэш
    const transactions = await client.getTransactions(wallet.address, { limit: 5 });
    const ourTx = transactions.find(tx =>
      tx.inMessage?.info.type === 'external-in' &&
      tx.description.type === 'generic'
    );

    if (ourTx) {
      const txHash = ourTx.hash();
      console.log('Transaction Hash:', txHash.toString('hex'));
    }
  } else {
    console.log('Транзакция не была обработана');
  }
}
```

### Поиск транзакции по BOC

Когда пользователь подтверждает отправку external сообщения через TON Connect, вы получаете BOC (Bag of Cells). Вы можете использовать этот BOC для поиска соответствующей транзакции в блокчейне.

**Практический пример:**
<details>
```typescript
import { Cell, Address, beginCell, storeMessage, TonClient } from '@ton/ton';

async function findTransactionByBOC(
  externalBOC: string,
  walletAddress: string
  ): Promise<string | null> {
  const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
  apiKey: 'your-api-key'
});

  try {
    // Получаем хэш внешнего BOC
    const extHash = Cell.fromBase64(externalBOC).hash().toString('hex');

    // Получаем последние транзакции кошелька
    const transactions = await client.getTransactions(
      Address.parse(walletAddress),
      { limit: 10 }
    );

    for (const tx of transactions) {
      const inMsg = tx.inMessage;
      if (inMsg?.info.type === 'external-in') {
        // Создаем хэш входящего сообщения
        const inHash = beginCell()
          .store(storeMessage(inMsg))
          .endCell()
          .hash()
          .toString('hex');

        console.log('External BOC hash:', extHash);
        console.log('Transaction message hash:', inHash);

        // Если хэши совпадают, мы нашли нашу транзакцию
        if (extHash === inHash) {
          const txHash = tx.hash().toString('hex');
          console.log('Найдена транзакция:', txHash);
          return txHash;
        }
      }
    }

    throw new Error('Транзакция не найдена');
  } catch (error) {
    console.error('Ошибка поиска транзакции:', error);
    return null;
  }
}

// Пример использования
const txHash = await findTransactionByBOC(
  'te6cckEBAgEAqQAB4YgA+yKcnwQCs1xAwIEKKB4DvkIdXNjL6B...',
  'EQB...'
  );
  ```
  
</details>


### Практические советы

#### Проверка статуса транзакции через API

```typescript
// Проверяем статус транзакции по её хэшу
async function checkTransactionStatus(txHash: string, walletAddress: string) {
  try {
    const response = await fetch(
      `https://testnet.toncenter.com/api/v2/getTransactions?` +
      `address=${walletAddress}&hash=${txHash}`
    );
    const data = await response.json();

    if (data.result.length > 0) {
      console.log('Транзакция найдена в блокчейне');
      return data.result[0];
    } else {
      console.log('Транзакция не найдена');
      return null;
    }
  } catch (error) {
    console.error('Ошибка при проверке транзакции:', error);
    return null;
  }
}
```

#### Хэш StateInit для верификации адресов

В [TON Connect](v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#backend-example) часто требуется верифицировать соответствие между адресом кошелька и его StateInit. Хэш StateInit должен совпадать с хэш-частью адреса.

**Практический пример верификации адреса:**

```typescript
import { Address, contractAddress } from '@ton/ton';

// Пример использования в TON Connect
const wantedAddress = Address.parse(payload.address);
const address = contractAddress(wantedAddress.workChain, stateInit);
if (!address.equals(wantedAddress)) {
  return false;
}
```

#### Мониторинг в реальном времени

```typescript
// Пример функции для мониторинга входящих транзакций
async function monitorIncomingTransactions(walletAddress: Address, client: TonClient) {
  let lastLt = '0';

  setInterval(async () => {
    try {
      const transactions = await client.getTransactions(walletAddress, {
        limit: 10,
        lt: lastLt
      });

      for (const tx of transactions) {
        if (tx.lt > lastLt) {
          const txHash = tx.hash();
          console.log('Новая транзакция:', txHash.toString('hex'));

          // Обрабатываем входящие сообщения
          if (tx.inMessage) {
            const msgCell = beginCell()
              .store(storeMessage(tx.inMessage))
              .endCell();
            const msgHash = msgCell.hash();
            console.log('Хэш сообщения:', msgHash.toString('hex'));
          }

          lastLt = tx.lt;
        }
      }
    } catch (error) {
      console.error('Ошибка мониторинга:', error);
    }
  }, 5000); // проверяем каждые 5 секунд
}
```

### Лучшие практики

1. **Всегда сохраняйте хэши**: Записывайте хэши важных транзакций и сообщений для последующего отслеживания.

2. **Используйте правильный тип хэша**: Для отслеживания транзакций используйте хэш транзакции, для верификации данных — хэш сообщения.

3. **Учитывайте время подтверждения**: В TON транзакции обычно финализируются за 3-6 секунд, но в периоды высокой нагрузки может потребоваться больше времени.

4. **Реализуйте логику перезапуска алгоритма**: Если транзакция не появилась в блокчейне в течение минуты стоит повторить повторить сообщения.

## Отправка сообщения

Есть два практических и важных для отличия случая, как можно отправить сообщение в блокчейн. Либо мы отсылаем сообщение с бэкенда являемся владельцем кошелька и можем сразу подписать и отправить сообщение в блокчейн, либо используя TON Connect на фронтенде мы можем собрать сообщение и предложить пользователю подписать и отправить его самому.

### Отправка с бэкенда

Когда у нас есть кошелек с сид фразой отправление сообщения происходит так
Код [отсюда](/v3/guidelines/dapps/cookbook/#how-to-transfer-ton-and-send-a-text-message-to-another-wallet)

### Отправка с фронтенда (TON Connect)
Тут мы просто предлагаем пользователю подписать сообщение

```
const myTransaction = {
validUntil: Math.floor(Date.now() / 1000) + 60, // 60 sec
messages: [
{
address: destination, // Address of smart contract to send internal message to
amount: amount, // Amount in nanotons to attach to the message
payload: Base64.encode(messageBody.toBoc())
}
]
}

tonConnectUI.sendTransaction(myTransaction)

```
## Get методы
Get methods
Build get method wrapper
Get balance
Get jetton wallet address
Get collection data

## Blockchain HTTP API
### Основные сервисы в TON

Мы рассмотрим сервисы которые выстраивают инфраструктуру нативно, другие поставщики API скорее всего используют одно из этих типовых решений.. Мы рекомендуется оценивать качество провайдера самостоятельно на основании исторических данных  и подходящих решений для вашей конкретной задачи.

#### TON Center
Сервисы TON Center это решение которое строится ресурсом команды TON Core на стеке GO. У TON Center два отдельных сервиса
TON Center API V3, который поставляет решения для индексации блокчейна.
TON Center API V2, который поставляет решения для быстрой чтения и отправки в блокчейн сообщений.

#### TON API
Решение в котором сфокусированы на поставление решинии бизнес задач и зачастую предлагает готовые решения для типовых задач в TON.

#### TONX API
API сервис начавший свое развитие TON Center, но продолжил закрытую разработку и расширение интерфейсов под нужды клиентов.

#### Tonhub API
HTTP API сервис с уникальной структурой, отличной от TON API и TON Center. Существуют задачи, для которых этот сервис подходит лучше.

### Транзакция это часть блока.

HTTP сервисы читают данные с Liteserver нод и десерализуют данные согласно стандартам описанным в TL-B. Данные которые минимально подвергаются постпроцессингу, иногда называют RAW data. Такие данные используются сервисами для самостоятельной аналитики, когда архитектурно важнее сделать решение более безопасным затратив на это больше внутреннего ресурса. Напротив, решения, которые не связанны с большим движением средств, но требуют какой-то аналитики событй в TON целесообразней имплементировать с помощью верхнеуровневых интерфейсов - интерфейсов API которые добавляют postprocessing информацию в выдоваемые данные.

Транзакция в TON упаковывается в блоки. Зафиналенные блоки БейсЧеина записываются в МастерЧейн блок. Соответственно для извлечения данных о выполненных транзакциях при читаются блоки MasterChain и соответствутющие блоки BaseChain. Кроме этого вложения, в TON всегда присутствует шардирование, которое тоже учитывается при парсинге каждого мастерчейн блока. Полученные блоки для каждого шарда, содержат все транзакции соответсвующие изначальному мастерчейн блоку.
У блоков всех воркчейнов одинаковая структура, для исследования транзакций, исследуется `block_extra`.

```tlb
block#11ef55aa global_id:int32
info:^BlockInfo value_flow:^ValueFlow
state_update:^(MERKLE_UPDATE ShardState)
extra:^BlockExtra = Block;
```
В свою очередь, часть блока `block_extra` содержит в себе структуру `account_blocks`. Именно в `account_blocks` содержатся транзакции обрабатанные всеми аккаунтами в соответсвующем шарде в пределах этого блока.

```tlb
block_extra in_msg_descr:^InMsgDescr
out_msg_descr:^OutMsgDescr
account_blocks:^ShardAccountBlocks
rand_seed:bits256
created_by:bits256
custom:(Maybe ^McBlockExtra) = BlockExtra;
```

Таким образом в процессе чтения блокчейна, сервисы итеративно обрабатывают от последнего считанного блока, до очередного нового зафиналенного.Полученные транзакции это RAW data, которая уже может выдаваться сервисам для дальнейшей работы. Так же, специальные сервисы анализируют и дополняют эти данные для удобства работы сервисов и балансирования между сложностью реализации и trustless подхода.

#### Статус аккаунта

Статус аккаунта - это статус, который описывает состояние аккаунта с точки зрения выполнения транзакции, но не является частью его хранимых данных. Существует 4 возможных значения `AccountStatus`, каждое из которых закодировано двумя битами в TL-B:


| Статус     | TL-B код | Описание                                                                                                     |
| ---------- | -------- |--------------------------------------------------------------------------------------------------------------|
| `nonexist` | `11`     | Аккаунт отсутствует в блокчейне — у него нет ни состояния, ни баланса.                                       |
| `uninit`   | `00`     | Аккаунт существует, но не содержит кода и данных. Может иметь баланс, но ещё не активирован.                 |
| `frozen`   | `01`     | Аккаунт удалён, но сохранён хэш его состояния. Он не может использоваться.                                   |
| `active`   | `10`     | Аккаунт содержит `StateInit` с кодом и данными. Это активный смарт-контракт, готовый обрабатывать сообщения. |

Наличие `code` в `StateInit` делает аккаунт исполняемым и определяет его как смарт-контракт.


:::important
Статус аккаунта используется только внутри транзакций (`orig_status` и `end_status`) и не сохраняется в самом аккаунте. Для хранения фактического состояния используется структура `AccountState`.
:::

### Подходы к получению транзакции из API блокчейна

Термины и их соотношение.

Transaction - это обновление состояния аккаунта в блокчейне, инициированное входящим сообщением и опционально завершаемое отправкой одного или нескольких исходящих сообщений. Анализ содержимого тела транзакции - это фундаментальный подход для всех сервисов.

Trace - Это детерменированный граф транзакций порожденный одним external сообщением. Интерфейсы с trace позволяют получить весь граф для конкретной транзакции, чтобы их удобно изучать все связанные транзакции. Биржи могут иногда использовать чтобы посмотреть что произошло, чтобы получить граф транзакций для дальнейшей. Можно использовать как дополнительный поиск jetton transfer без jetton notification.
Нужно использовать тогда, когда обработка бизнес операции зависит от множества условий в согласованных транзакциях.

Action - Это агрегированная абстракция над несколькими изменениями аккаунтов, которое соответсвует одной бизнес операции. Пример Action - Перевод жетонов между двумя пользователями. Используется только для визуализации, никакой логики для движения средств.


##### Анализ верхнеуровневых данных

Как получить массив транзакций или транзакцию с помощью API?

Использование верхнеуровневых интерфейсов для событий(или операций): Get /Actions, Get /Traces, GET /jetton/transfers(burns), GET /NFT, GET /Actions.
В данном подходе, разработчику не требуется анализировать содержимое транзакций. Подход, когда разработчик не перепроверяет данные, можно использовать только если не требуется выполнять движение средств. Кроме простых проверок для сервисов, этот подход может быть частью более сложных алгоритмов, например поиск всех связанных транзакций методом Traces для их дальнейшего анализа.

#### Поиск транзакции по содержимому сообщению

GetTranasction by (external/internal) message (только api/v3). https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_message Очень хорошо когда следишь за 1 аккаунтом (до ~10). wallet-v4/wallet-v5 отправка, идеально. В основном используется для нахождения тр которая порождена ext. Важный момент, что есть задержка до 10 секунд. Поэтому лучше решается через pending.


#### Поиск транзакции по адресу аккаунта
Запрашивать транзакции по аккаунту который ты слушаешь (только APIv2) https://toncenter.com/api/v2/#/accounts/get_transactions_getTransactions_get этот метод доступен везде, даже на Liteclient. До ~100 аккаунтов приемлимый.

#### Сканирование блокчейна для получения полного массива транзакций
Перебор все транзакции с последнего блока MasterChain. Если от 1000 до infinity количество прослушиваемых аккаунтов.

Обработка через api/v2 : shards -> compute shard diff -> getBlockTransactionsExt for each block (в доке: https://docs.toncenter.com/docs/ton-center-cookbook#how-to-scan-blockchain)

Обработка через api/v3: В api/v3 не использовать алгоритм api/v2, метод https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block.

Выбор: либо очень простая имплементация с высоким уровнем доверия крупным провайдерам, либо сложная имплементация в которой не приходится доверять провайдеру. Но для большей безопасности всегда рекомендуется самостоятельно процессить транзакции по блокам.

За исключением первого подхода, результат поиска данных - это массив с одной или нескольими транзакциями: Transaction[]

#### API Transaction body

Транзакции уникальные на уровне API/v2 и API/v3
Тело объекта транзакции в API соответствует изначальной структуре обозначенной в TL-B по набору данных, но дополнительно расширенно постпроцессно вычисленными особенностями транзакции.
Например, одним из самых важных полей, который не содержится в блокчейне но вычисляется сервисом это хеш транзакции

```json
"hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM="
```

В блокчейне обычная транзакция, это структура описанная полным телом и уникальным заголовком


```tlb
transaction$0111 account_addr:bits256 lt:uint64
    prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
    outmsg_cnt:uint15
    orig_status:AccountStatus end_status:AccountStatus
    ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
    total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
    description:^TransactionDescr = Transaction;
```

Заголовок, TransactionDescr, определеяет природу транзакции в блокчейне. Все пользовательские транзакции для работы сервисов являются обычным - Ordinary:


```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

API сервис десериализует всю структуру с точностью до строковых и числовых типов данных. В связи с этим, тело транзакции возращаемое в json

```curl
curl -X 'GET' \
  'https://toncenter.com/api/v3/transactions?limit=10&offset=0&sort=desc' \
  -H 'accept: application/json'
```

Возвращает очень большую структуру (пример для API/v3):

```json
 {
  "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF",
  "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
  "lt": "15371766000003",
  "now": 1696238450,
  "mc_block_seqno": 13353447,
  "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=",
  "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=",
  "prev_trans_lt": "15371704000004",
  "orig_status": "active",
  "end_status": "active",
  "total_fees": "12446659",
  "description": {
  ...
  },
  "compute_ph": {
   ....
  },
  "action": {
    ...
  },
  "block_ref": {
    ...
  },
  "in_msg": {
  ...
  },
  "out_msgs": [
   ...
  ],

  "account_state_before": {
    ...
  },

  "account_state_after": {
  ...
  }
}

```

<details>
  ```json
  {
    "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account of transcation
    "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
    "lt": "15371766000003", # logical time, may have same values for txs on different accounts but every transaction on a given account will have unique lt
    "now": 1696238450, # unix timestamp
    "mc_block_seqno": 13353447, # seqno of masterchain block
    "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=", # tx_hash of the root transaction of the trace
    "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=", # hash of previous transaction on this account
    "prev_trans_lt": "15371704000004", # lt of prev. transaction
    "orig_status": "active", # account status before transaction
    "end_status": "active", # ... after transaction
    "total_fees": "12446659", # ... sum of fees from description
    "description": {
    "type": "ord",
    "aborted": false,
    "destroyed": false,
    "credit_first": false,
    "storage_ph": {
    "storage_fees_collected": "48",
    "status_change": "unchanged"
  },
    "compute_ph": {
    "skipped": false,
    "success": true,
    "msg_state_used": false,
    "account_activated": false,
    "gas_fees": "8823000",
    "gas_used": "8823",
    "gas_limit": "400000",
    "mode": 0,
    "exit_code": 0,
    "vm_steps": 178,
    "vm_init_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    "vm_final_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  },
    "action": {
    "success": true,
    "valid": true,
    "no_funds": false,
    "status_change": "unchanged",
    "total_fwd_fees": "10871000",
    "total_action_fees": "3623611",
    "result_code": 0,
    "tot_actions": 1,
    "spec_actions": 0,
    "skipped_actions": 0,
    "msgs_created": 1,
    "action_list_hash": "9XTNK6e1Fmmhd3cdzI0XcNDYRAoP5f5L4bWPUD3KNIE=",
    "tot_msg_size": {
    "cells": "23",
    "bits": "8377"
  }
  }
  },
    # reference for the block of the transaction
    "block_ref": {
    "workchain": 0,
    "shard": "8000000000000000",
    "seqno": 14627985
  },
    # in message
    "in_msg": {
    "hash": "O9XCuICyXBWOs4hHMOYA0k6o4GPBsWbAkjFi2qbttQE=", # hash of whole message
    "source": "0:F0C9C78F021AC65839B4006321A68BBB32DE5025F84C853CB9D75EB4894D0848", # account who has sended this message
    "destination": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account who received this message (for in_msg should be same as account of transaction)
    "value": "400000000", # attached TONS
    "fwd_fee": "1494679", # fee for forwarding the message using Hypercube Routing
    "ihr_fee": "0", # fee for forwarding the message throught Instant Hypercube Routing (now IHR is not implemented so this should be added to value)
    "created_lt": "15371766000002", # logical time of creation (usually slightly differs from transaction lt, where this message appears as an out_msg)
    "created_at": "1696238450", # unix timestamp
    "opcode": "0x0f8a7ea5", # opcode
    "ihr_disabled": true,
    "bounce": true, # if bounce should be perfomed on failure
    "bounced": false, # if bounce has happened
    "import_fee": null,
    "message_content": { # message body
    "hash": "tWjTyEL/sabOLNt97uyCj5na740lW54GUcVa0UrSDao=", # hash of the message body
    # message body in base64 format
    "body": "te6cckEBAgEAiAABbQ+KfqUAAAAAdJizmkC/A/doAc9ztfOy5YIoBWjnofpWHchoFtAb/s4FvzXctxUu0Cf0ED8uUQMBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQIjm5Xw==",
    "decoded": null # text comment if it could be decoded
  },
    "init_state": null
  },
    "out_msgs": [
  {
    "hash": "FuV4JPR/uZZOCzZxWQ473bASToqChvKDLmnf5BiCspI=",
    "source": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # should coinside with transaction account for out_msg
    "destination": "0:794760D36E657A27CDB8D3D65F243D6B468CAD2C34AF413E7709390E4DBE9907",
    "value": "380306000",
    "fwd_fee": "7247389",
    "ihr_fee": "0",
    "created_lt": "15371766000004",
    "created_at": "1696238450",
    "opcode": "0x178d4519",
    "ihr_disabled": true,
    "bounce": true,
    "bounced": false,
    "import_fee": null,
    "message_content": {
    "hash": "o+VOluS6wdyl44k2AIFTcRBvdxZD/98275dunIWcVIA=",
    "body": "te6cckEBAgEAiAABbReNRRkAAAAAdJizmkC/A/doAeGTjx4ENYywc2gAxkNNF3ZlvKBL8JkKeXOuvWkSmhCQIH5cogYBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQPzgXtA==",
    "decoded": null
  },
    # init state in same format as message body
    # needed to deploy a new contract
    "init_state": {
    "hash": "eUdg025leifNuNPWXyQ9a0aMrSw0r0E+dwk5Dk2+mQc=",
    "body": "te6cckECFAEAA4AAAgE0AgEBhwgBz3O187LlgigFaOeh+lYdyGgW0Bv+zgW/Ndy3FS7QJ/UAN1wXvOOOdJfwh7sHnzxnFjjhTeJ04Bmd10caY4RPyrggAgEU/wD0pBP0vPLICwMCAWIEBQICywYHABug9gXaiaH0AfSB9IGoYQIBIAgJAIPSAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVICAUgKCwIBWAwNAMNCDHAJJfBOAB0NMDAXGwlRNfA/AQ4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwDeCCEBeNRRlSILqWMUREA/AO4DWCEFlfB7y6k1nwD+BfBIQX8vCAART6RDBwuvLhTYAfFQPTP/oA+kAh8ALtRND6APpA+kDUMFE2oVIqxwXy4sEowv/y4sJUNEJwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAySD5AHB0yMsCygfL/8nQBPpA9AQx+gAg10nCAPLixHeAGMjLBVAIzxZw+gIXy2sTzIDgIBIA8QAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQD9ztRND6APpA+kDUMAjTP/oAUVGgBfpA+kBTW8cFVHNtcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMn5AHB0yMsCygfL/8nQUA3HBRyx8uLDCvoAUaihggiYloCCCJiWgBK2CKGCCOThwKAYoSfjDyXXCwHDACOAREhMA2ztRND6APpA+kDUMAfTP/oA+kAwUVGhUknHBfLiwSfC//LiwoII5OHAqgAWoBa88uLDghB73ZfeyMsfFcs/UAP6AiLPFgHPFslxgBjIywUkzxZw+gLLaszJgED7AEATyFAE+gJYzxYBzxbMye1UgAHBSeaAYoYIQc2LQnMjLH1Iwyz9Y+gJQB88WUAfPFslxgBDIywUkzxZQBvoCFctqFMzJcfsAECQQIwAOEEkQODdfBAB2wgCwjiGCENUydttwgBDIywVQCM8WUAT6AhbLahLLHxLLP8ly+wCTNWwh4gPIUAT6AljPFgHPFszJ7VTOKoYI",
    "decoded": null
  }
  }
    ],
    # account state before the transaction
    "account_state_before": {
    "hash": "ICpM+dm0PYhxtwS/EnIwMAvOQbtDhVWMnPtMAlw5Dog=", # hash of whole account state
    "balance": "37821399", # balance
    "account_status": "active", # status of account (active, nonexist = deleted, frozen, uninitialized)
    "frozen_hash": null, # hash of state when it became frozen
    "data_hash": "XeSmBiLWvwn00CWu5oq/q9Q6d4luPKxnOWC4NgEeugU=", # hash of data
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc=" # hash of code
  },
    # account state after the transaction
    "account_state_after": {
    "hash": "7vvsHBjy5KoM/rIs6U8nHZt0pYOW5I3oTbBirxVK+Go=",
    "balance": "37821351",
    "account_status": "active",
    "frozen_hash": null,
    "data_hash": "aD0LD2LpPQYYR81n5b/EBHCPYmhBo4soNdvPoTL+xIk=",
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc="
  }
  }
  ```
</details>

В зависимости от задачи интересные к проверке поля могут меняться. Сейчас обозначим наиболее интересные
Native - содержится в блокчейне. В описание указано наименвоание поля определенное в TL-B схемах block.tlb.
Postprocessing - досчитано на стороне API
Native object extended inside - Такой объект есть в блокчейне, но данные дополнены на строне API, подробно в отдельной таблице

| Поле           | Происхождение                 | Описание                                                                                                                             | Пример                                           |
|----------------|-------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|

| `trace_id`       | Postprocessing                | tx_hash of the root transaction of the trace                                                                                         | 13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=     |
| `prev_trans_hash` | Native                        | tx_hash of the root transaction of the trace                                                                                         | 6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=     |
| `account`        | Native                        | Адрес аккаунта, на котором произошла транзакция. Происхождение нативное, важно учесть что здесь получается RAW формат адреса.        | `0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF` |
| `hash`           | Postprocessing                | Хеш текущей транзакции                                                                                                               | `/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=`        |
| `lt`             | Native                        | Логическое время транзакции; уникально для каждой транзакции на одном аккаунте. Исходное поле транзакции в блокчейне `lt`.           | `15371766000003`                                      |
| `now`            | Native                        | Временная метка транзакции в формате UNIX timestamp. Исходное поле транзакции в блокчейне `now`.                                     | `1696238450`                                          |
| `mc_block_seqno` | Postprocessing                | Порядковый номер блока мастерчейна, в который включена транзакция. В транзакции этой информации нет, HTTP сервис добавляет по памяти | `13353447`                                            |
| `trace_id`       | Postprocessing               | Хеш корневой транзакции в цепочке вызовов (trace). Trace - сущность создаваемая в TON Center API/v3                                  | `13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=`        |
| `prev_trans_hash`| Native               | Хеш предыдущей транзакции на этом аккаунте. Исходное поле транзакции в блокчейне `prev_trans_hash`                                   | `6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=`        |
| `prev_trans_lt`  | Native               | Логическое время предыдущей транзакции на этом аккаунте. Исходное поле транзакции в блокчейне `prev_trans_lt`.                       | `15371704000004`                                      |
| `orig_status`    | Native               | Статус аккаунта до выполнения транзакции. Исходное поле транзакции в блокчейне `orig_status`.                                      | `active`                                              |
| `end_status`     | Native               | Статус аккаунта после выполнения транзакции. Исходное поле транзакции в блокчейне `end_status`.                                   | `active`                                              |
| `total_fees`     | Native      | Сумма всех комиссий, связанных с транзакцией. Исходное поле транзакции в блокчейне `total_fees`.                                                                                       | `12446659`                                            |
| `in_msg`         | Native object extended inside | In message body object                                                                                                               | `"in_msg": {...}`                                |

TODO определить набор полей которые здесь полезно рассмотреть.


## Транзакция

Любое изменение состояния аккаунта в блокчейне TON фиксируется при помоищ транзакций. В отличие от сообщений, транзакции не могут "двигаться", "отправляться" и "приниматься". Зачастую эти два термина путают, но важно понимать, что транзакция - это запись, которая фиксирует все изменения, произошедшие с одним конкретным аккаунтом.

### Состав тела транзакции на TL-B

Перед тем, как рассмотреть, как работают транзакции в TON, необходимо рассмотреть, из чего он состоит, используя TL-B. Для начала стоить уточнить, что транзакции деляться на несколько типов, однако в рамках данного туториала мы будем рассматривать только обычные транзакции. Именно эти транзакции интересны нам с точки зрения обработки платежей и разработки любого продукта.

```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

Согласно TL-B, транзакция состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `credit_first` | `Bool` | Указывает, должна ли сперва идти credit фаза или нет. Это зависит от того, [включён ли bounce](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.cpp#L3530). Более подробно это будет рассмотрено в одном из следующих разделов. |
| `storage_ph` | `Maybe TrStoragePhase` | Фаза, которая отвечает за обработку комиссий, связанных с хранилищем аккаунта.
| `credit_ph` | `Maybe TrCreditPhase` | Фаза, которая отвечает за обработку зачисления средств, которые поступили вместе с входящим сообщением, если это internal ([#1](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2926) и [#2](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2935)).
| `compute_ph` | `TrComputePhase` | Фаза, которая отвечает за выполнение кода смарт-контракта (кода, который хранится в соле `code` аккаунта).
| `action` | `Maybe ^TrActionPhase` | Фаза, которая отвечает за обработку созданных actions, которые были сгенерированы в процессе выполнения кода смарт-контракта.
| aborted | `Bool` | Указывает, была ли транзакция прервана на какой-либо из фаз. Если это поле равно `true`, то транзакция не была выполнена и все изменения, которые произошли на `compute_ph` и `action` фазах, не были применены.
| bounce | `Maybe TrBouncePhase` | Фаза, которая отвечает за обработку ошибок, которые произошли на `compute_ph` или `action` фазе.
| destroyed | `Bool` | Указывает, был ли аккаунт уничтожен в процессе выполнения транзакции.

:::info
Другие виды транзакций, такие как [trans_storage](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L352-L353), [trans_tick_tock](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L355-L357), [trans_split_prepare](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L362-L366) и другие нужны для событий, которые происходят незаметно для конечного пользователя. Например, разделение и соединение шардов, тик-ток транзакции и так далее.

Так как они не нужны для задач, связанных с разработкой DApps, то мы не будем их рассматривать в данном туториале.
:::

### Credit phase

Данная фаза довольно маленькая и простая. Если мы посмотрим исходный код блокчейна, то увидим, что основная логика этой фазы заключается в пополнении баланса контракта остатком средств из поступающего сообщения:

```cpp
  credit_phase->credit = msg_balance_remaining;
  if (!msg_balance_remaining.is_valid()) {
    LOG(ERROR) << "cannot compute the amount to be credited in the credit phase of transaction";
    return false;
  }
  // NB: msg_balance_remaining may be deducted from balance later during bounce phase
  balance += msg_balance_remaining;
  if (!balance.is_valid()) {
    LOG(ERROR) << "cannot credit currency collection to account";
    return false;
  }
```

Сериализиуется эта фаза в TL-B следующим образом:

```tlb
tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;
```

Здесь мы видим, что фаза состоит из двух полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `due_fees_collected` | `Maybe Grams` | Сумма комиссий, которые были за хранилище. Это происходит в том случае, если на аккаунте не было баланса и накопился долг. |
| `credit` | `CurrencyCollection` | Сумма, которая была зачислена на аккаунт в процессе получения сообщения. |

### Storage phase

На этой фазе происходит обработка комиссий, связанных с хранилищем аккаунта. Для начала ознакомимся с TL-B схемой:

```tlb
tr_phase_storage$_ storage_fees_collected:Grams 
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;
```

Здесь мы видим, что фаза состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `storage_fees_collected` | `Grams` | Сумма комиссий, которые были собраны за хранилище аккаунта. |
| `storage_fees_due` | `Maybe Grams` | Сумма комиссий, которые были начислены за хранилище аккаунта, но не были собраны. Это происходит в том случае, если на аккаунте не было баланса и накопился долг. |
| `status_change` | `AccStatusChange` | Изменение статуса аккаунта после выполнения транзакции. |

`storage_fees_due` имеет тип `Maybe`, потому что в случае, когда у контракта есть баланс, это значение не будет присутствовать. Оно необходимо только для отображения долга. В свою очередь, `AccStatusChange` позволяет понять, изменился ли статус аккаунта после этой фазы. Например, если долг превысил 0.1 TON, то состояние аккаунта [заморозится](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L949C11-L953C12), а после 1 TON - [удалится](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L936C11-L946C12).

### Compute phase

Одной из самых комплексных фаз транзакции является compute phase. Именно на этой фазе выполняется код смарт-контракта, который хранится в хранилище. В этот раз TL-B у нас содержит несколько схем:

```tlb
tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool 
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;
```

Для начала заметим, что compute phase может быть пропущена и в качестве причины могут быть указаны следующие:

| Причина пропуска | Описание |
| --- | --- |
| `cskip_no_state` | Смарт-контракт не имеет состояния (а значит и кода), поэтому его код не может быть выполнен. |
| `cskip_bad_state` | Данная ошибка выбрасывается в двух случаях: [неправильное значение поля `fixed_prefix_length`](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1721) или же StateInit, который был передан в сообщении, [не соответствует адресу аккаунта](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1726). |
| `cskip_no_gas` | В поступающем сообщении не было достаточного количества TON для выполнения кода смарт-контракта. |
| `cskip_suspended` | Аккаунт был заморожен, поэтому код не может быть выполнен. Это использовалось для заморозки аккаунтов ранних майнеров в рамках стабилизации токеномики TON. |

:::tip
Поле `fixed_prefix_length` позволяет установить фиксированные начальные биты адреса аккаунта, чтобы он находился в конкретном шарде. Это не входит в рамки данного туториала, однако об этом можно почитать [здесь](https://github.com/ton-blockchain/ton/blob/master/doc/GlobalVersions.md#anycast-addresses-and-address-rewrite).
:::

После того, как мы разобрались с причинами пропуска compute phase, мы можем разобрать, что происходит после того, как код смарт-контракта был выполнен:

| Поле | Тип | Описание |
| --- | --- | --- |
| `success` | `Bool` | Указывает, была ли успешно выполнена compute phase. Если это значение равно `false`, то все изменения, которые произошли на этой фазе, не были применены. |
| `msg_state_used`, `account_activated`, `mode`, `vm_init_state_hash`, `vm_final_state_hash` | - | Эти поля никак не используются в текущей версии блокчейна и лишь записываются нулевыми значениями. |
| `gas_fees` | `Grams` | Сумма комиссий, которые были уплачены за выполнение кода смарт-контракта. |
| `gas_used`, `gas_limit` | `VarUInteger` | Количество газа, которое было использовано и лимит газа, который был установлен для выполнения кода смарт-контракта. |
| `gas_credit` | `Maybe (VarUInteger 3)` | Используется в external сообщениях. Поскольку они не могут нести при себе TON, то в этом случае выделяется немного газа для того, чтобы код смарт контракта мог запуститься и решить, готов ли 
| `exit_code` | `int32` | Код выхода виртуальной машины. Если код равен 0 или 1 (alternative success), то код смарт-контракта был успешно выполнен. Если код не равен 0, то это означает, что код смарт-контракта завершился с ошибкой (исключением является применение `commit`). |
| `exit_arg` | `Maybe int32` | Аргумент, который был выброшен виртуальной машиной в случае ошибки. Это может быть полезно для отладки кода смарт-контракта. |
| `vm_steps` | `uint32` | Количество шагов, которые были выполнены виртуальной машиной. |

:::tip
Инструкция `commit` используется для того, чтобы зафиксировать изменения, которые были сделаны до этой инструкции и применить их вне зависимости от того, будет ли далее ошибка в этой фазе. Может быть отменена только в случае, если Action Phase завершиться неудачно.
:::

### Action phase

После того, как код смарт-контракта был выполнен, начинается action phase. Если в процессе выполнения кода были созданы какие-либо actions, то они будут обработаны на этой фазе. Всего существует 4 типа actions:

```tlb
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;
```

| Тип | Описание |
| --- | --- |
| `action_send_msg` | Отправка сообщения. |
| `action_set_code` | Установка нового кода смарт-контракта. |
| `action_reserve_currency` | Резервирование средств на аккаунте. Очень полезно при газ мененджменте. |
| `action_change_library` | Изменение библиотеки, которая используется в смарт-контракте. |

Теперь мы можем посмотреть TL-B схему, которая описывает action phase:

```tlb
tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16 
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;
```
Здесь мы видим, что фаза состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `success` | `Bool` | Указывает, была ли успешно выполнена action phase. Если это значение равно `false`, то все изменения, которые произошли на этой фазе, не были применены. Также отменяются изменения, которые были сделаны на compute phase. |
| `valid` | `Bool` | Указывает, была ли action phase валидной. Если это значение равно `false`, то это означает, что в процессе выполнения кода смарт-контракта были созданы некорректные actions. Для каждого action имеется свой набор критериев. |
| `no_funds` | `Bool` | Указывает, были ли средства на аккаунте для выполнения actions. `false` означает, что Action Phase была прервана из-за недостатка средств. |
| `status_change` | `AccStatusChange` | Изменение статуса аккаунта после выполнения action phase. Так как удаление аккаунта происходит именно через actions (через мод 32), то это поле может содержать информацию о том, был ли аккаунт удалён. |
| `total_fwd_fees` | `Maybe Grams` | Сумма комиссий, которые были уплачены за пересылку сообщений, созданных в процессе выполнения actions. |
| `total_action_fees` | `Maybe Grams` | Сумма комиссий, которые были уплачены за выполнение actions. |
| `result_code` | `int32` | Код результата выполнения actions. Если код равен 0, то это означает, что все actions были успешно выполнены. |
| `result_arg` | `Maybe int32` | Аргумент, который был выброшен в случае ошибки. Это может быть полезно для отладки кода смарт-контракта. |
| `tot_actions` | `uint16` | Общее количество actions, которые были созданы в процессе выполнения кода смарт-контракта. |
| `spec_actions` | `uint16` | Количество специальных actions (все, кроме `action_send_msg`). |
| `skipped_actions` | `uint16` | Количество actions, которые были пропущены в процессе выполнения кода смарт-контракта. Относится к отправке сообщений, с которыми были проблемы, однако был установлен флаг `ignore_errors` (2). |
| `msgs_created` | `uint16` | Количество сообщений, которые были созданы в процессе выполнения actions. |
| `action_list_hash` | `bits256` | Хеш списка actions. |
| `tot_msg_size` | `StorageUsed` | Общий размер сообщений. |

### Bounce phase

Если фаза compute phase или action phase завершилась с ошибкой и при этом у входящего сообщения был установлен флаг `bounce`, то будет выполнена bounce phase:

:::note
Для того, чтобы началась bounce phase из-за ошибки в action phase, то должен зафейлиться action, который был создан с флагом 16, означающий баунс в случае ошибки.
:::

```tlb
tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
```

`tr_phase_bounce_negfunds` не используется в текущей версии блокчейна, поэтому мы рассмотрим оставшиеся две:

| Тип | Описание |
| --- | --- |
| `tr_phase_bounce_nofunds` | Означает, что на обработку сообщения, которое должно было быть возвращено отправителю, недостаточно средств. |
| `tr_phase_bounce_ok` | Означает, что сообщение было успешно обработано и отправлено обратно отправителю. |

Здесь `msg_fees` и `fwd_fees` вычисляются на основе общей комиссии `fwd_fees` за обработанное сообщение. 1/3 часть этой комиссии уплачивается на месте и записывается в `msg_fees`, а остальная часть записывается в `fwd_fees`. 

### Полное тело транзакции

После того, как мы разобрали заголовок транзакции и её описание, мы можем посмотреть, как целиком выглядит любая транзакция в TON. Для начала посмотри на TL-B схему:

```tlb
transaction$0111 account_addr:bits256 lt:uint64
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;
```

Здесь мы видим, что транзакция состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `account_addr` | `bits256` | Адрес аккаунта, к которому относится транзакция. |
| `lt` | `uint64` | Логическое время транзакции. |
| `prev_trans_hash` | `bits256` | Хэш предыдущей транзакции, которая была выполнена на этом аккаунте. |
| `prev_trans_lt` | `uint64` | Логическое время предыдущей транзакции, которая была выполнена на этом аккаунте. |
| `now` | `uint32` | Время создания транзакции в формате Unix timestamp. |
| `outmsg_cnt` | `uint15` | Количество исходящих сообщений, которые были созданы в процессе выполнения транзакции. |
| `orig_status` | `AccountStatus` | Исходный статус аккаунта перед выполнением транзакции. |
| `end_status` | `AccountStatus` | Статус аккаунта после выполнения транзакции. |
| `in_msg` | `Maybe ^(Message Any)` | Входящее сообщение, которое было обработано в процессе выполнения транзакции. В случае с обычной транзакцией всегда будет присутствовать. |
| `out_msgs` | `HashmapE 15 ^(Message Any)` | Исходящие сообщения, которые были созданы в процессе выполнения транзакции. |
| `total_fees` | `CurrencyCollection` | Общее количество комиссий, которые были уплачены за выполнение транзакции. |
| `state_update` | `^(HASH_UPDATE Account)` | Объект, который содержит в себе хеш предыдущего состояния аккаунта и хеш нового состояния аккаунта.
| `description` | `^TransactionDescr` | Описание транзакции, которое содержит в себе информацию о фазах выполнения транзакции. Это поле мы уже разобрали выше. |

Поля `orig_status` и `end_status` содержат в себе информацию о том, как изменилось состояние аккаунта после выполнения транзакции. Всего существует 4 статуса:

```tlb
acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;
```

### Как получить транзакцию, используя api/v2

Из доступных и подддерживаемых OpenSource API, мы можем использовать [APIv2](https://toncenter.com/api/v2/) и [APIv3](https://toncenter.com/api/v3/index.html#/) от Toncenter. APIv2 является более сырой версией и позволяет получать лишь очень базовую информацию о блокчейне. Для получения транзакции у нас есть 2 способа:

- Использовать `/api/v2/getTransactions` endpoint:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import axios from 'axios';

async function main() {
    const client = axios.create({
        baseURL: 'https://toncenter.com/api/v2',
        'timeout': 5000,
        headers: {
            'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
        }
    });
    
    const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
    const response = await client.get('/getTransactions', {
        params: {
            address: address,
            limit: 1,
            to_lt: 0,
            archival: false
        },
        headers: {
            'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
        }
    });
    console.log(response.data)
}

main().finally(() => console.log("Exiting..."));

```

</TabItem>
</Tabs> 


- Использовать `JSON-RPC` протокол:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, TonClient } from '@ton/ton';

async function main() {
    const client = new TonClient({
        endpoint: "https://toncenter.com/api/v2/jsonRPC",
        apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
    });

    const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
    const response = await client.getTransactions(address, {
        limit: 1,
    });
    console.log(response[0]);
}

main().finally(() => console.log("Exiting..."));
```

</TabItem>
</Tabs> 

Рекомендованным способом является использование `JSON-RPC` протокола, поскольку для этого можно использовать готовый SDK, в котором уже все поля заранее расписаны и имеют нужный тип. Таким образом вам не придётся изучать то, что означает каждое поле.

:::note
Во время получения транзакций вы можете столкнуться с ошибкой `LITE_SERVER_UNKNOWN: cannot compute block with specified transaction: cannot find block (0,ca6e321c7cce9ece) lt=57674065000003: lt not in db`. 

Это означает, что на этом аккаунте транзакции были довольно давно и блоки, в которых они были созданы, уже не хранятся на LiteServer. В таком случае вы можете использовать `archival: true`, который будет запрашивать информацию из архивной ноды.
:::

### Как получить транзакцию, используя api/v3

`APIv3` является более продвинутым и удобным для получения информации о разных событиях в блокчейне. Например, в нём можно запрашивать получать информацию о переводе NFT, жетонов и даже транзакциях, которые находятся в статусе `pending`. Мы рассмотрим только `transactions` endpoint, который возвращат уже свершившиеся транзакции:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import axios from 'axios';

async function main() {
    const client = axios.create({
        baseURL: 'https://toncenter.com/api/v3',
        'timeout': 5000,
        headers: {
            'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
        }
    });
    
    const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
    const response = await client.get('/transactions', {
        params: {
            account: address,
            limit: 1,
            to_lt: 0,
            archival: false
        }
    });
    console.log(response.data.transactions[0])
}

main().finally(() => console.log("Exiting..."));
```

</TabItem>
</Tabs> 

Если мы посмотрим на ответ, то увидим, что он сильно отличается от ответа `APIv2`. Основная разница заключается в том, что эта версия **индексирует** транзакции в то время, как прошлая версия лишь являлась некой оболочкой для общения с LiteServer. Это означает, что информация запрашивается из базы данных самого сервера. 

Это позволяет нам получать уже обработанную информацию. Например, если мы углубимся в ответ, то увидим, что в полях `account_state_before` и `account_state_after` не только хеш состояния, но и полную информацию, такую как код, дата, баланс TON и даже баланс ExtraCurrency:

```json
[
  account_state_before: {
    hash: 'Rljfqi3l3198Fok7x1lyf9OlT5jcVRae7muNhaOyqNQ=',
    balance: '235884286762',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: 'uUe+xBA4prK3EyIJ8iBk8unWktT4Grj+abz4LF2opX0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  },
  account_state_after: {
    hash: 'asmytWJakUpuVVYtuSMgwjmlZefj5tV5AgnWgGYP+Qo=',
    balance: '225825734714',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: '6L0wUi1S55GRvdizozJj2GkCqjKSx8iK7dEHlTOe8d0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  }
]
```

Дополнительно мы в ответе получаем `address_book`, который содержит массив адресов, с которыми было взаимодействие в процессе выполнения транзакций.

### Поля транзакции в SDK

При изучении ответа, полученного с помощью `JSON-RPC` протокола в `@ton/ton@`, мы можем заметить, что помимо полей, рассмотренных выше, в ответе есть ещё `hash` и `raw`. Эти поля не содержатся в самих транзакциях в рамках блокчейна, но добавляются со стороны SDK для удобства.

С помощью поля `hash`, который содержит функцию, мы можем посчитать хеш транзакции, а поле `raw` содержит в себе BOC транзакции, с помощью которой мы можем сами распарсить транзакцию, используя либо готовый метод из SDK, либо вручную:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { Address, loadTransaction, TonClient } from '@ton/ton';

async function main() {
    const client = new TonClient({
        endpoint: "https://toncenter.com/api/v2/jsonRPC",
        apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
    });

    const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
    const response = await client.getTransactions(address, {
        limit: 1,
    });

    const transaction = response[0];
    console.log(loadTransaction(transaction.raw.beginParse()));
    console.log(`Transaction hash: ${transaction.hash().toString('hex')}`);
}

main().finally(() => console.log("Exiting..."));
```
</TabItem>
</Tabs>

### Action: User Context (a.k.a. Event)

Перед тем, как рассмотреть пользовательские операции и их обработку, резюмируем, что мы узнали о транзакциях:

- Транзакция - это запись, которая фиксирует все изменения, произошедшие с одним конкретным аккаунтом.
- Транзакция состоит из нескольких фаз, которые обрабатывают входящие сообщения, выполняют код смарт-контракта и обрабатывают созданные actions.
- Каждая фаза транзакции имеет своё описание, которое содержит информацию о том, что произошло в процессе выполнения транзакции.
- Транзакция может быть успешно выполнена или завершиться с ошибкой, в зависимости от того, были ли выполнены все фазы и были ли созданы корректные actions.
- Обычные транзакции всегда содержат входящее сообщение, но могут не содержать исходящих сообщений.
- Транзакция может быть получена с помощью APIv2 или APIv3, которые предоставляют информацию о транзакции в удобном формате.
- В APIv3 транзакция индексируется, что позволяет получать уже обработанную информацию в то время как APIv2 - это лишь обёртка для общения с LiteServer.
- В SDK могут появляться дополнительные поля для удобства работы с транзакциями, такие как `hash` и `raw`, которые позволяют получить хеш транзакции и BOC транзакции соответственно.

Ранее мы говорили об actions с технической точки зрения. Однако часто в различных API сервисах этот термин используется для обозначения пользовательских операций. Например, один перевод Jetton с одного кошелька на другой осуществляется минимум за 3 разных транзакции. Цепочка этих транзакций будет называться `Jetton Transfer action`. Во избежание путаницы, мы будем использовать термин `Event`, который также можно встретить в различных API сервисах.

### Успешность Event в экосистеме: Ordinary TON Transfer

Как мы ранее уже обсуждали, в TON всё происходит асинхронно, поэтому успешность одной транзакции не означает, что вся цепочка успешно завершилась или завершится в будущем. Поэтому мы должны опираться на более абстрактные понятия успешности.

Например, если мы хотим отправить TON с одного кошелька на другой, то успешность этой операции будет означать, что средства были успешно зачислены на целевой кошелек. Для этого нам необходимо получать последние транзакции на целевом аккаунте, время создания которых больше или равно, чем время создания транзакции, в которой возникло сообщение, отправляющее TON.

Допустим, мы хотим проверять депозиты, поступающие на наш кошелёк `UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL`. Для удобства мы будем использовать APIv3 и запрашивать последние 10 транзакций на аккаунте:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

```js
import { fromNano } from '@ton/core';
import axios from 'axios';

async function main() {
    const client = axios.create({
        baseURL: 'https://toncenter.com/api/v3',
        'timeout': 5000,
        headers: {
            'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
        }
    });
    
    const address = 'UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL';
    const response = await client.get('/transactions', {
        params: {
            account: address,
            limit: 10,
            to_lt: 0,
            archival: false
        }
    });

    for (const transaction of response.data.transactions) {
        const description = transaction.description;
        if (description.type !== 'ord') {
            continue;
        }

        const inMsg = transaction.in_msg;
        if (inMsg.created_lt === null) {
            continue; // Skip external messages
        }
        const bouncePhase = description.bounce;
        
        if (bouncePhase && bouncePhase.type === 'ok') {
            console.log(`Fake deposit detected: ${transaction.hash}`);
            continue;
        }

        console.log(`Deposit detected: ${transaction.hash}. Value: ${fromNano(inMsg.value)} TON.`);
    }
}

main().finally(() => console.log("Exiting..."));
```

</TabItem>
</Tabs>

После получения транзакций мы должны проверить следующее:

1. Транзакция должна быть обычной, то есть `description.type` должно быть равно `ord`.
2. Входящее сообщение должно быть internal. Это означает, что поле`created_lt` должно быть заполнено.
3. Если в описании транзакции присутствует поле `bounce` (это относится только к отвечу `transactions` endpoint для APIv3), то это означает, что была запущена bounce phase. В таком случае, мы проверяем, завершилась ли она успешно, что будет означать, что средства были возвращены отправителю.
4. Если все проверки пройдены, то мы можем считать, что депозит был успешно зачислен на кошелёк.

:::danger
Необходимо учитывать, что предложенный код является лишь примером и не является полноценным решением для отслеживания депозитов. В реальных приложениях необходимо обрабатывать не строго последние 10 транзакций, а все транзакции, которые были после последней проверки.

Также необходимо учитывать, что то, какие значения должны быть у полей в случае фейкового депозита, может отличаться от API сервиса. В данном примере показывается лишь ответ APIv3 от Toncenter для `transactions` endpoint.
:::

Если мы запустим этот код, то получим следующий вывод:

```
Fake deposit detected: 4vXGhdvtfgFx8tkkaL17POhOwrUZq3sQDVSdNpW+Duk=
```

Посмотрев на эту транзакцию в [эксплорере](https://tonviewer.com/transaction/e2f5c685dbed7e0171f2d92468bd7b3ce84ec2b519ab7b100d549d3695be0ee9), мы увидим, что средства действительно вернулись отправителю.

:::note
Если мы запросим транзакции для этого аккаунта с помощью APIv2, то не получим никаких транзакций. Дело в том, что информация об этой транзакции была записана лишь в блок и индексатор в APIv3 смог её проиндексировать.

Однако так как данный аккаунт не имеет никакого стейта (даже ни одного пополнения баланса), то к этому аккаунту не относятся никакие транзакции. Если бы был хотя бы один депозит, то состояние из `nonexist` изменилось бы на `uninit` и тогда APIv2 смог бы вернуть эту транзакцию.
:::

### Успешность Event в экосистеме: Jetton Transfer

Теперь мы можем рассмотреть более сложный пример, связанный с переводом Jetton. Для начала рассмотрим, как выглядит Jetton Transfer:

1. external_in -> User_A - > internal (op::jetton_transfer)
2. internal (op::jetton_transfer) -> User_A_Jetton_Wallet -> internal (op::internal_transfer)
3. internal (op::internal_transfer) -> User_B_Jetton_Wallet

Как мы видим, в этом случае у нас есть 3 транзакции и по-настоящему перевод жетонов заканчивается только тогда, когда третья транзакция завершилась удачно. После 3-й транзакции дополнительно могут быть отправлены 2 сообщения:

1. internal (op::jetton_transfer_notification) -> User_B | If `forward_amount` is set
2. internal (op::excesses) -> response_destination | If `response_destination` is set

Однако для того, чтобы проверить перевод, нам нужна лишь третья транзакция. Для облегчения примера, допустим, что мы хотим проверять поступающие жетоны на конкретном кошельке `EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX` для жетона USDT:

<Tabs groupId="code-examples">
<TabItem value="js" label="JavaScript">

<details>
<summary>
Source code
</summary>

```js
import { Address, TonClient } from '@ton/ton';

// Changed version of
// https://github.com/ton-org/ton-core/blob/b2e781f67b41958e4fde0440752a27c168602717/src/utils/convert.ts#L69C1-L96C2
export function fromMicro(src: bigint | number | string) {
    let v = BigInt(src);
    let neg = false;
    if (v < 0) {
        neg = true;
        v = -v;
    }

    // Convert fraction
    let frac = v % 1000000n;
    let facStr = frac.toString();
    while (facStr.length < 6) {
        facStr = '0' + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)![1];

    // Convert whole
    let whole = v / 1000000n;
    let wholeStr = whole.toString();

    // Value
    let value = `${wholeStr}${facStr === '0' ? '' : `.${facStr}`}`;
    if (neg) {
        value = '-' + value;
    }

    return value;
}

async function main() {
    const client = new TonClient({
        endpoint: "https://toncenter.com/api/v2/jsonRPC",
        apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
    });

    const address = Address.parse('EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX');
    const response = await client.getTransactions(address, {
        limit: 10,
        archival: true,
    });
    
    for (const transaction of response) {
        if (transaction.description.type !== 'generic') {
            continue;
        }
        
        // Check if the compute phase is present and successful
        if (transaction.description.computePhase.type !== 'vm') {
            continue;
        }
        if (transaction.description.computePhase.exitCode !== 0) {
            continue;
        }

        // Check if the action phase is present and successful
        if (transaction.description.actionPhase && transaction.description.actionPhase.resultCode !== 0) {
            continue;
        }

        if (transaction.description.aborted === true) {
            continue;
        }

        if (transaction.inMessage.info.type !== 'internal') {
            continue;
        }

        const body = transaction.inMessage.body.beginParse();
        try {
            /*
            internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                     response_address:MsgAddress
                     forward_ton_amount:(VarUInteger 16)
                     forward_payload:(Either Cell ^Cell)
                     = InternalMsgBody;
            */

            const op = body.loadUint(32);
            if (op !== 0x178d4519) { // op::internal_transfer
                continue;
            }
            const queryId = body.loadUintBig(64);
            const amount = body.loadCoins();
            const from = body.loadAddress();
            const responseAddress = body.loadMaybeAddress();
            const forwardTonAmount = body.loadCoins();
            const eitherForwardPayload = body.loadBoolean();
            const forwardPayload = eitherForwardPayload ? body.loadRef() : body.asCell();

            console.log(`Deposit detected:
    Transaction hash: ${transaction.hash().toString('hex')}
    Query ID: ${queryId}
    Amount: ${fromMicro(amount)} USDT
    From: ${from.toString({ testOnly: true })}
    Response Address: ${responseAddress ? responseAddress.toString({ testOnly: true }) : 'None'}
    Forward TON Amount: ${forwardTonAmount.toString()} TON
    Forward Payload: ${forwardPayload.toBoc().toString('hex')}`);
        } catch (e) {
            console.error(`Error processing transaction ${transaction.hash().toString('hex')}:`, e);
        }
    }
}

main().finally(() => console.log("Exiting..."));
```

</details>

</TabItem>
</Tabs>

Для начала мы получаем последние 10 транзакций на смарт контракте USDT Jetton Wallet. После этого нам необходимо проверить:

1. Транзакция должна быть обычной, то есть `description.type` должно быть равно `generic`.
2. Фаза compute должна быть успешной, то есть `description.computePhase.type` должно быть равно `vm` и `description.computePhase.exitCode` должно быть равно 0.
3. Если фаза action присутствует, то она должна быть успешной, то есть `description.actionPhase.resultCode` должно быть равно 0.
4. Входящее сообщение должно быть internal, то есть `inMessage.info.type` должно быть равно `internal`.
5. В теле входящего сообщения должно быть `internal_transfer` операция, то есть `body.loadUint(32)` должно вернуть `0x178d4519`.
6. Если все проверки пройдены, то мы можем считать, что депозит был успешно зачислен на кошелёк.

Для разбора тела входящего сообещения мы используем TL-B схему из [TEP-0074](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md):

```tlb
internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                     response_address:MsgAddress
                     forward_ton_amount:(VarUInteger 16)
                     forward_payload:(Either Cell ^Cell)
                     = InternalMsgBody;
```

:::note
Важно понимать, что это был очень упрощённый пример. В реальных приложениях может быть другая логика обработки депозитов. Для более подробной информации о том, как обрабатывать такие события, вы можете ознакомиться с [отдельной статьёй](/v3/guidelines/dapps/asset-processing/jettons).
:::

### Успешность Event в экосистеме: NFT Transfer

TL-B: https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#tl-b-schema

todo: В нфт проще, тут лишь нужно заменить поле `owner_address`. Схема для этого следующая:

```tlb
transfer query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)  forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)  = InternalMsgBody;
```

Если был указан `forward_amount`, то:

```tlb
ownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody;
```

:::note
advanced: http://localhost:3000/v3/guidelines/dapps/asset-processing/nft-processing/nfts
:::

### Как исследовать контракт и его схему в TL-B, чтобы построить логику для анализа успешной операции

В этом разделе мы на основе Jetton Wallet контракта рассмотрим, как на основе его кода понять, что необходимо проверить для того, чтобы убедиться, что операция была целиком успешно завершена.

todo: разбор func кода, на основе jetton_transfer определить успешность операции и немного примеров на ts коде

Мы будем юзать следующий код: https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-wallet.fc,
И эти схемы из спефицикации: https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#tl-b-schema

Рассмотрим опкоды входящие:

```func
  if (op == op::transfer()) { ;; outgoing transfer
    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
    return ();
  }

  if (op == op::internal_transfer()) { ;; incoming transfer
    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
    return ();
  }
```

Разберём отправку. Для начала посмотрим, что представляет с собою входящее сообщение:

```tlb
transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
           response_destination:MsgAddress custom_payload:(Maybe ^Cell)
           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;

```

Теперь разберём код:

<details>
<summary>

`send_tokens` function

</summary>

```func
() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  slice to_owner_address = in_msg_body~load_msg_addr();
  force_chain(to_owner_address);
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  balance -= jetton_amount;

  throw_unless(705, equal_slices(owner_address, sender_address));
  throw_unless(706, balance >= 0);

  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);
  slice to_wallet_address = calculate_jetton_wallet_address(state_init);
  slice response_address = in_msg_body~load_msg_addr();
  cell custom_payload = in_msg_body~load_dict();
  int forward_ton_amount = in_msg_body~load_coins();
  throw_unless(708, slice_bits(in_msg_body) >= 1);
  slice either_forward_payload = in_msg_body;
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(to_wallet_address)
    .store_coins(0)
    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(state_init);
  var msg_body = begin_cell()
    .store_uint(op::internal_transfer(), 32)
    .store_uint(query_id, 64)
    .store_coins(jetton_amount)
    .store_slice(owner_address)
    .store_slice(response_address)
    .store_coins(forward_ton_amount)
    .store_slice(either_forward_payload)
    .end_cell();

  msg = msg.store_ref(msg_body);
  int fwd_count = forward_ton_amount ? 2 : 1;
  throw_unless(709, msg_value >
                     forward_ton_amount +
                     ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response
                     ;; but last one is optional (it is ok if it fails)
                     fwd_count * fwd_fee +
                     (2 * gas_consumption() + min_tons_for_storage()));
                     ;; universal message send fee calculation may be activated here
                     ;; by using this instead of fwd_fee
                     ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)

  send_raw_message(msg.end_cell(), 64); ;; revert on errors
  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

```

</details>

Здесь мы разберём, какое сообщение и в каком виде отправляется получателю и будем отталкиваться от этого. И так же видим, что отправка соответствует схеме TL-B:

```tlb
transfer_notification query_id:uint64 amount:(VarUInteger 16)
           sender:MsgAddress forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;
```

Теперь разберём получение:

<details>
<summary>

`receive_tokens` function

</summary>

```func

() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
  ;; NOTE we can not allow fails in action phase since in that case there will be
  ;; no bounce. Thus check and throw in computation phase.
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  balance += jetton_amount;
  slice from_address = in_msg_body~load_msg_addr();
  slice response_address = in_msg_body~load_msg_addr();
  throw_unless(707,
      equal_slices(jetton_master_address, sender_address)
      |
      equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)
  );
  int forward_ton_amount = in_msg_body~load_coins();

  int ton_balance_before_msg = my_ton_balance - msg_value;
  int storage_fee = min_tons_for_storage() - min(ton_balance_before_msg, min_tons_for_storage());
  msg_value -= (storage_fee + gas_consumption());
  if(forward_ton_amount) {
    msg_value -= (forward_ton_amount + fwd_fee);
    slice either_forward_payload = in_msg_body;

    var msg_body = begin_cell()
        .store_uint(op::transfer_notification(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(from_address)
        .store_slice(either_forward_payload)
        .end_cell();

    var msg = begin_cell()
      .store_uint(0x10, 6) ;; we should not bounce here cause receiver can have uninitialized contract
      .store_slice(owner_address)
      .store_coins(forward_ton_amount)
      .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_ref(msg_body);

    send_raw_message(msg.end_cell(), 1);
  }

  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
    var msg = begin_cell()
      .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000
      .store_slice(response_address)
      .store_coins(msg_value)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(op::excesses(), 32)
      .store_uint(query_id, 64);
    send_raw_message(msg.end_cell(), 2);
  }

  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

```

</details>

Тут увидем, что происходит во время принятия жетонов. Отсюда будем отталкиваться при проверке успешности операции.