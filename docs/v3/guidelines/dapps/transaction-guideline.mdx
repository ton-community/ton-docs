

# Interact with transactions

## Как мне выяснить что моя транзакция выполнилась успешно спомощью метода API?
//TODO briefing: what you will learn in this guide

## Терминология

### Общие термины
* Actor
* Assyncronius
* AccountChain
* ShardChain
* WorkChain
* Type of WorkChain: MasterChain and BaseChain
* Testnet and Mainnet

### Структура и взаимодействия акторов в TON
* Account
* Balance
* Contract
* State
* Address
* Message feature
* Transaction feature
* Assyncronius природа транзакций

### Сообщения

* Сообщение
Все взаимодействия cо смарт контрактами в тоне построено на сообщениях. Сообщения чем-то похожи на запросы к серверу. Каждый смарт контракт имеет обработчик сообщений и выполняет определенную логику, по приходу сообщения.

* Transaction and message real life examples
* Tl-B structure
* Message structure TL-B
  Теперь о данных в сообщении. Мы уже говорили что и в external, и internal сообщениях могут содержаться какие-то данные. Но как именно эти данные передавать? В тоне все данные представлены в виде ячеек. Для того чтобы закодировать данные в ячейку, существует общепринятый стандарт для описания сериализации этих данных – TL-B.
  Простейший практический контракт в тоне – это счетчик. Рассмотрим такой гипотетический пример и примеры возможных сообщений к нему. Пусть смарт контракт может совершать два действия, увеличить или уменьшить внутреннюю переменную в нём. Тогда возможные сообщения описанные на языке TL-B будут выглядеть примерно так:

* Particular message structure
* Headers fields (CommonMsgInfo)
* Типы сообщений

Всего есть три типа сообщений:
- internal
- external incoming
- external outgoing


### Internal
Теперь об internal сообщениях. Когда кошелек получает external сообщение он проверяет подпись, и если всё корректно кошелек посылает уже internal сообщение на другой смарт контракт. У internal сообщения есть несколько важных отличий – помимо данных, к сообщению может быть прикреплено некоторое количество тонов, а ещё у internal сообщения есть отправитель, то есть в нашем примере отправитель это наш кошелек.

Говоря немного иначе internal сообщение – это сообщение от одного смарт контракта к другому. При получении internal сообщения смарт контракт знает сколько к этому сообщению было прикреплено тонов и кто отправитель этого сообщения. Корректность этих данных гарантируется блокчейном, соответственно смарт контракт может им доверять.

### External incoming
Начнём с external сообщений. External сообщение это просто сообщение с данными к конкретному смарт контракту. То есть любой человек может отправить произвольные данные на любой смарт контракт, а смарт контракт решит, что с этим сообщением делать. Это относительно редко используемая логика, но у неё есть одно самое важное применение – контракты кошельков.

Почти любое действие в блокчейне начинается с external сообщение к кошельку. То есть, когда пользователь хочет кому-то перевести тоны или например совершить обмен на дексе, он посылает external сообщение на свой кошелёк с подписанными данными.

### External outgoing
External-out (их ещё иногда называют Events) – это просто данные которые генерирует смарт контракт и никуда не отправляет. Редкий тип сообщения, по своей сути очень похож на логи. По большей части нужен просто для облегчения индексации блокчейна. Например дедаст генерирует external out сообщение при успешном свапе, чтобы другим сервисам был.

External message examples and typical using
Internal message examples and typical using
Message value
Bounce of messages (они bouncable/unbouncable либо они могут быть или нет bouncable/unbouncable)
Address with flags as field of message
Trace
Action
External message is an initiation of Action
Define that we need build internal message and wrap this in external message.
* Serializators for messages. (Message builders)
* Types of message descriptors
  * Дополнительные стандарты с TL-B (https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md)

#### Создание сообщение по TL-B

```
increase#34a3ff12 query_id:uint64 amount:uint32 = InternalMsgBody;
```

```
decrease#e4d5986b query_id:uint64 amount:uint32 = InternalMsgBody;
```

Это схема описывает 2 сообщения (сами данные). Когда мы работаем с сообщением, то тело сообщения и количество прикрепленных к нему тон – это два самых важных параметра.

В теле сообщения есть два конвенциональных поля – opcode и query_id. opcode – это 32-битное число означающее тип операции, а query_id – 64-битное число, которое смарт контракт никак не должен использовать, и нужное лишь для удобства внешним сервисам.

Так в коде чтобы собрать тело сообщения

```
function generateMessageBody(amount: bigint): Cell {
const op = 0x34a3ff12;
const queryId = randomUint64();
const body = beginCell()
.storeUint(op, 32)
.storeUint(queryId, 64)
.storeUint(amount, 32)
.endCell();

    return body;
}
```
  * Build message serializer according to TL-B
  * Ресиверы в коде  (https://github.com/ton-blockchain/highload-wallet-contract-v3)
  * Build message serializer according to source code
  * Assembler (blockchain explorer preview/ https://tonviewer.com/EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1?section=code )

  
* Hash
* Hash of a message’s body
* Hash of a full message’s (Message X)
* Send message and check fact of sending

## Отправка сообщения

Есть два практических и важных для отличия случая, как можно отправить сообщение в блокчейн. Либо мы отсылаем сообщение с бэкенда являемся владельцем кошелька и можем сразу подписать и отправить сообщение в блокчейн, либо используя TON Connect на фронтенде мы можем собрать сообщение и предложить пользователю подписать и отправить его самому.

### Отправка с бэкенда

Когда у нас есть кошелек с сид фразой отправление сообщения происходит так
Код [отсюда](https://docs.ton.org/v3/guidelines/dapps/cookbook#how-to-transfer-ton-and-send-a-text-message-to-another-wallet)

### Отправка с фронтенда (TON Connect)
Тут мы просто предлагаем пользователю подписать сообщение

```
const myTransaction = {
validUntil: Math.floor(Date.now() / 1000) + 60, // 60 sec
messages: [
{
address: destination, // Address of smart contract to send internal message to
amount: amount, // Amount in nanotons to attach to the message
payload: Base64.encode(messageBody.toBoc())
}
]
}

tonConnectUI.sendTransaction(myTransaction)

```
## Get методы
Get methods
Build get method wrapper
Get balance
Get jetton wallet address
Get collection data

## Blockchain HTTP API 
* Основные сервисы в TON: TON Center, TON API, TONX API.
* Транзакция это часть блока.
* Подходы к получению транзакции из блокчейна.
  * GetTranasction by external message.
  * Перебор все транзакции с последнего блока MasterChain. 
  * Использование верхнеуровневых интерфейсов для событий(или операций): GetJettons, GetNFTs, GetActions.
* Фундаментальный подход к получению массива транзакций.
Для получения всех транзакций используют метод сканирования сверху. Расмотрим алгоритм на примере TON Center HTTP API

- https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_masterchain_info
- https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_masterchainBlockShardState

Получить seqno последного MasterChain блока. Пусть мы получили N.
Метод api_v3_get_masterchainBlockShardState возращает последние блоки в каждом Shard каждого WorkChain (за исключением MasterChain, где всегда только один Shard).
1. Запросить шард стет для MasterChain блока с seqno = N, сравнить его Shard state с Shard ateate для MasterChain блока N-1.
2. Существует 3 возможных ситуации для каждого Shard:
   a. Обычный случа: Было 0, 1 или более новых блоков в текущем шарде. Вам потребуется сканировать все эти блоки.
   b. Split：　Один шард исчез, появилось два новых, с новыми ID шарда. Новых блоков не может быть созданно в процессе разделения.
   с. Merge: Исчезло два шарда S1, S2 в N-1, и появился новый шард с seqno max(S1,S2)+ 1 в N. Нам нужны блоки которые появились в новом шарде.
3. Соберите список всех "новых" блоков между MasterChain блоками N-1 и N.
4. Получить все транзакции по этим блокам используя метод https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions .

Этот алгоритм уже имплементирован в методе https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block.
Но для большей безопасности рекомендуется самостоятельно процессить транзакции по блокам.

## Транзакция
….
Поля Транзакции
Транзакция в TVM и фазы

В TVM каждая транзакция выполняется по этапам:

1. **Storage phase**: Загружаем текущий стейт аккаунта в VM
2. **Credit phase**: Берем средства на выполнение инструкций
3. **Compute phase**: Выполнение контракта
4. **Action phase**: Отправка сообщений
5. **Bounce phase**: Обработка ошибок

# Успешность транзакции
1. Фаза Compute, Action возвращает Exit code в результате работы. Если они оба равны 0 (или 1) - транзакция выполнена успешно.
2. Однако, транзакция может не выполниться и отклониться ещё до выполнения Credit phase, Compute phase, Action phase - тогда Exit code не будет получен вовсе, и транзакция тоже не является успешной.
3. В контрактах расширяется логика Exit code TVM и добавляются дополнительные ошибочные коды для улучшения дебага. Но успешность выполнения транзакции как и всегда описывается Exit code.

Успешность операции (Event, Actions)
1. Успешность операции не является тем же самым что успешность транзакции.
Transaction success verified
Action success verified

