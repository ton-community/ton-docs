# Interact with transactions

## Как мне выяснить что моя транзакция выполнилась успешно с помощью метода API?
//TODO briefing: what you will learn in this guide

## Терминология

### Общие термины
#### Актор и модель актора

**Актор** — это абстрактная модель поведения, формализованная как вычислительный объект, который реагирует на входящие сообщения, изменяет своё состояние, создаёт новых акторов и отправляет сообщения другим.
Акторы изолированы: они не имеют доступа к состоянию друг друга и взаимодействуют только через сообщения.

**Акторная модель** — это модель параллельных вычислений, в которой система описывается как совокупность акторов, взаимодействующих через передачу сообщений.

Ключевые свойства модели:

* изоляция акторов;
* асинхронность коммуникаций;
* любая вычислительная абстракция может быть реализована как актор.

Модель используется для точного описания и анализа распределённых систем. Например:
* электронная почта может быть смоделирована как система акторов: пользователи представлены как акторы, адреса электронной почты — как адреса акторов;
* веб-сервисы с конечными точками (например, SOAP) можно интерпретировать как акторов, обрабатывающих сообщения по своему адресу.

**Акторная модель в TON**

TON реализует акторную модель как основу своей вычислительной архитектуры.

В TON все активные сущности — это акторы. В зависимости от наличия кода и структуры состояния, различают частные случаи акторов:
* Аккаунт — актор без кода, содержащий только состояние (например, баланс).
* Смарт-контракт — актор с кодом, определяющим его поведение.

#### Асинхронность

**Асинхронность** — это свойство взаимодействия, при котором отправка сообщения не требует немедленной готовности получателя.
Отправитель может инициировать передачу, не ожидая, что получатель в этот момент доступен или обработает сообщение сразу.


В отличие, от большинства сихнронных моделей, в TON контракты не вызывают друг друга напрямую. Вместо этого акторы отправляют сообщения друг другу, и каждый актор обрабатывает сообщение внутри себя без связи с другими акторами. Это значит, что один контракт не может узнать обновления состояния контракта по ходу обработки сообщения. Единственный способ узнать о результате, это получить в дальнейшем сообщение, в котором будет указана нужная информация.


> В отличие от синхронных блокчейнов, где можно "сделать вызов → получить ответ → принять решение", в TON каждая обработка сообщения — это изолированный внутри актора процесс. Результат этого процесса, в зависимости от наличия отправленного сообщения, может прийти позже (или не прийти вовсе - проверить и уточнить).


### Структура и взаимодействия акторов в TON
#### Аккаунт

Аккаунт в TON — это структура, хранящаяся в блокчейне по определённому адресу. Аккаунт состоит из:

* адрес `MsgAddressInt`,
* баланс `CurrencyCollection`,
* logical time последней транзакции `last_trans_lt`,
* статистику хранилища `StorageInfo`,
* состояние `AccountState`, определяющее его поведение.

#### Состояние аккаунта

TON определяет 3 состояния аккаунта (`AccountState`):

| Состояние         | Описание                                                                                                                    |
|--------------|-----------------------------------------------------------------------------------------------------------------------------|
| Uninitialized | Аккаунт не содержит кода, данных и баланса. Его состояние в блокчейне отсутствует до первого взаимодействия.  !!!!                       |
| Active       | Аккаунт содержит `StateInit`, в котором задан код `code`. Это смарт-контракт, способный выполнять код по входящим сообщениям.   |
| Frozen       | Аккаунт был удалён или заморожен, но оставлен контрольный хэш состояния. Он не может выполнять код или принимать сообщения. |


#### Статус аккаунта

Статус аккаунта - это ярлык, отражающий текущий этап жизненного цикла аккаунта в блокчейне. Он описывает, доступен ли аккаунт, содержит ли код, может ли быть активирован или больше не существует.

* Uninitialized
* active
* frozen
* non exist

:::important
Статус аккаунта — это абстрактная классификация, а не сериализуемая структура. Не путать с `AccountState`, который содержит полное бинарное состояние аккаунта (код, данные, хэш) на момент времени.
:::

#### Смарт контракт


Смарт-контракт в TON — это аккаунт, находящийся в активном состоянии `AccountState = active`, у которого:

* задана структура `StateInit`,
* внутри `StateInit` присутствует поле `code`.

Наличие `code` в `StateInit` делает аккаунт исполняемым и определяет его как смарт-контракт.


Наличие `code` в `StateInit` делает аккаунт исполняемым и определяет его как смарт-контракт.


#### Адрес

Адрес в блокчейне TON — это уникальный идентификатор любого аккаунта или смарт-контракта. Он используется для взаимодействия между (акторами, аккаунтами, контрактами). Адрес формируется на основе следующих компонентов:

**Структура адреса**

* Workchain ID — знаковое 32-битное целое число, определяющее workchain, к которой принадлежит аккаунт (например, -1 для MasterChain, 0 для BaseChain).
* Account ID — 256-битный хеш от `state_init`, уникально определяющий содержимое аккаунта.

**Что такое state_init?**

`state_init` — это набор данных, необходимый для деплоя контракта на аккаунте. Он включает:

* код смарт-контракта
* начальные данные

Так как адрес определяется как хеш этого `state_init`, даже небольшое изменение кода или данных приведёт к совершенно новому адресу.
(TODO не забыть уточнить - валидаторы перепроверяет отправителя, и перезаписывают адрес отправителя в сообщении)



:::important
`state_init` — это не полное состояние аккаунта, а только начальное состояние. Полное состояние включает текущее значение баланса, данные, очередь сообщений и другие параметры, которые могут меняться со временем. Однако эти изменения не влияют на адрес, поскольку адрес зависит только от начальной конфигурации `state_init`.
:::


#### Отношение TON-сущностей и парадигма в сообществе TON разработчиков

В разговоре разработчики могут называть вот этими терминами актор, аккаунт, смарт-контракт и адрес - смарт-контракт. Для единообразия терминологии и во избежание неоднозначностей в данном документе используется термин **аккаунт** как общее обозначение всех подобных сущностей. (лучше убрать)

#### Message feature

Сообщение это набор инструкций по желаемым действиям к одному актору.

#### Transaction feature

Транзакция это изолированное на аккаунте обновление его состояние, с опциональным исходящим сообщением. *** (рассказать что именно делает транзакция, какую функцию выполняет)

#### Асинхронная природа транзакций

В TON все аккаунты взаимодействуют исключительно посредством **сообщений** — это основа коммуникации между акторными сущностями. Каждое сообщение является частью транзакции, которая содержит информацию о состоянии и действиях, инициируемых этим сообщением.

Транзакции в сети обрабатываются **асинхронно**, что означает, что вызовы и изменения состояния аккаунтов происходят независимо друг от друга во времени.


#### AccountChain

**AccountChain** — это цепочка транзакций, связанных с одним конкретным аккаунтом в TON-блокчейне. Она представляет собой линейную последовательность: `Tx1 → Tx2 → Tx3 → …`, где каждая транзакция ссылается на предыдущую. Для удобства обработки и достижения консенсуса транзакции группируются в блоки — например, `[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]`. В блоках также содержатся очереди входящих и исходящих сообщений, фиксирующие все события и изменения состояния аккаунта за данный период.

**AccountChain** — это «микро-блокчейн» одного аккаунта. Он хранит и упорядочивает всю историю операций и взаимодействий аккаунта, обеспечивая прозрачность и прослеживаемость. В масштабе всей сети множество таких цепочек объединяются в ShardChain (или просто «шард»), который отвечает за обработку группы аккаунтов.

#### ShardChain

ShardChain — это блокчейн, объединяющий множество AccountChain-ов, то есть индивидуальных цепочек транзакций разных аккаунтов. Если AccountChain описывает историю операций одного аккаунта, то ShardChain отвечает за обработку и хранение данных целой группы аккаунтов с одинаковым бинарным префиксом в их адресах (например, все адреса начинаются с `0b00101`).

ShardChain можно представить как «горизонтальный» блокчейн, составленный из ShardBlocks, каждый из которых агрегирует AccountBlocks — блоки отдельных аккаунтов. ShardChain-ы также участвуют в маршрутизации сообщений между аккаунтами, гарантируя их доставку и соблюдение порядка: если одно сообщение было отправлено раньше другого, оно и прибудет раньше.

Таким образом, ShardChain — это ключевая структурная единица TON, которая обеспечивает параллельную обработку транзакций в масштабируемой и детерминированной архитектуре.


#### WorkChain

WorkChain — это самостоятельный блокчейн внутри TON, объединяющий множество ShardChain-ов (шардов). В отличие от шарда, WorkChain может иметь свои собственные правила. (пояснить)

TON поддерживает до 2³² WorkChain'ов, каждый из которых может быть разбит на 2⁶⁰ шардов.

#### Type of WorkChain: MasterChain and BaseChain

MasterChain — главный координирующий блокчейн. Он содержит:
* параметры протокола,
* список валидаторов и их стейки,
* мета-информацию о всех активных WorkChain’ах и ShardChain’ах,
* хэши последних блоков всех других цепочек.

MasterChain важен для функционирования всей сети, но из-за высокой стоимости используется в основном для системных целей.

BaseChain — основная рабочая цепочка, предназначенная для ежедневных транзакций и смарт-контрактов. Она недорогая и подходит для обычных пользователей и разработчиков.

![](/img/docs/blockchain-fundamentals/scheme.png)

#### Testnet and Mainnet

#### Mainnet (основная сеть)

Mainnet — это настоящая сеть, где:

* все транзакции реальны и необратимы;
* используются настоящие токены (например, реальные Toncoin);
* любые действия (переводы, запуск смарт-контрактов) влияют на основной блокчейн.

Все пользователи и проекты, которые работают “в продакшене”, используют именно Mainnet.

#### Testnet (тестовая сеть)

Testnet — это песочница для разработчиков, копия основной сети, но без риска. В ней:

* используются тестовые монеты, которые не имеют ценности;
* можно свободно тестировать контракты, транзакции, DApps и ошибки;
* блокчейн может быть сброшен или изменён в любой момент.

Testnet нужен, чтобы безопасно разрабатывать и отлаживать проекты, прежде чем запускать их в основной сети.

## Сообщения

### Сообщение

В блокчейне TON сообщение — это фундаментальная единица взаимодействия между аккаунтами (смарт-контрактами). Все действия, изменения состояния и выполнение логики в системе происходят через отправку и получение сообщений. Сообщения можно сравнить с запросами, отправляемыми на сервер.

* Transaction and message real life examples
### Tl-B structure
#### Message structure TL-B
  Теперь о данных в сообщении. Мы уже говорили что и в external, и internal сообщениях могут содержаться какие-то данные. Но как именно эти данные передавать? В TON все данные представлены в виде ячеек. Для того чтобы закодировать данные в ячейку, существует общепринятый стандарт для описания сериализации этих данных – TL-B.
  Простейший практический контракт в TON – это счетчик. Рассмотрим такой гипотетический пример и примеры возможных сообщений к нему. Пусть смарт-контракт может совершать два действия, увеличить или уменьшить внутреннюю переменную в нём. Тогда возможные сообщения описанные на языке TL-B будут выглядеть примерно так:

* Particular message structure
* Headers fields (CommonMsgInfo)

### Типы сообщений

Всего есть три типа сообщений:
- internal
- external incoming
- external outgoing


### Internal

Internal сообщение — это сообщение, отправленное от одного смарт-контракта другому внутри блокчейна TON. Когда смарт-контракт получает внутреннее сообщение, он знает:

* сколько монет TON прикреплено к сообщению,
* кто отправитель этого сообщения.
* блокчейн гарантирует целостность этой информации, что позволяет смарт-контракту безопасно ей доверять и использовать.

### External incoming

Прежде чем смарт-контракты смогут взаимодействовать друг с другом, отправляя внутренние сообщения, они должны быть активированы или профинансированы. Но как смарт-контракты получают свои первые Toncoin?

Некоторые сообщения поступают в систему извне блокчейна — то есть они не создаются существующими аккаунтами внутри сети. Такие сообщения называются *external incoming* сообщениями.

External incoming — это точка входа во внешний мир для блокчейна TON. Любой пользователь может отправить произвольные данные любому смарт-контракту, и уже контракт решает, как с ними обращаться.

Обычно они поступают от:

* пользователей — например, при отправке транзакции из кошелька;
* валидаторов или off-chain сервисов;
* ботов или скриптов — для автоматизации взаимодействия.

Хотя external-in сообщения редко используются в основной логике смарт-контрактов, они важны для кошельков. Почти каждое пользовательское действие в TON — например, отправка TON или взаимодействие с DEX — начинается с внешнего входящего сообщения от кошелька пользователя. После этого сам кошелек отправляет внутренние сообщения другим контрактам.

### External outgoing

External outgoing сообщения (external-out messages), также известные как events (события) — это особый тип сообщений, создаваемых смарт-контрактами, которые не доставляются конкретному получателю. Вместо этого они служат как логи или сигналы, которые можно отслеживать вне блокчейна.

Хотя такие сообщения редко используются в основной логике работы блокчейна, они играют важную роль в следующих задачах:

* индексация и мониторинг состояния блокчейна;
* запуск off-chain процессов, таких как уведомления внешних сервисов или обновление пользовательского интерфейса.

Например, смарт-контракт децентрализованной биржи (DEX) может сгенерировать внешнее исходящее сообщение после успешного обмена токенов — чтобы уведомить внешние сервисы или пользователей об этом событии.

External message examples and typical using
Internal message examples and typical using
Message value

Bounce of messages

Address with flags as field of message

Trace

Action

External message is an initiation of Action

Define that we need build internal message and wrap this in external message.
* Serializators for messages. (Message builders)
* Types of message descriptors
  * Дополнительные стандарты с TL-B (https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md)

#### Создание сообщение по TL-B

```
increase#34a3ff12 query_id:uint64 amount:uint32 = InternalMsgBody;
```

```
decrease#e4d5986b query_id:uint64 amount:uint32 = InternalMsgBody;
```

Это схема описывает 2 сообщения (сами данные). Когда мы работаем с сообщением, то тело сообщения и количество прикрепленных к нему TON – это два самых важных параметра.

В теле сообщения есть два конвенциональных поля – opcode и query_id. opcode – это 32-битное число означающее тип операции, а query_id – 64-битное число, которое смарт-контракт никак не должен использовать, и нужное лишь для удобства внешним сервисам.

Так в коде чтобы собрать тело сообщения

```
function generateMessageBody(amount: bigint): Cell {
const op = 0x34a3ff12;
const queryId = randomUint64();
const body = beginCell()
.storeUint(op, 32)
.storeUint(queryId, 64)
.storeUint(amount, 32)
.endCell();

    return body;
}
```
  * Build message serializer according to TL-B
  * Ресиверы в коде  (https://github.com/ton-blockchain/highload-wallet-contract-v3)
  * Build message serializer according to source code
  * Assembler (blockchain explorer preview/ https://tonviewer.com/EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1?section=code )

## Хэши в TON Blockchain

Хэши играют критически важную роль в экосистеме TON, обеспечивая идентификацию и верификацию данных на всех уровнях блокчейна. Понимание того, как работают хэши, поможет вам эффективно отслеживать транзакции, верифицировать сообщения и интегрировать ваши приложения с TON.

### Что такое хэш?

В контексте TON хэш — это уникальный криптографический отпечаток данных, вычисленный с помощью алгоритма SHA-256. Каждая ячейка (Cell), сообщение или транзакция имеют свой уникальный хэш, который служит их цифровой подписью.

:::info Важно
Хэши в TON необратимы — по хэшу нельзя восстановить исходные данные. Однако они детерминированы — одни и те же данные всегда дают одинаковый хэш.
:::

### Типы хэшей в TON

#### Хэш тела сообщения

Хэш тела сообщения — это уникальный идентификатор содержимого вашего сообщения. Он вычисляется от ячейки, содержащей данные сообщения.

**Практический пример:**

```typescript
import { beginCell } from '@ton/core';

// Создаем тело сообщения для увеличения счетчика
const messageBody = beginCell()
        .storeUint(0, 32) // op code
        .storeStringTail("Hello TON!")
        .endCell();
    
console.log("Message Body Hash:", messageBody.hash().toString("hex"));
```

**Когда использовать хэш тела сообщения:**
- Для проверки целостности данных
- При отладке и логировании операций
- Для дедупликации сообщений в вашем приложении

#### Хэш полного сообщения

Полное сообщение включает не только тело, но и заголовки с метаданными (отправитель, получатель, сумма, комиссии). Его хэш — это уникальный идентификатор всего сообщения.

**Практический пример:**

```typescript
import { storeMessage, beginCell, internal, Address } from '@ton/ton';
import { toNano } from '@ton/core';

// Создаем внутреннее сообщение
const internalMessage = internal({
  to: Address.parse('EQB...'), // адрес получателя
  value: toNano('0.1'),        // 0.1 TON
  body: messageBody             // тело сообщения из предыдущего примера
});

// Получаем хэш полного сообщения
const messageCell = beginCell()
  .store(storeMessage(internalMessage))
  .endCell();

const fullMessageHash = messageCell.hash();
console.log('Full Message Hash:', fullMessageHash.toString('hex'));
// Вывод: Full Message Hash: f1e2d3c4b5a6987...
```

**Когда использовать хэш полного сообщения:**
- Для отслеживания конкретных сообщений в блокчейне
- При работе с API TON Center для поиска транзакций
- Для верификации того, что сообщение не было изменено

#### Хэш транзакции

Хэш транзакции — это уникальный идентификатор всей транзакции, включающей входящие и исходящие сообщения, изменения состояния и комиссии.

**Практический пример получения хэша транзакции:**

```typescript
import { TonClient } from '@ton/ton';
import { Address } from '@ton/core';

const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
  apiKey: 'your-api-key'
});

const transactions = await client.getTransactions(
  Address.parse('EQB...'), 
  { limit: 10 }
);

for (const tx of transactions) {
  const txHash = tx.hash();
  console.log('Transaction Hash:', txHash.toString('hex'));
  
  // Также можем получить хэш входящего сообщения
  if (tx.inMessage) {
    const inMsgCell = beginCell()
      .store(storeMessage(tx.inMessage))
      .endCell();
    const inMsgHash = inMsgCell.hash();
    console.log('Incoming Message Hash:', inMsgHash.toString('hex'));
  }
}
```

#### Нормализованный хэш сообщения

Нормализованный хэш сообщения — это инновационное решение проблемы надежного отслеживания транзакций в TON. Согласно [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467), этот подход обеспечивает стабильный идентификатор для external-in сообщений, устраняя влияние несущественных полей на хэш.

**Проблема, которую решает нормализация:**

Обычные хэши сообщений могут различаться для функционально идентичных сообщений из-за вариаций в полях `src`, `import_fee` и `init`. Это усложняет отслеживание транзакций и дедупликацию.

**Как работает нормализация:**

Нормализованный хэш вычисляется путем стандартизации следующих полей external-in сообщения:

1. **Source Address (`src`)**: Устанавливается в `addr_none$00`
2. **Import Fee (`import_fee`)**: Устанавливается в `0`
3. **InitState (`init`)**: Устанавливается в пустое значение
4. **Body**: Всегда сохраняется как ссылка

**Практический пример вычисления нормализованного хэша:**

```typescript
import { toNano, beginCell, Cell, Address } from "@ton/core";

function normalizeExternalMessage(destAddress: Address, bodyCell: Cell): Cell {
    try {
        const normalizedExtMessage = beginCell()
            .storeUint(0b10, 2) // ext_msg prefix (10 in binary)
            .storeUint(0, 2) // src -> addr_none (НОРМАЛИЗАЦИЯ!)
            .storeAddress(destAddress) // Address.parse(destAddress.toString({ bounceable: false })) если пытаться использовать .address из WalletContractV4
            .storeCoins(0) // import_fee:Grams -> 0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(false) // init:(Maybe (Either StateInit ^StateInit)) -> nothing$0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(true) // body:(Either X ^X) -> right$1 (НОРМАЛИЗАЦИЯ!)
            .storeRef(bodyCell) // Store body as reference (НОРМАЛИЗАЦИЯ!)
            .endCell();

        return normalizedExtMessage;
    } catch (error: any) {
        console.error("❌ Error in normalization:", error.message);
        throw error;
    }
}

// Пример использования
const messageBody = beginCell()
  .storeUint(0, 32) // opcode для простого перевода
  .storeStringTail('Normalized hash example')
  .endCell();

const destinationAddress = Address.parse('EQB...');
const normalizedExternalMessage = normalizeExternalMessage(destinationAddress, messageBody);
const normalizedHash = normalizedExternalMessage.hash().toString("hex");

console.log('Normalized Message Hash:', normalizedHash);
```

**Сравнение обычного и нормализованного хэшей:**

```typescript
import { toNano, beginCell, Cell, Address, external, internal } from '@ton/ton';

// 1. Создание тела сообщения
const messageBody = beginCell()
    .storeUint(0, 32) // op code
    .storeStringTail("Hello TON!")
    .endCell();

// 2. Создание intenal message через wrapper
const internalMessage = internal({
    to: walletAddress,
    value: toNano("0.01"),
    body: messageBody
});
// 3. Создание external message через wrapper
const externalMessage = await contract.createTransfer({
    seqno,
    secretKey: keyPair.secretKey,
    messages: [internalMessage]
});

const originalHash = externalMessage.hash().toString("hex");
console.log("\nOriginal External Message Hash:", originalHash);

```

**Когда использовать нормализованный хэш:**

- **Отслеживание транзакций в реальном времени** — получите стабильный идентификатор сразу после отправки
- **Дедупликация сообщений** — избежите дублирования функционально идентичных операций  
- **TON Connect интеграции** — обеспечите надежную связь между фронтендом и бэкендом
- **Биржевые системы** — гарантируйте точное отслеживание пользовательских операций

**Уникальность и ограничения:**

Нормализованный хэш обеспечивает уникальность в типичных сценариях:

1. Сообщение отправляется на кошелек
2. Сообщение включает инструкцию с флагом IGNORE_ERRORS=+2
3. Кошелек никогда не удаляется

Нормализованный хэш сообщения представляет собой значительный шаг вперед в надежности отслеживания транзакций TON. Это решение уже активно используется командами Tonkeeper и TonAPI, что подтверждает его практическую ценность для разработчиков.

### Отправка сообщения и проверка факта отправки

Один из наиболее важных сценариев — это отправить сообщение и убедиться, что оно было обработано блокчейном.

**Пошаговый процесс:**

```typescript
import { WalletContractV4, internal, TonClient } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';
import { Address, toNano, beginCell } from '@ton/core';

async function sendAndVerifyMessage() {
  // 1. Создаем клиент и кошелек
  const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC'
  });
  
  const mnemonic = 'your mnemonic words here';
  const keyPair = await mnemonicToPrivateKey(mnemonic.split(' '));
  const wallet = client.open(WalletContractV4.create({
    publicKey: keyPair.publicKey,
    workchain: 0
  }));

  // 2. Создаем сообщение с комментарием
  const messageBody = beginCell()
    .storeUint(0, 32)           // opcode для простого перевода
    .storeStringTail('Hello TON!')
    .endCell();

  // 3. Отправляем транзакцию
  const seqno = await wallet.getSeqno();
  await wallet.sendTransfer({
    secretKey: keyPair.secretKey,
    seqno,
    messages: [internal({
      to: Address.parse('EQB...'),
      value: toNano('0.01'),
      body: messageBody
    })]
  });

  // 4. Проверяем факт отправки через некоторое время
  await new Promise(resolve => setTimeout(resolve, 10000)); // ждем 10 секунд
  
  const newSeqno = await wallet.getSeqno();
  if (newSeqno > seqno) {
    console.log('Транзакция успешно обработана!');
    
    // 5. Находим нашу транзакцию и получаем её хэш
    const transactions = await client.getTransactions(wallet.address, { limit: 5 });
    const ourTx = transactions.find(tx => 
      tx.inMessage?.info.type === 'external-in' && 
      tx.description.type === 'generic'
    );
    
    if (ourTx) {
      const txHash = ourTx.hash();
      console.log('Transaction Hash:', txHash.toString('hex'));
    }
  } else {
    console.log('Транзакция не была обработана');
  }
}
```

### Поиск транзакции по BOC

Когда вы отправляете транзакцию через TON Connect, вы получаете BOC (Bag of Cells). Вы можете использовать этот BOC для поиска соответствующей транзакции в блокчейне.

**Практический пример:**

```typescript
import { Cell, Address, beginCell, storeMessage, TonClient } from '@ton/ton';

async function findTransactionByBOC(
  externalBOC: string, 
  walletAddress: string
): Promise<string | null> {
  const client = new TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC',
    apiKey: 'your-api-key'
  });

  try {
    // Получаем хэш внешнего BOC
    const extHash = Cell.fromBase64(externalBOC).hash().toString('hex');
    
    // Получаем последние транзакции кошелька
    const transactions = await client.getTransactions(
      Address.parse(walletAddress), 
      { limit: 10 }
    );
    
    for (const tx of transactions) {
      const inMsg = tx.inMessage;
      if (inMsg?.info.type === 'external-in') {
        // Создаем хэш входящего сообщения
        const inHash = beginCell()
          .store(storeMessage(inMsg))
          .endCell()
          .hash()
          .toString('hex');
        
        console.log('External BOC hash:', extHash);
        console.log('Transaction message hash:', inHash);
        
        // Если хэши совпадают, мы нашли нашу транзакцию
        if (extHash === inHash) {
          const txHash = tx.hash().toString('hex');
          console.log('Найдена транзакция:', txHash);
          return txHash;
        }
      }
    }
    
    throw new Error('Транзакция не найдена');
  } catch (error) {
    console.error('Ошибка поиска транзакции:', error);
    return null;
  }
}

// Пример использования
const txHash = await findTransactionByBOC(
  'te6cckEBAgEAqQAB4YgA+yKcnwQCs1xAwIEKKB4DvkIdXNjL6B...', 
  'EQB...'
);
```

### Практические советы

#### Проверка статуса транзакции через API

```typescript
// Проверяем статус транзакции по её хэшу
async function checkTransactionStatus(txHash: string, walletAddress: string) {
  try {
    const response = await fetch(
      `https://testnet.toncenter.com/api/v2/getTransactions?` +
      `address=${walletAddress}&hash=${txHash}`
    );
    const data = await response.json();
    
    if (data.result.length > 0) {
      console.log('Транзакция найдена в блокчейне');
      return data.result[0];
    } else {
      console.log('Транзакция не найдена');
      return null;
    }
  } catch (error) {
    console.error('Ошибка при проверке транзакции:', error);
    return null;
  }
}
```

#### Хэш StateInit для верификации адресов

В [TON Connect](v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#backend-example) часто требуется верифицировать соответствие между адресом кошелька и его StateInit. Хэш StateInit должен совпадать с хэш-частью адреса.

**Практический пример верификации адреса:**

```typescript
import { Address, contractAddress } from '@ton/ton';

// Пример использования в TON Connect
const wantedAddress = Address.parse(payload.address);
const address = contractAddress(wantedAddress.workChain, stateInit);
if (!address.equals(wantedAddress)) {
  return false;
}
```

#### Мониторинг в реальном времени

```typescript
// Пример функции для мониторинга входящих транзакций
async function monitorIncomingTransactions(walletAddress: Address, client: TonClient) {
  let lastLt = '0';
  
  setInterval(async () => {
    try {
      const transactions = await client.getTransactions(walletAddress, { 
        limit: 10,
        lt: lastLt
      });
      
      for (const tx of transactions) {
        if (tx.lt > lastLt) {
          const txHash = tx.hash();
          console.log('Новая транзакция:', txHash.toString('hex'));
          
          // Обрабатываем входящие сообщения
          if (tx.inMessage) {
            const msgCell = beginCell()
              .store(storeMessage(tx.inMessage))
              .endCell();
            const msgHash = msgCell.hash();
            console.log('Хэш сообщения:', msgHash.toString('hex'));
          }
          
          lastLt = tx.lt;
        }
      }
    } catch (error) {
      console.error('Ошибка мониторинга:', error);
    }
  }, 5000); // проверяем каждые 5 секунд
}
```

### Лучшие практики

1. **Всегда сохраняйте хэши**: Записывайте хэши важных транзакций и сообщений для последующего отслеживания.

2. **Используйте правильный тип хэша**: Для отслеживания транзакций используйте хэш транзакции, для верификации данных — хэш сообщения.

3. **Учитывайте время подтверждения**: В TON транзакции обычно подтверждаются за 3-6 секунд, но в периоды высокой нагрузки может потребоваться больше времени.

4. **Реализуйте retry логику**: Если транзакция не появилась в блокчейне в течение минуты, стоит проверить её статус или повторить отправку.

Хэши — это ваш надежный инструмент для работы с TON блокчейном. Используйте их правильно, и ваши приложения будут работать стабильно и предсказуемо.

## Отправка сообщения

Есть два практических и важных для отличия случая, как можно отправить сообщение в блокчейн. Либо мы отсылаем сообщение с бэкенда являемся владельцем кошелька и можем сразу подписать и отправить сообщение в блокчейн, либо используя TON Connect на фронтенде мы можем собрать сообщение и предложить пользователю подписать и отправить его самому.

### Отправка с бэкенда

Когда у нас есть кошелек с сид фразой отправление сообщения происходит так
Код [отсюда](/v3/guidelines/dapps/cookbook/#how-to-transfer-ton-and-send-a-text-message-to-another-wallet)

### Отправка с фронтенда (TON Connect)
Тут мы просто предлагаем пользователю подписать сообщение

```
const myTransaction = {
validUntil: Math.floor(Date.now() / 1000) + 60, // 60 sec
messages: [
{
address: destination, // Address of smart contract to send internal message to
amount: amount, // Amount in nanotons to attach to the message
payload: Base64.encode(messageBody.toBoc())
}
]
}

tonConnectUI.sendTransaction(myTransaction)

```
## Get методы
Get methods
Build get method wrapper
Get balance
Get jetton wallet address
Get collection data

## Blockchain HTTP API
### Основные сервисы в TON

Мы рассмотрим сервисы которые выстраивают инфраструктуру нативно, другие поставщики API скорее всего используют одно из этих типовых решений.. Мы рекомендуется оценивать качество провайдера самостоятельно на основании исторических данных  и подходящих решений для вашей конкретной задачи.

#### TON Center
Сервисы TON Center это решение которое строится ресурсом команды TON Core на стеке GO. У TON Center два отдельных сервиса
TON Center API V3, который поставляет решения для индексации блокчейна.
TON Center API V2, который поставляет решения для быстрой чтения и отправки в блокчейн сообщений.

#### TON API
Решение в котором сфокусированы на поставление решинии бизнес задач и зачастую предлагает готовые решения для типовых задач в TON.

#### TONX API
API сервис начавший свое развитие TON Center, но продолжил закрытую разработку и расширение интерфейсов под нужды клиентов.

#### Tonhub API
HTTP API сервис с отличным подходом. Существуют задачи, для которых этот сервис подходит лучше.

### Транзакция это часть блока.

HTTP сервисы читают данные с Liteserver нод и десерализуют данные согласно стандартам описанным в TL-B. Данные которые минимально подвергаются постпроцессингу, иногда называют RAW data. Такие данные используются сервисами для самостоятельной аналитики, когда архитектурно важнее сделать решение более безопасным затратив на это больше внутреннего ресурса. Напротив, решения, которые не связанны с большим движением средств, но требуют какой-то аналитики событй в TON целесообразней имплементировать с помощью верхнеуровневых интерфейсов - интерфейсов API которые добавляют postprocessing информацию в выдоваемые данные.

Транзакция в TON упаковывается в блоки. Зафиналенные блоки БейсЧеина записываются в МастерЧейн блок. Соответственно для извлечения данных о выполненных транзакциях при читаются блоки MasterChain и соответствутющие блоки BaseChain. Кроме этого вложения, в TON всегда присутствует шардирование, которое тоже учитывается при парсинге каждого мастерчейн блока. Полученные блоки для каждого шарда, содержат все транзакции соответсвующие изначальному мастерчейн блоку.
У блоков всех воркчейнов одинаковая структура, для исследования транзакций, исследуется `block_extra`.

```tlb
block#11ef55aa global_id:int32
info:^BlockInfo value_flow:^ValueFlow
state_update:^(MERKLE_UPDATE ShardState)
extra:^BlockExtra = Block;
```

В свою очередь, часть блока `block_extra` содержит в себе структуру `account_blocks`. Именно в `account_blocks` содержатся транзакции обрабатанные всеми аккаунтами в соответсвующем шарде в пределах этого блока.

```tlb
block_extra in_msg_descr:^InMsgDescr
out_msg_descr:^OutMsgDescr
account_blocks:^ShardAccountBlocks
rand_seed:bits256
created_by:bits256
custom:(Maybe ^McBlockExtra) = BlockExtra;
```

Таким образом в процессе чтения блокчейна, сервисы итеративно обрабатывают от последнего считанного блока, до очередного нового зафиналенного.Полученные транзакции это RAW data, которая уже может выдаваться сервисам для дальнейшей работы. Так же, специальные сервисы анализируют и дополняют эти данные для удобства работы сервисов и балансирования между сложностью реализации и trustless подхода.

### Подходы к получению транзакции из API блокчейна

Термины и их соотношение.

Transaction - это обновление состояния аккаунта в блокчейне, инициированное входящим сообщением и опционально завершаемое отправкой одного или нескольких исходящих сообщений. Анализ содержимого тела транзакции - это фундаментальный подход для всех сервисов.

Trace - Это детерменированный граф транзакций порожденный одним external сообщением. Интерфейсы с trace позволяют получить весь граф для конкретной транзакции, чтобы их удобно изучать все связанные транзакции. Биржи могут иногда использовать чтобы посмотреть что произошло, чтобы получить граф транзакций для дальнейшей. Можно использовать как дополнительный поиск jetton transfer без jetton notification.
Нужно использовать тогда, когда обработка бизнес операции зависит от множества условий в согласованных транзакциях.

Action - Это агрегированная абстракция над несколькими изменениями аккаунтов, которое соответсвует одной бизнес операции. Пример Action - Перевод жетонов между двумя пользователями. Используется только для визуализации, никакой логики для движения средств.


##### Анализ верхнеуровневых данных

Как получить массив транзакций или транзакцию с помощью API?

Использование верхнеуровневых интерфейсов для событий(или операций): Get /Actions, Get /Traces, GET /jetton/transfers(burns), GET /NFT, GET /Actions.
В данном подходе, разработчику не требуется анализировать содержимое транзакций. Подход, когда разработчик не перепроверяет данные, можно использовать только если не требуется выполнять движение средств. Кроме простых проверок для сервисов, этот подход может быть частью более сложных алгоритмов, например поиск всех связанных транзакций методом Traces для их дальнейшего анализа.

#### Поиск транзакции по содержимому сообщению

GetTranasction by (external/internal) message (только api/v3). https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_message Очень хорошо когда следишь за 1 аккаунтом (до ~10). wallet-v4/wallet-v5 отправка, идеально. В основном используется для нахождения тр которая порождена ext. Важный момент, что есть задержка до 10 секунд. Поэтому лучше решается через pending.


#### Поиск транзакции по адресу аккаунта
Запрашивать транзакции по аккаунту который ты слушаешь (только APIv2) https://toncenter.com/api/v2/#/accounts/get_transactions_getTransactions_get этот метод доступен везде, даже на Liteclient. До ~100 аккаунтов приемлимый.

#### Сканирование блокчейна для получения полного массива транзакций
Перебор все транзакции с последнего блока MasterChain. Если от 1000 до infinity количество прослушиваемых аккаунтов.

Обработка через api/v2 : shards -> compute shard diff -> getBlockTransactionsExt for each block (в доке: https://docs.toncenter.com/docs/ton-center-cookbook#how-to-scan-blockchain)

Обработка через api/v3: В api/v3 не использовать алгоритм api/v2, метод https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block.

Выбор: либо очень простая имплементация с высоким уровнем доверия крупным провайдерам, либо сложная имплементация в которой не приходится доверять провайдеру. Но для большей безопасности всегда рекомендуется самостоятельно процессить транзакции по блокам.

За исключением первого подхода, результат поиска данных - это массив с одной или нескольими транзакциями: Transaction[]

#### API Transaction body

Транзакции уникальные на уровне API/v2 и API/v3
Тело объекта транзакции в API соответствует изначальной структуре обозначенной в TL-B по набору данных, но дополнительно расширенно постпроцессно вычисленными особенностями транзакции.
Например, одним из самых важных полей, который не содержится в блокчейне но вычисляется сервисом это хеш транзакции

```json
"hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM="
```

В блокчейне обычная транзакция, это структура описанная полным телом и уникальным заголовком


```tlb
transaction$0111 account_addr:bits256 lt:uint64
    prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
    outmsg_cnt:uint15
    orig_status:AccountStatus end_status:AccountStatus
    ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
    total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
    description:^TransactionDescr = Transaction;
```

Заголовок, TransactionDescr, определеяет природу транзакции в блокчейне. Все пользовательские транзакции для работы сервисов являются обычным - Ordinary:


```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

API сервис десериализует всю структуру с точностью до строковых и числовых типов данных. В связи с этим, тело транзакции возращаемое в json

```curl
apiv3 request body <-
```
Возвращает очень большую структуру:

<details>
```json
 {
          "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account of transcation
          "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=", 
          "lt": "15371766000003", # logical time, may have same values for txs on different accounts but every transaction on a given account will have unique lt
          "now": 1696238450, # unix timestamp
          "mc_block_seqno": 13353447, # seqno of masterchain block
          "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=", # tx_hash of the root transaction of the trace
          "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=", # hash of previous transaction on this account
          "prev_trans_lt": "15371704000004", # lt of prev. transaction
          "orig_status": "active", # account status before transaction
          "end_status": "active", # ... after transaction
          "total_fees": "12446659", # ... sum of fees from description
          "description": {
            "type": "ord",
            "aborted": false,
            "destroyed": false,
            "credit_first": false,
            "storage_ph": {
              "storage_fees_collected": "48",
              "status_change": "unchanged"
            },
            "compute_ph": {
              "skipped": false,
              "success": true,
              "msg_state_used": false,
              "account_activated": false,
              "gas_fees": "8823000",
              "gas_used": "8823",
              "gas_limit": "400000",
              "mode": 0,
              "exit_code": 0,
              "vm_steps": 178,
              "vm_init_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "vm_final_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            "action": {
              "success": true,
              "valid": true,
              "no_funds": false,
              "status_change": "unchanged",
              "total_fwd_fees": "10871000",
              "total_action_fees": "3623611",
              "result_code": 0,
              "tot_actions": 1,
              "spec_actions": 0,
              "skipped_actions": 0,
              "msgs_created": 1,
              "action_list_hash": "9XTNK6e1Fmmhd3cdzI0XcNDYRAoP5f5L4bWPUD3KNIE=",
              "tot_msg_size": {
                "cells": "23",
                "bits": "8377"
              }
            }
          },
          # reference for the block of the transaction
          "block_ref": {
            "workchain": 0,
            "shard": "8000000000000000",
            "seqno": 14627985
          },
          # in message
          "in_msg": {
            "hash": "O9XCuICyXBWOs4hHMOYA0k6o4GPBsWbAkjFi2qbttQE=", # hash of whole message
            "source": "0:F0C9C78F021AC65839B4006321A68BBB32DE5025F84C853CB9D75EB4894D0848", # account who has sended this message
            "destination": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account who received this message (for in_msg should be same as account of transaction)
            "value": "400000000", # attached TONS
            "fwd_fee": "1494679", # fee for forwarding the message using Hypercube Routing
            "ihr_fee": "0", # fee for forwarding the message throught Instant Hypercube Routing (now IHR is not implemented so this should be added to value)
            "created_lt": "15371766000002", # logical time of creation (usually slightly differs from transaction lt, where this message appears as an out_msg)
            "created_at": "1696238450", # unix timestamp
            "opcode": "0x0f8a7ea5", # opcode
            "ihr_disabled": true,
            "bounce": true, # if bounce should be perfomed on failure
            "bounced": false, # if bounce has happened
            "import_fee": null, 
            "message_content": { # message body
              "hash": "tWjTyEL/sabOLNt97uyCj5na740lW54GUcVa0UrSDao=", # hash of the message body
              # message body in base64 format
              "body": "te6cckEBAgEAiAABbQ+KfqUAAAAAdJizmkC/A/doAc9ztfOy5YIoBWjnofpWHchoFtAb/s4FvzXctxUu0Cf0ED8uUQMBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQIjm5Xw==",
              "decoded": null # text comment if it could be decoded
            },
            "init_state": null
          },
          "out_msgs": [
            {
              "hash": "FuV4JPR/uZZOCzZxWQ473bASToqChvKDLmnf5BiCspI=",
              "source": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # should coinside with transaction account for out_msg
              "destination": "0:794760D36E657A27CDB8D3D65F243D6B468CAD2C34AF413E7709390E4DBE9907",
              "value": "380306000",
              "fwd_fee": "7247389",
              "ihr_fee": "0",
              "created_lt": "15371766000004",
              "created_at": "1696238450",
              "opcode": "0x178d4519",
              "ihr_disabled": true,
              "bounce": true,
              "bounced": false,
              "import_fee": null,
              "message_content": {
                "hash": "o+VOluS6wdyl44k2AIFTcRBvdxZD/98275dunIWcVIA=",
                "body": "te6cckEBAgEAiAABbReNRRkAAAAAdJizmkC/A/doAeGTjx4ENYywc2gAxkNNF3ZlvKBL8JkKeXOuvWkSmhCQIH5cogYBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQPzgXtA==",
                "decoded": null
              },
              # init state in same format as message body
              # needed to deploy a new contract
              "init_state": {
                "hash": "eUdg025leifNuNPWXyQ9a0aMrSw0r0E+dwk5Dk2+mQc=",
                "body": "te6cckECFAEAA4AAAgE0AgEBhwgBz3O187LlgigFaOeh+lYdyGgW0Bv+zgW/Ndy3FS7QJ/UAN1wXvOOOdJfwh7sHnzxnFjjhTeJ04Bmd10caY4RPyrggAgEU/wD0pBP0vPLICwMCAWIEBQICywYHABug9gXaiaH0AfSB9IGoYQIBIAgJAIPSAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVICAUgKCwIBWAwNAMNCDHAJJfBOAB0NMDAXGwlRNfA/AQ4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwDeCCEBeNRRlSILqWMUREA/AO4DWCEFlfB7y6k1nwD+BfBIQX8vCAART6RDBwuvLhTYAfFQPTP/oA+kAh8ALtRND6APpA+kDUMFE2oVIqxwXy4sEowv/y4sJUNEJwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAySD5AHB0yMsCygfL/8nQBPpA9AQx+gAg10nCAPLixHeAGMjLBVAIzxZw+gIXy2sTzIDgIBIA8QAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQD9ztRND6APpA+kDUMAjTP/oAUVGgBfpA+kBTW8cFVHNtcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMn5AHB0yMsCygfL/8nQUA3HBRyx8uLDCvoAUaihggiYloCCCJiWgBK2CKGCCOThwKAYoSfjDyXXCwHDACOAREhMA2ztRND6APpA+kDUMAfTP/oA+kAwUVGhUknHBfLiwSfC//LiwoII5OHAqgAWoBa88uLDghB73ZfeyMsfFcs/UAP6AiLPFgHPFslxgBjIywUkzxZw+gLLaszJgED7AEATyFAE+gJYzxYBzxbMye1UgAHBSeaAYoYIQc2LQnMjLH1Iwyz9Y+gJQB88WUAfPFslxgBDIywUkzxZQBvoCFctqFMzJcfsAECQQIwAOEEkQODdfBAB2wgCwjiGCENUydttwgBDIywVQCM8WUAT6AhbLahLLHxLLP8ly+wCTNWwh4gPIUAT6AljPFgHPFszJ7VTOKoYI",
                "decoded": null
              }
            }
          ],
          # account state before the transaction
          "account_state_before": {
            "hash": "ICpM+dm0PYhxtwS/EnIwMAvOQbtDhVWMnPtMAlw5Dog=", # hash of whole account state
            "balance": "37821399", # balance
            "account_status": "active", # status of account (active, nonexist = deleted, frozen, uninitialized)
            "frozen_hash": null, # hash of state when it became frozen
            "data_hash": "XeSmBiLWvwn00CWu5oq/q9Q6d4luPKxnOWC4NgEeugU=", # hash of data
            "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc=" # hash of code
          },
          # account state after the transaction
          "account_state_after": {
            "hash": "7vvsHBjy5KoM/rIs6U8nHZt0pYOW5I3oTbBirxVK+Go=",
            "balance": "37821351",
            "account_status": "active",
            "frozen_hash": null,
            "data_hash": "aD0LD2LpPQYYR81n5b/EBHCPYmhBo4soNdvPoTL+xIk=",
            "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc="
          }
        }
```
</details>

В зависимости от задачи интересные к проверке поля могут меняться. Сейчас обозначим наиболее интересные
Native - содержится в блокчейне.
Postprocessing - досчитано на стороне API


| Поле            | Происхождение                 | Описание                                     | Пример                                         |
|-----------------|-------------------------------|----------------------------------------------|------------------------------------------------|
| trace_id        | Postprocessing                | tx_hash of the root transaction of the trace | 13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=   | 
| prev_trans_hash | Native                        | tx_hash of the root transaction of the trace | 6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=   | 
| in_msg          | Native object extended inside | In message body object                       | `"in_msg": {...}`                                |

TODO определеить набор полей которые здесь полезно рассмотреть.


## Транзакция

Любое изменение состояния аккаунта в блокчейне TON фиксируется при помоищ транзакций. В отличие от сообщений, транзакции не могут "двигаться", "отправляться" и "приниматься". Зачастую эти два термина путают, но важно понимать, что транзакция - это запись, которая фиксирует все изменения, произошедшие с одним конкретным аккаунтом.

### Состав тела транзакции на TL-B

Перед тем, как рассмотреть, как работают транзакции в TON, необходимо рассмотреть, из чего он состоит, используя TL-B. Для начала стоить уточнить, что транзакции деляться на несколько типов, однако в рамках данного туториала мы будем рассматривать только обычные транзакции. Именно эти транзакции интересны нам с точки зрения обработки платежей и разработки любого продукта.

```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

Согласно TL-B, транзакция состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `credit_first` | `Bool` | Указывает, должна ли сперва идти credit фаза или нет. Это зависит от того, [включён ли bounce](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.cpp#L3530). Более подробно это будет рассмотрено в одном из следующих разделов. |
| `storage_ph` | `Maybe TrStoragePhase` | Фаза, которая отвечает за обработку комиссий, связанных с хранилищем аккаунта.
| `credit_ph` | `Maybe TrCreditPhase` | Фаза, которая отвечает за обработку зачисления средств, которые поступили вместе с входящим сообщением, если это internal ([#1](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2926) и [#2](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2935)).
| `compute_ph` | `TrComputePhase` | Фаза, которая отвечает за выполнение кода смарт-контракта (кода, который хранится в соле `code` аккаунта).
| `action` | `Maybe ^TrActionPhase` | Фаза, которая отвечает за обработку созданных actions, которые были сгенерированы в процессе выполнения кода смарт-контракта.
| aborted | `Bool` | Указывает, была ли транзакция прервана на какой-либо из фаз. Если это поле равно `true`, то транзакция не была выполнена и все изменения, которые произошли на `compute_ph` и `action` фазах, не были применены.
| bounce | `Maybe TrBouncePhase` | Фаза, которая отвечает за обработку ошибок, которые произошли на `compute_ph` или `action` фазе.
| destroyed | `Bool` | Указывает, был ли аккаунт уничтожен в процессе выполнения транзакции.

:::info
Другие виды транзакций, такие как [trans_storage](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L352-L353), [trans_tick_tock](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L355-L357), [trans_split_prepare](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L362-L366) и другие нужны для событий, которые происходят незаметно для конечного пользователя. Например, разделение и соединение шардов, тик-ток транзакции и так далее.

Так как они не нужны для задач, связанных с разработкой DApps, то мы не будем их рассматривать в данном туториале.
:::

### Credit phase

Данная фаза довольно маленькая и простая. Если мы посмотрим исходный код блокчейна, то увидим, что основная логика этой фазы заключается в пополнении баланса контракта остатком средств из поступающего сообщения:

```cpp
  credit_phase->credit = msg_balance_remaining;
  if (!msg_balance_remaining.is_valid()) {
    LOG(ERROR) << "cannot compute the amount to be credited in the credit phase of transaction";
    return false;
  }
  // NB: msg_balance_remaining may be deducted from balance later during bounce phase
  balance += msg_balance_remaining;
  if (!balance.is_valid()) {
    LOG(ERROR) << "cannot credit currency collection to account";
    return false;
  }
```

### Storage phase

todo: расписать таким же образом, как и credit phase

### Compute phase


todo: расписать таким же образом, как и credit phase. При этом дополнительно добавить детали про опкоды, выполнение кода, exit код и так далее


### Action phase


todo: расписать таким же образом, как и credit phase. Не забыть про exit code и нюансы с send_ignore_errors


### Bounce phase


todo: расписать таким же образом, как и credit phase


### Полное тело транзакции

После того, как мы разобрали заголовок транзакции и её описание, мы можем посмотреть, как целиком выглядит любая транзакция в TON. Для начала посмотри на TL-B схему:

```tlb
transaction$0111 account_addr:bits256 lt:uint64 
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;
```

Здесь мы видим, что транзакция состоит из следующих полей:

| Поле | Тип | Описание |
| --- | --- | --- |
| `account_addr` | `bits256` | Адрес аккаунта, к которому относится транзакция. |
| `lt` | `uint64` | Логическое время транзакции. |
| `prev_trans_hash` | `bits256` | Хэш предыдущей транзакции, которая была выполнена на этом аккаунте. |
| `prev_trans_lt` | `uint64` | Логическое время предыдущей транзакции, которая была выполнена на этом аккаунте. |
| `now` | `uint32` | Время создания транзакции в формате Unix timestamp. |
| `outmsg_cnt` | `uint15` | Количество исходящих сообщений, которые были созданы в процессе выполнения транзакции. |
| `orig_status` | `AccountStatus` | Исходный статус аккаунта перед выполнением транзакции. |
| `end_status` | `AccountStatus` | Статус аккаунта после выполнения транзакции. |
| `in_msg` | `Maybe ^(Message Any)` | Входящее сообщение, которое было обработано в процессе выполнения транзакции. В случае с обычной транзакцией всегда будет присутствовать. |
| `out_msgs` | `HashmapE 15 ^(Message Any)` | Исходящие сообщения, которые были созданы в процессе выполнения транзакции. |
| `total_fees` | `CurrencyCollection` | Общее количество комиссий, которые были уплачены за выполнение транзакции. |
| `state_update` | `^(HASH_UPDATE Account)` | Объект, который содержит в себе хеш предыдущего состояния аккаунта и хеш нового состояния аккаунта.
| `description` | `^TransactionDescr` | Описание транзакции, которое содержит в себе информацию о фазах выполнения транзакции. Это поле мы уже разобрали выше. |

Поля `orig_status` и `end_status` содержат в себе информацию о том, как изменилось состояние аккаунта после выполнения транзакции. Всего существует 4 статуса:

```tlb
acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;
```

### Как правильно считать хеш транзакции

todo: здесь в основном js код

### Action: Tech Context

Расписать actions согласно tl-b:

```tlb
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;
```

### Action: User Context (a.k.a. Event)

Здесь в конце мы привём к выводу, что в дальнейшем будем использовать термин Event.

### Как получить транзакцию, используя api/v2

### Как получить транзакцию, используя api/v3


### Поля транзакции в API
### Поля транзакции в SDK
* ton/ton'
* ton4j

### Успешность Event в экосистеме: Ordinary TON Transfer

Как мы ранее уже обсуждали, в TON всё происходит асинхронно, поэтому успешность одной транзакции не означает, что вся цепочка успешно завершилась или завершится в будущем. Поэтому мы должны опираться на более абстрактные понятия успешности.

Например, если мы хотим отправить TON с одного кошелька на другой, то успешность этой операции будет означать, что средства были успешно зачислены на целевой кошелек. Для этого нам необходимо получать последние транзакции на целевом аккаунте, время создания которых больше или равно, чем время создания транзакции, в которой возникло сообщение, отправляющее TON.

todo: здесь хорошо бы иметь пример кода, который это делает

:::danger
todo: Здесь про то, что нужно учитывать атаку с баунсом, когда средства возвращаются обратно
:::

### Успешность Event в экосистеме: NFT Transfer



### Успешность Event в экосистеме: Jetton Transfer


### Как исследовать контракт и его схему в TL-B, чтобы построить логику для анализа успешной операции

В этом разделе мы на основе Jetton Wallet контракта рассмотрим, как на основе его кода понять, что необходимо проверить для того, чтобы убедиться, что операция была целиком успешно завершена.

todo: разбор func кода, на основе jetton_transfer определить успешность операции и немного примеров на ts коде

## Build an internal message and wrap this in external message 

Смарт-контракты взаимодействуют друг с другом, отправляя так называемые Internal сообщения. Когда Internal сообщение достигает своего адресата, создается обычная транзакция от имени акккаунта получателя, а Internal сообщение обрабатывается в соответствии с кодом и постоянными данными этого аккаунта (смарт-контракт).

External же сообщения отправляются извне в смарт-контракты, находящиеся в блокчейне TON, чтобы заставить их выполнить определенные действия.

Например, смарт-контракт кошелька ожидает получения External сообщений, содержащих заявки (например, Internal сообщения, которые должны быть отправлены из смарт-контракта кошелька), подписанных владельцем кошелька. Когда такое External сообщение получено смарт-контрактом кошелька, он сначала проверяет подпись, затем принимает сообщение (запуская примитив TVM ACCEPT), а затем выполняет все необходимые действия.

## Serializators for messages

Прежде чем погрузиться в создание сообщений, давайте познакомимся с концепцией ячеек, из которых состоят тела сообщений.

### Что такое ячейка?

Ячейка — это базовая структура данных в блокчейне TON. Она может хранить до 1023 бит и содержать до 4 ссылок на другие ячейки, что позволяет хранить более сложные структуры данных. Такие библиотеки, как @ton/core и @ton-community/assets-sdk, предоставляют эффективные способы обработки ячеек.

### Создание ячейки

Чтобы создать ячейку, используйте функцию beginCell(). Пока ячейка "открыта", вы можете хранить различные типы данных с помощью функций store...(). Когда работа закончена, закройте ячейку с помощью функции endCell().

```
import { Address, beginCell } from "@ton/ton";

const cell = beginCell()
  .storeUint(99, 64) // Stores uint 99 in 64 bits
  .storeAddress(Address.parse('[SOME_ADDR]')) // Stores an address
  .storeCoins(123) // Stores 123 as coins
  .endCell() // Closes the cell
```

### Анализ ячейки

Чтобы прочитать или проанализировать данные из ячейки, вызывается функция beginParse(). Вы считываете данные в том же порядке, в котором они были сохранены, используя аналогичные функции load...():

```
const slice = cell.beginParse();
const uint = slice.loadUint(64);
const address = slice.loadAddress();
const coins = slice.loadCoins();
```

### Большие объемы данных

Каждая ячейка имеет ограничение в 1023 бита. Если вы превысите его, возникнет ошибка:

```
// This will fail due to overflow
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeUint(3, 256)
  .storeUint(4, 256) // Exceeds 1023-bit limit (256 + 256 + 256 + 256 = 1024)
  .endCell()
```
Чтобы сохранить больше данных, ячейки могут ссылаться на другие ячейки. Вы можете использовать функцию storeRef() для создания вложенных ячеек:

```
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeRef(beginCell()
    .storeUint(3, 256)
    .storeUint(4, 256)
    .endCell())
  .endCell()
```

Чтобы загрузить ячейку, на которую есть ссылка (вложенную), используйте loadRef():

```
const slice = cell.beginParse();
const uint1 = slice.loadUint(256);
const uint2 = slice.loadUint(256);
const innerSlice = slice.loadRef().beginParse(); // Load and parse nested cell
const uint3 = innerSlice.loadUint(256);
const uint4 = innerSlice.loadUint(256);
```

### Необязательные ссылки и значения

Ячейки могут хранить необязательные значения (которые могут быть нулевыми). Они сохраняются с помощью функций storeMaybe...():

```
const cell = beginCell()
  .storeMaybeInt(null, 64) // Optionally stores an int
  .storeMaybeInt(1, 64)
  .storeMaybeRef(null) // Optionally stores a reference
  .storeMaybeRef(beginCell()
    .storeCoins(123)
    .endCell());
```

Вы можете анализировать необязательные значения с помощью соответствующих функций loadMaybe...(). Возвращаемые значения могут быть нулевыми, поэтому не забудьте проверить их на нулевое значение!

```
const slice = cell.beginParse();
const maybeInt = slice.loadMaybeUint(64);
const maybeInt1 = slice.loadMaybeUint(64);
const maybeRef = slice.loadMaybeRef();
const maybeRef1 = slice.loadMaybeRef();
if (maybeRef1) {
  const coins = maybeRef1.beginParse().loadCoins();
}
```

### Пример полноценного построения internal сообщения

```
import {Address, beginCell} from "@ton/core";

// serialization
const cell = beginCell()
  .storeUint(260734629, 32)
  .storeUint(42, 64)
  .storeCoins(100)
  .storeAddress(Address.parse('[DESTINATION]'))
  .storeAddress(Address.parse('[RESPONSE_DESTINATION]'))
  .storeMaybeRef(null)
  .storeCoins(1)
  .storeMaybeRef(null)
  .endCell();

// deserialization
const slice = cell.beginParse();
const op = slice.loadUint(32);
const queryId = slice.loadUint(64);
const amount = slice.loadCoins();
const destination = slice.loadAddress();
const responseDestination = slice.loadAddress();
const customPayload = slice.loadMaybeRef();
const fwdAmount = slice.loadCoins();
const fwdPayload = slice.loadMaybeRef();

const transferMessage = { op, queryId, amount, destination, responseDestination, customPayload, fwdAmount, fwdPayload };
```

# Types of message descriptors

## Анализ TL-B схемы

Теперь после базового погружения в термины, мы можем приступить к практическому применению наших знаний на постройке скрипта на отправку сообщения, пользуясь tl-b.

### TL-B Схема

Если вы не знакомы с тем, что такое tl-b, то ознакомиться можно здесь: https://docs.ton.org/v3/documentation/data-formats/tlb/tl-b-language. 

Представим, что мы имеем tl-b схему, сообщение из которой нам нужно упаковать в скрипт и отправить. В этом примере я взял tl-b с https://github.com/evaafi/contracts/blob/maiоn/schema/schema.tlb#L132.


```
tlb

revert_call#0000000f query_id:uint64 owner_address:MsgAddressInt revert_body:^Cell = InternalMsgBody
```

Прежде чем писать скрипт, давайте сначала разберём полученную нам tl-b схему.
#### Разбор структуры:

- `#0000000f` - оп-код, который ставится первым по порядку при формировании сообщения (всегда занимает 32 бита (uint32)). 
- `query_id:uint64` - Идентификатор запроса, который всегда ставится вторым по порядку при формировании сообщения (всегда занимает 64 бита (uint64))
- `owner_address:MsgAddressInt` - Адрес владельца (как правило, передаётся в смарт-контракте в виде slice)
- `revert_body:^Cell` - Ссылка на дополнительную ячейку (ссылка на ячейку, в которой лежит вся дополнительная информация для данной операции (cell)).

## Анализ FunC контракта

### FunC код:

Если вы не знакомы с языком FunC, то изучить его можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/func/overview/. 

Теперь представим, что мы имеем FunC код, который демонстрирует как с помощью предыдущей tl-b схемы получилось удобно упаковать сообщение, которое нам нужно передать в скрипт и отправить. В этом примере я взял FunC код с https://github.com/evaafi/contracts/blob/main/contracts/logic/user-revert-call.fc. 

```
func 

() revert_call(
    slice sender_address, slice owner_address,
    slice in_msg_body
) impure method_id(0x770) {
    
    send_message(
        sender_address, 0,
        begin_cell()
        .store_uint(0x0000000f, 32)
        .store_uint(0, 64) ;; query_id
        .store_slice(owner_address) ;; 3+8+256
        ;; Part above is totalling: 32 + 64 + 3+8+256 = 363 bits,
        ;; which is significant -> Let's keep in_msg_body in a separate cell
        .store_ref(
            begin_cell().store_slice(in_msg_body).end_cell()
        ) ;; revert_body
        .end_cell(),
        64 ;; is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.
    );
    commit(); 
    throw(error::user_code_version_mismatch);
}

```

Разберём важные моменты. В этом примере мы просто будем отправлять сообщение на нужный нам адрес, т. е. у нас нет recv_internal(), который бы скомпилировал контракт с этим оп-кодом и сообщением с ним, а только после этого мы бы на имеющийся контракт отправили нужное нам сообщение. 
Прежде чем идти писать скрипт, давайте проверим все ли аргументы нам подходят и все ли совпадает с tl-b схемой:
`.store_uint(0x0000000f, 32)` - этот оп-код нам подходит, так как его мы видели в tl-b схеме, также он стоит первым по списку.
`.store_uint(0, 64)` - query_id всегда передаётся в формате 64 битов, в данном случае у него номер 0.
`.store_slice(owner_address)` - третьим по списку передаётся адрес, как и в tl-b всё соответствует. 
`.store_ref(begin_cell().store_slice(in_msg_body).end_cell())` - четвёртым по списку передаётся cell, как и в tl-b всё соответствует.

Теперь когда мы уверены в том, что вся информация передана правильно, можно составлять сообщение благодаря Blueprint SDK.

## Assembler

Код FunC по сути является списком объявлений/определений функций и объявлений глобальных переменных. Определять op-code можно не только по tl-b, но и напрямую через asm консрукции:

```
int op::transfer() asm "0x5fcc3d14 PUSHINT";
int op::ownership_assigned() asm "0x05138d91 PUSHINT";
int op::excesses() asm "0xd53276db PUSHINT";
int op::get_static_data() asm "0x2fcb26a2 PUSHINT";
int op::report_static_data() asm "0x8b771735 PUSHINT";
int op::get_royalty_params() asm "0x693d3950 PUSHINT";
int op::report_royalty_params() asm "0xa8cb00ad PUSHINT";
```

Стоит отметить, что есть op-code, которые являются core логикой TVM и если вы будете использовать для своих op-codes такие же числовые переменные, то будет выбрасываться ошибка Exit Code 6 (Compute Phase). 

## 3. Typescript реализация

### Настройка окружения

Устанавливаем нужные нам модули: 

Команда npm create ton@latest установит окружение Blueprint SDK.

```
cd revert-call-msg
npm create ton@latest
или если вы хотите поставить только нужные вам модули, то сделайте так:
npm install @ton/core @ton/blueprint 
```

## Сборка скрипта на отправку сообщения

Когда вы установили все нужные модули создаём папку /scripts (в окружении Blueprint SDK) она есть сразу. Больше изучить работу в Blueprint SDK можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/getting-started/javascript/. Весь следующий код будет разделён на шаги для простоты повестования, используйте его в одном файле.
Для простоты использования начнём с интерфейсами и передадим туда необходимые нам модули, такие как адрес смарт-контракта куда отправится наше сообщение, адрес владельца, query_id и revert_body. Для Cell и Address используем импортым из библиотеки @ton/core. После определения модулей в интерфейсе можно переходить к основной функции.  

```
typescript

import { 
  Address, 
  beginCell, 
  Cell, 
  toNano 
} from '@ton/core';
import { 
  NetworkProvider 
} from '@ton/blueprint';

interface RevertCallParams {
  contractAddress: Address;  // recipient msg address
  ownerAddress: Address;      
  queryId?: bigint;           
  revertBody?: Cell;         
}
```

В данной функции мы будем реализовывать основную логику отправки сообщения при помощи ранее созданного интерфейса. В contractAddress подставляется нужный адрес смарт-контракт для отправки сообщения. В ownerAddress подставляется адрес владельца контрактом, иначе при проверке смарт-контракта сообщение упадёт, ведь такого владельца не существует, а отправитель не имеет прав на отправку этого сообщения. revertBody упаковывается при помощи дополнительный функции, которая передаёт необходимый нам Cell in_msg_body. После этого сообщение отправляется с нужными нам аргументами. Теперь нам осталось лишь отправить это сообщение.

```
export async function run(provider: NetworkProvider) {
  const contractAddress = Address.parse(
    "EXISTING_CONTRACT_ADDRESS_HERE"
  );
  const ownerAddress = Address.parse(
    "OWNER_ADDRESS_HERE"
  );

  const revertBody = prepareRevertBody();

  await sendRevertCall(provider, {
    contractAddress,
    ownerAddress,
    queryId: 0n,
    revertBody
  });
}
```

В этой функции мы отправим нужное нам сообщение на нужный контракт. Создаём тело сообщения как это было в tl-b, а позднее и в смарт-контракте. Библиотека @ton/core сама даст нам нужные модули для составления сообщения, подобно как в смарт-контракте на FunC. Ставим обработку сообщения через try catch и отправляем сообщения на нужный адрес, учитывая fees на газ (обычно это около 0.05-0.1 тона) и вставляем наше тело. В конце добавляем ошибки, которые могут возникнуть при отправке сообщения (несовпадение адресов отправителей и админа смарт-контракта, нехватка тонов или неправильно построенное сообщение). 

```

async function sendRevertCall(
  provider: NetworkProvider, 
  params: RevertCallParams
) {
  // Создание тела сообщения
  const messageBody = beginCell()
    .storeUint(0x0000000f, 32)  // Op-код Revert Call
    .storeUint(params.queryId || 0n, 64)  // Query ID
    .storeAddress(params.ownerAddress)  // Адрес владельца
    .storeRef(params.revertBody)
    .endCell();

  try {
    await provider.sender().send({
      to: params.contractAddress,
      value: toNano('0.1'),  // Газ
      body: messageBody
    });

    console.log(`Сообщение revert-call отправлено на адрес: ${params.contractAddress}`);
  } catch (error) {
    console.error('Ошибка при отправке revert-call:', error);
  }
}

function prepareRevertBody(): Cell {
  return beginCell()
    .storeUint(0x01, 8)  
    .storeBuffer(
      Buffer.from('Данные для revert-call', 'utf-8')
    )
    .endCell();
}
```

