import { BlockMath, InlineMath } from 'react-katex';
import 'katex/dist/katex.min.css';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Interact with transactions

## How can I check if my transaction was successful using the API?
//TODO briefing: what you will learn in this guide

## Terminology

### Actor 

An **actor** is an abstract behavioral model, formalized as a computational object that reacts to incoming messages, changes its internal state, creates new actors, and sends messages to others. Actors are isolated: they do not have access to each other’s state and interact only through message passing.

In other words:

An actor is an independent entity with its state and behavior. Actors interact by exchanging messages. Each actor can:
* change its state
* send messages to other actors
* spawn new actors


![](/img/docs/blockchain-fundamentals/actor_eng_light.svg)


### Actor model

The **actor model** is a model of concurrent computation in which a system is described as a collection of actors that interact through message passing.

Key properties of the model:
* actor isolation
* asynchronous communication
* any computational abstraction can be implemented as an actor

The model is used to precisely describe and analyze distributed systems. For example:
* Email can be modelled as an actor system: users are represented as actors and email addresses serve as actor addresses.
* Web services with endpoints (e.g., SOAP) can be interpreted as actors that handle messages sent to their addresses.

In TON, all active entities are actors.


### Account

An **account** in TON is an actor characterized by the following components:
* **General account state** — common properties of any account: *ID, balance, status, and last transaction (`last_tx`)*
* **Data** — custom account-specific state
* **Code** — custom logic defining the account's behavior

The general state fully defines all account types in TON. Examples:
* `(ID1, 0, unexist)`
* `(ID2, 10, uninit, last_tx)`
* `(ID3, -0.5, frozen)`


![](/img/docs/blockchain-fundamentals/account_eng.svg)


### Smart contract

An account that, in addition to the general state, also contains **code** and **data** is called a **smart contract**.

![](/img/docs/blockchain-fundamentals/smart_contract_eng.svg)

#### Difference between an account and a smart contract

- An **account** is an actor that has a general state — such as balance, address, and status — and may optionally include code and data.

Example: `(ID1, 0, unexist)` or `(ID2, 2, inited, last_tx, data, code)`
- A **smart contract** is an actor with **mandatory** code and data that define its specific behavior.

Example: `(ID2, 2, inited, data, code)`


#### Entity structure in TON Blockchain

![](/img/docs/blockchain-fundamentals/structure_eng.svg)

### Asynchrony

In TON, contracts or actors do not call each other directly. Instead, they communicate by sending messages, each of which is processed independently of the others. All interaction happens through asynchronous message passing.

**Asynchrony** is a property of communication, meaning that sending a message does not require the recipient to be immediately available.
* The sender doesn’t wait for a response — it simply sends the message.
* The recipient may process the message later when it’s their turn.
* If a result is required, the recipient must send a new message explicitly. Otherwise, the sender won’t receive any feedback.

This is different from synchronous models, where the flow is: call → wait for a response → continue.
In TON, a result can only be received as a separate message — and only if it is explicitly sent.

![](/img/docs/blockchain-fundamentals/actors_msging_eng.svg)

### Structure and communication of actors in TON

#### Account

Earlier, we mentioned that an account is an actor defined by the following components:

* General account state (ID, balance, status, last_tx)
* Data
* Code

In practice, the actual data layout is more complex, but the logical distinction between an account and a smart contract remains the same. To describe data structures, in TON, TL-B schemas are used. These define how data is laid out at the bit level.

Let’s take a look at how an account is defined.
The account structure consists of several nested objects:

```tlb
account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```

* Address — `MsgAddressInt`
* Balance — `CurrencyCollection`
* State — `AccountState`, which defines the account’s behavior
* Logical time of the account's last applied transaction — `last_trans_lt`
* Storage statistics — `StorageInfo`

<details>

  ```tlb

  account_none$0 = Account;
  account$1 addr:MsgAddressInt storage_stat:StorageInfo
  storage:AccountStorage = Account;

  account_storage$_ last_trans_lt:uint64
  balance:CurrencyCollection state:AccountState
  = AccountStorage;

  account_uninit$00 = AccountState;
  account_active$1 _:StateInit = AccountState;
  account_frozen$01 state_hash:bits256 = AccountState;

  acc_state_uninit$00 = AccountStatus;
  acc_state_frozen$01 = AccountStatus;
  acc_state_active$10 = AccountStatus;
  acc_state_nonexist$11 = AccountStatus;


  _ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

  ```
</details>

Let’s clarify which properties are part of the **general account state**, according to the TL-B schema:

* ID → `MsgAddressInt`
* Balance → `CurrencyCollection`
* Status → `AccountState`
* Last transaction logical time (`last_trans_lt`) — also part of the general state

Meanwhile, the data and code are defined within the state:` AccountState` field.

Now, let’s take a closer look at the general account state and how it’s represented in the data layout.

#### Account status

TON defines account states `AccountState` as follows:

| Status     | TL-B Code | Description                                                                                                                                   |
|------------|------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `uninit`   | `00`       | The account exists but contains no code or data. It may hold a non-zero balance but is not initialized yet.                                      |
| `frozen`   | `01`       | The account is frozen: its code and data are deleted, but a hash of the previous state is retained. It can't be used, but it can be restored. **CHECK** The account has zero or negative balance, or doesn't meet the workchain’s minimum requirement.     |
| `active`   | `10`       | The account includes a `StateInit` with code and data. It is an active smart contract, ready to process incoming messages.             |


```tlb
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;
```


#### Smart contract

Smart contracts are a set of promises in digital form, including protocols by which the parties fulfill these promises.

In TON typically by smart contract recognize:
- the program code executed described in FunC, Tact or Tolk in the blockchain.
- the account that implement business logic and contets code.

The diagram below illustrates the lifecycle of an account in the TON blockchain, showing how its state changes under different conditions.


![](/img/docs/blockchain-fundamentals/account_states.svg)



A smart contract is an account with mandatory code and data which define its unique behavior.
In terms of TON account, this means:

* A smart contract in TON is an `Account` in the active state (`AccountState = active`)
* The `code` field in `StateInit` is initialized
* The `data` field in `StateInit` is initialized

The presence of `code` and `data` in `StateInit` makes an account executable and defines it as a smart contract.

A smart contract is an actor that must have both code and data, which together define its unique behavior.
In terms of actual data, this means:

* A smart contract in TON is an `Account` in the active state `AccountState = active`
* The `code` field in `StateInit` is initialized
* The `data` field in `StateInit` is initialized

The presence of both `code` and `data` in `StateInit` makes the account executable and qualifies it as a smart contract.

#### Address

An address in TON is a unique identifier for a smart contract required for interaction between network participants.
Account itself has address, but we completly define the address for arbitary using only with smart contract.
It consists of the following components:


* **WorkChain ID** — a 32-bit signed integer indicating the WorkChain to which the account belongs (e.g., -1 for the MasterChain, 0 for the BaseChain).
* **Account ID**— a 256-bit hash of the `StateInit` structure, which contains the contract’s initial state: `code`, `data`, and optionally a `library`.

The address is defined as:

<BlockMath math="{Address} := ({workchain\_id},{account\_id})" />, where <BlockMath math="{account\_id}:= {SHA256(BoC(StateInit))}" />
Here, boc (bag of cells) is a special serialization format used in TON.

An address corresponds to a specific initial state of a contract and can be calculated even **before** the contract is deployed.
This allows you to use the address ahead of time — for example, to receive tokens or set up interactions.

:::important
An address depends only on the `StateInit`. Even a small change to the `code`, `data`, or `library` results in a completely different `account_id`.

At the same time, `StateInit` defines only the initial configuration of the contract. It does **not** include balance, current data, message queue, or any other runtime parameters. These changes do not affect the address.
In fact, during message processing, validators verify the sender’s address — if it’s incorrect, they silently replace it with the correct one.
:::

#### Message feature

A message is a set of instructions intended for a single actor.

#### Transaction feature

A transaction represents an update to an account's state triggered by an incoming message.
It may also produce one or more outgoing messages, depending on the contract logic.

In TON, a transaction is required to update an account's state in response to an incoming message and, if necessary, to continue interacting with other accounts by sending outgoing messages.

#### Asynchronous nature of transactions

In TON, accounts interact exclusively through messages — this is the core of actor-based communication.
Each message triggers a transaction, which records the entire context: the triggering message, state updates, and any generated outbound messages.

Transactions are processed **asynchronously**, meaning that each account’s updates and message handling occur independently over time.

#### AccountChain

**AccountChain** is a chain of transactions executed on a single account in the TON blockchain.
It forms a linear sequence: `Tx1 → Tx2 → Tx3 → …`, where each transaction references the previous one.
For efficient processing and consensus, transactions are grouped into blocks — for example:
`[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]`.

These blocks also include incoming and outgoing message queues, recording all events and state changes for the account during that period.

In other words, an AccountChain is a *micro-blockchain* scoped to a single account.
Like a regular blockchain, it is a linear, append-only sequence of transactions — but dedicated to just one account.
It stores and orders the entire history of that account’s operations and interactions, ensuring transparency and traceability.

At the network level, many such chains are grouped into a **ShardChain** or simply **shard**, which manages a collection of accounts. This abstraction supports logical grouping *AccountChains* across physical infrastructure *ShardChain ↔ Validator*.

The diagram below provides a graphical representation of an AccountChain and its structure.
![](/img/docs/blockchain-fundamentals/accountchain.svg)

#### ShardChain

A **ShardChain** is a blockchain that aggregates multiple AccountChains.
While an AccountChain represents the transaction history of a single account, a ShardChain processes and stores data for a group of accounts that share a common binary address prefix (e.g., all addresses starting with `0b00101`).
C
onceptually, a ShardChain can be seen as a **horizontal** blockchain composed of **ShardBlocks**, each of which contains AccountBlocks. ShardChains also facilitate message routing between accounts, ensuring both delivery and order: if one message is sent before another, it will arrive first.

ShardChains are a fundamental unit of TON’s architecture, enabling parallel transaction processing within a scalable and deterministic system.
Each validator is responsible for a specific ShardChain or a group of them, allowing the network to process transactions concurrently across different shards.

![](/img/docs/blockchain-fundamentals/shardchain.svg)

#### WorkChain

A **WorkChain** is an independent blockchain within TON that groups multiple ShardChains or shards.
Unlike a ShardChain, a WorkChain may define its own protocol rules.

TON supports up to 2³² WorkChains, each of which can be divided into up to 2⁶⁰ ShardChains.

#### Types of WorkChain: MasterChain and BaseChain

**BaseChain** is the primary execution chain used for everyday transactions and smart contracts.
It is optimized for low fees, making it suitable for regular users and developers.

![](/img/docs/blockchain-fundamentals/basechain.svg)


**MasterChain** is the main coordinating blockchain, including one ShardChain. It contains:
* protocol parameters
* the current validator set and their stakes
* validator account chains
* metadata about all active WorkChains and ShardChains
* hashes of the latest blocks from all other chains

Gas costs are intentionally high in the MasterChain to ensure stability, prioritize critical operations, and prevent spam.

![](/img/docs/blockchain-fundamentals/masterchain.svg)


Thanks to the hierarchical structure of WorkChains and ShardChains, TON forms a **blockchain of blockchains** — a scalable architecture where each chain operates independently, and all blocks reference their predecessors via cryptographic hashes.

![](/img/docs/blockchain-fundamentals/chain-of-chains.svg)

#### Testnet and Mainnet

#### Mainnet (the main network)

The **Mainnet** is the live production network where:

* all transactions are real
* real tokens are used (e.g., actual Toncoin)

All users and projects operating in production use the Mainnet.

#### Testnet (the test network)

The **Testnet** is a sandbox environment for developers — a copy of the main network but without risk. In Testnet:

* test coins are used, which have no real value
* contracts, transactions, DApps, and errors can be safely tested
* the blockchain can be reset or altered at any time

Testnet is essential for safe development and debugging before launching to the main network.


## Messages

In the TON blockchain, a **message** is the fundamental unit of interaction between accounts (smart contracts). All actions, state changes, and logic execution within accounts are triggered by messages.

## Transaction and message real-life examples

Let’s explore how transactions and messages work in TON through an analogy.
Imagine the TON blockchain as a unique city in the global world — the Internet.
In this city, the rules are strict: residents **never meet in person**, and the **only** way to communicate is via a postal service.
People receive messages asking them to perform a task, complete it privately in their homes, and then send the results back to others.

Each person checks their mailbox and picks up *exactly one incoming message*, then locks themselves inside and doesn’t come out until the task is completed.
While they’re working, new letters may arrive — but they *ignore them completely*.

If they realize mid-task that some necessary information is missing, they *cannot pause to ask for clarification*.
In that case, they must declare the task as failed and, at best, return leftover resources along with scraps of the original instructions.

If the task is successful, the person, as specified in the original message:
* send new messages to other residents, or
* store the resulting items safely in their home.

After finishing, they return to their mailbox and retrieve the **next** incoming message.

Now imagine that for each work session, the person keeps a **detailed journal**.
To keep their work organized and separate, each journal entry is called a **transaction**.
Each transaction contains:
* the full content of the incoming message (the task),
* a note on what was produced and where it was stored,
* and, optionally, information about any messages sent to others.

Messages delivered via the postal system between residents are called **internal messages**.
Messages from the outside world also reach the city. These have a specified recipient, but their sender is unknown — they are known as **external incoming** or **external-in messages**.

While external-in and internal messages fulfil a similar role from the actor’s perspective, each actor may handle them differently. Some may process them normally, while others might completely ignore messages from the outside world — like someone who refuses to open letters from strangers.

#### Message structure: TL-B

Now, let’s look at the data contained in the messages.
As mentioned earlier, both external and internal messages can carry data — but how exactly is this data encoded?

In TON, all data is represented using **cells**.
To serialize data into a cell, TON relies on a well-established standard called **TL-B** (Type Language – Binary).

## Particular message structure

```
message$_ {X:Type} info:CommonMsgInfo
init:(Maybe (Either StateInit ^StateInit))
body:(Either X ^X) = Message X;
```

* `info: CommonMsgInfo` — contains metadata about the message.
* `init: (Maybe (Either StateInit ^StateInit))` — optional field used to initialize a new account or update the existing one.
* `body: (Either X ^X)` —  the main payload of the message; can be embedded directly or stored as a reference.


### Message types

There are three types of messages:

- **external incoming**: sender is outside the blockchain → recipient is a smart contract
- **internal**: sender is a smart contract → recipient is a smart contract
- **external outgoing**: sender is a smart contract → recipient is outside the blockchain (unknown actor)

### External incoming

#### Functional purpose

**External incoming** messages serve as the entry point for the outside world into the TON blockchain.
Any user can send arbitrary data to any smart contract, and the contract decides how to handle it.

Fundamentally, any account can receive an external message.
However, how a specific contract behaves concerning a given external-in message is defined in its code.
The most common type of contract that processes external-in messages is the **wallet contract**.

They usually come from:

- users of wallet applications
- validators
- DApp services

Although external-in messages are rarely used in core smart contract logic, they are essential for wallets.
Almost every user action in TON — such as sending TON or interacting with a DEX — starts with an **external incoming message** from the user’s wallet.
The wallet then sends **internal messages** to other contracts.

#### Sending an external-in message

The term **message** is closely related to a transaction, but it's important to distinguish between them:

- A **message** is a data packet sent between smart contracts containing instructions for some action
- A **transaction** is the result of executing a smart contract in response to an incoming message.
During execution, the smart contract may update its state and send one or more outgoing messages.

An **external-in** message is one whose `CommonMsgInfo` header is described by the structure `ext_in_msg_info$10`.

```
message$_ {X:Type} info:CommonMsgInfo
init:(Maybe (Either StateInit ^StateInit))
body:(Either X ^X) = Message X;
```

**TL-B:**
```
//external incoming message
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt
import_fee:Grams = CommonMsgInfo;
```

Since this message is sent **from outside the blockchain into the blockchain**, the initiator is an external actor.
The tool used may be a wallet contract or a piece of code interacting with blockchain API services.

Thus, to send an external-in message to a smart contract, you need to:

1. Construct a structure that matches the TL-B schema
2. Send this structure to the blockchain using an API service

For example, in **Blueprint**, there is a built-in helper that assembles this structure on the fly for the developer.


```@ton/blueprint 0.36.1

import {Address, beginCell} from "@ton/ton";
import {NetworkProvider} from "@ton/blueprint";

export async function run(provider: NetworkProvider, args: string[]) {
    
    //Mainnet address : 'EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2'
    const address = Address.parse('EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2');
    
    //Switch address for the Testnet :
    //const address = Address.parse('kQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16z768');


    // Get current seqno using blueprint's provider
    const contractProvider = provider.provider(address);
    const result = await contractProvider.get('seqno', []);
    const currentSeqno = result.stack.readNumber();

    // Send external message with current seqno
    return contractProvider.external(
        beginCell().storeUint(currentSeqno, 32).endCell()
    );
}

```

:::info How to use examples with Blueprint

1. Prepare a wallet application (e.g., Tonkeeper) that you’ll use to send the external message
2. Install the Blueprint project locally:
`npm create ton@latest`
3. Add the provided script to your Blueprint project under the `scripts` directory, for example:
`blueprintproject/scripts/yourscript.ts`
4. Run the script with the command:
`npx blueprint run yourscript`

:::


### Internal

#### Functional purpose

An **internal message** is a message sent from one smart contract to another within the TON blockchain.
When a smart contract receives an internal message, it knows:

* how many TON coins are attached to the message
* the sender and recipient contracts
* the blockchain guarantees the integrity of this information, allowing the smart contract to trust and use it safely.

**TL-B:**

A contract initiates an internal message — meaning it is the result of executing a transaction.
In other words, the **sender of an internal message is always a contract**, as the name implies.

The primary way to trigger the sending of an internal message is to send an external message to a contract
that contains instructions to forward an internal message to another contract.

```
//internal message
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
src:MsgAddressInt dest:MsgAddressInt
value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```


| Structure      | Description                                                                                                         |
|----------------|---------------------------------------------------------------------------------------------------------------------|
| int_msg_info$0 | $0 tag means, that in serialization CommonMsgInfo started with 0 bit describes a internal message.                  |
| ihr_disabled   | Hyper cube routing flag.                                                                                            |
| bounce         | Message should be bounced if there are errors during processing. If message's flat bounce = 1, it calls bounceable. |
| bounced        | Flag that describes, that message itself is a result of bounce.                                                     |
| src            | Address of smart contract sender of message.                                                                        |
| dest           | Address of smart contract destination of message.                                                                   |
| value          | Structure which describes currency information including total funds transferred in message.                        |
| ihr_fee        | Fees for hyper routing delivery                                                                                     |
| fwd_fee        | Fees for forwarding messages assigned by validators                                                                 |
| created_lt     | Logic time of sending message assigned by validator. Using for odering actions in smart contract.                   |
| created_at     | Unix time                                                                                                           |


The first thing a developer needs to define is the amount of Toncoin attached to the internal message (`value`)
and the destination address (`dest`) where it will be sent.

In this example, an external message is sent with additional instructions to your wallet contract.
As a result of executing the transaction on the wallet contract, an outgoing internal message will be sent
with the specified `value` of TON and the recipient `address`.


```@ton/blueprint 0.36.1

import {Address} from "@ton/ton";
import {NetworkProvider} from "@ton/blueprint";

export async function run(provider: NetworkProvider, args: string[]) {

    const address = Address.parse('kQBUCuxgGsF6znHM_yNmnV_EwtlmdvmDzqTxiWHJip2ux6Wn');
    const contractProvider = provider.provider(address);

    return contractProvider.internal(
        provider.sender(),{
        value: '0.01'
    });

}

```

### External outgoing

External outgoing messages (also known as **logs**) are a special type of message generated by smart contracts,
which are **not delivered to a specific recipient**.
Instead, they act as logs or signals that can be tracked **outside** the blockchain.

Although such messages are rarely used in the core blockchain logic, they play an important role in tasks like:

* indexing and monitoring blockchain state
* triggering off-chain processes, such as notifying external services or updating a user interface

For example, a decentralized exchange (DEX) smart contract might generate an external outgoing message
after a successful token swap — to notify external services or users about the event.


**TL-B:**
```
//external outgoing message
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

#### Bounce of messages

A **bounce message** is a message that is automatically sent back to the sender if a transaction fails.
For example, if the recipient smart contract does not exist or execution fails with an error.
It not only indicates an error but also allows the sender to handle it — for instance, by refunding tokens or showing an error message to the user.

Most internal messages between smart contracts should be **bounceable**, i.e., with the `bounce` flag set, so that in case of an error:

* the message is returned to the sender
* the remaining funds (minus fees) are refunded

In turn, smart contracts must:

* check the `bounced` flag in incoming messages
* either ignore such messages (terminate with exit code 0)
* or handle the error

:::important
The content of a bounce message **must not be executed** like a regular request — it is used only for error reporting and refunding.
:::

### Custom messages for executing contract operations

We’ve reviewed the native mechanisms for contract communication, including both external and internal messages.
To trigger the execution of various logic within smart contracts, it is necessary to attach a **payload** to the standard message.
In internal messages, this optional payload is placed in the `body`.
There are two approaches to defining the structure of the `body`:

- Build the message based on a TL-B schema provided in the documentation or the contract source
- Build the message by **analyzing the contract code**, essentially inverting the deserialization process

#### Serializing internal messages according to TL-B

Let’s take a look at the `nft-item.fc` contract.
The standard defines a TL-B schema for the message structure required to initiate a transfer of ownership to another user.

Technically, this is a message sent from the current owner’s contract, specifying the **operation code** for transfer and the **address of the new owner**.


```tlb

transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`

```

In the TON SDK, predefined primitives are available for the most essential structures, allowing complex structures to be packed using built-in helpers.

```
import {Address, beginCell, toNano} from "@ton/ton";
/*
`transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`
*/


const messageBody = beginCell()
    .storeUint(0x5fcc3d14, 32) // opcode for NFT transfer
    .storeUint(0, 64) // query id, by default 0
    .storeAddress(destinationAddress) //
    .storeAddress(destinationAddress) // response destination for lasts funds
    .storeBit(0) // if 0, no custom payload
    .storeCoins(toNano('0.01')) // forward amount - if >0, will send additional message to destination as a wallet notification message
    .endCell();
```

A prepared example can be used to test the sending process.
To run the example, you need to specify the wallet address and the NFT contract address.

```@ton/blueprint 0.36.1
import {Address, beginCell, toNano} from "@ton/ton";
import {NetworkProvider} from "@ton/blueprint";


export async function run(provider: NetworkProvider, args: string[]) {

    // PREPARE INTERNAL MESSAGE TRANSFER
    const nftItemAddress = Address.parse('kQBUCuxgGsF6znHM_yNmnV_EwtlmdvmDzqTxiWHJip2ux6Wn');
    const destinationAddress = Address.parse('0QABa48hjKzg09hN_HjxOic7r8T1PleIy1dRd8NvZ3922CW7');

    const address = nftItemAddress;
    const contractProvider = provider.provider(address);
    /*
    `transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
    custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`
     */
    const messageBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // opcode for NFT transfer
        .storeUint(0, 64) // query id
        .storeAddress(destinationAddress)
        .storeAddress(destinationAddress) // response destination
        .storeBit(0) // if 0, no custom payload
        .storeCoins(toNano('0.01')) // forward amount - if >0, will send additional message to destination as a wallet notification message
        .endCell();


    return contractProvider.internal(
        provider.sender(),{
        value: toNano('0.5'),
        body: messageBody
    });

}
```

### Internal message serializer according to contract code
//TODO
  * Receivers in the code  (https://github.com/ton-blockchain/highload-wallet-contract-v3)
  * Build message serializer example in blueprint according to source code 


### Internal messages serializer according disabled code
In case developer hase no documentation with TL-B and contract code, the only way to analyze and find approach to contract reading disassmbled code.
This approach have the worst effectivness but can be helpful for legacy contracts.
Example: [Simplecontract](https://verifier.ton.org/EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2)


## Hashes in TON Blockchain

Hashes play a crucial role in the TON ecosystem, ensuring the identification and verification of data at all levels of the blockchain.
Understanding how hashes work will help you effectively track transactions, verify messages, and integrate your applications with TON.

### What is a hash?

In the context of TON, a **hash** is a unique cryptographic fingerprint of data calculated using the **SHA-256** algorithm.
Each cell, message, or transaction has its unique hash that serves as its digital signature.

### Data representation in TON

All data in TON is stored in **cells**. Conceptually, this is a structure containing **1023 bits** and **4 references** to other cells.
Serialized cell trees are packed according to a unified cell format standard.

In TL-B, this structure is called a **Bag of Cells (BoC)**:


```tlb


serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)
  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }
  size:(## 3) { size <= 4 }
  off_bytes:(## 8) { off_bytes <= 8 }
  cells:(##(size * 8))
  roots:(##(size * 8)) { roots >= 1 }
  absent:(##(size * 8)) { roots + absent <= cells }
  tot_cells_size:(##(off_bytes * 8))
  root_list:(roots * ##(size * 8))
  index:has_idx?(cells * ##(off_bytes * 8))
  cell_data:(tot_cells_size * [ uint8 ])
  crc32c:has_crc32c?uint32
  = BagOfCells;

```

A deep understanding of this structure is not required,
Since TON development tools and SDKs already provide helpers that build this structure for developers.

### Hash types in TON

:::info Important
Hashes in TON are irreversible — it’s impossible to restore the original data from a hash.
However, they are **deterministic** — the same input will always produce the same hash.
:::

#### Message body hash

The **message body hash** is a unique identifier of your message's content.
It is computed from the cell that contains the message data.

The body of the message is the part found in the field:
`body: (Either X ^X)`


```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

```

Let’s examine an example of a message body with the comment "Hello, TON!" and calculate its hash.

```typescript
import { beginCell } from '@ton/core';

// Создаем тело сообщения для увеличения счетчика
const messageBody = beginCell()
        .storeUint(0, 32) // op code
        .storeStringTail("Hello TON!")
        .endCell();

console.log("Message Body Hash:", messageBody.hash().toString("hex"));
```

#### Expected output

```
Message Body Hash: d989794fa90c9817a63a22e00554574f3c4a347dcfd2e2886980a294de15f2af
```

**When to use the message body hash:**
- To verify data integrity
- During debugging and operation logging
- For message deduplication in your application

#### Full message hash

A full message includes not only the body but also headers with metadata (sender, recipient, amount, fees).
Its hash is a unique identifier of the entire message.

For example, in the case of an internal message, this is the `Message X` structure defined by the following TL-B:

```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;


int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

#### Example:

```typescript
import { storeMessage, beginCell, Address, Message } from '@ton/ton';
import { toNano } from '@ton/core';

// Создаем тело сообщения для увеличения счетчика
const messageBody = beginCell()
        .storeUint(0, 32) // op code
        .storeStringTail("Hello TON!")
        .endCell();

// Создайте полный объект сообщений
const message: Message = {
    info: {
        type: 'internal',
        dest: Address.parse('UQAi....'), // вставьте адрес получателя
        value: { coins: toNano('0.1') },
        bounce: true,
        src: Address.parse('UQA1....'), // вставьте адрес отправителя
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
    },
    body: messageBody
};

// Получаем хэш полного сообщения
const messageCell = beginCell()
    .store(storeMessage(message))
    .endCell();

const fullMessageHash = messageCell.hash();
console.log('Full Message Hash:', fullMessageHash.toString('hex'));
```

#### Expected output
```
Full Message Hash: 40b1477f90d702af223f15194724e0c12b51028bc622444959e155e77903b12c
```

**When to use the complete message hash:**
- To track specific messages on the blockchain
- When working with the TON Center API to search for transactions
- To verify that the message has not been modified

#### Transaction hash

A **transaction hash** is a unique identifier of the entire transaction.
It depends on all the data within the transaction, such as incoming and outgoing messages, state changes, and fees.
This data becomes available **only after the transaction is executed**, and the hash can also only be computed once it is recorded on the blockchain.

**Practical example of obtaining a transaction hash:**

```typescript
import { TonClient, beginCell, storeMessage } from '@ton/ton';
import { Address } from '@ton/core';


async function main() {
    const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // тестнет, если проводите операции в мейннете, не забудьте поменять
    apiKey: 'insert your api key' // используя бот, получите свой api key
    });

    const transactions = await client.getTransactions(
    Address.parse('0QD3o...'), // вставьте свой адрес кошелька
    {   archival: true,
        limit: 10 }
    );

    for (const tx of transactions) {
    const txHash = tx.hash();
    console.log('Transaction Hash:', txHash.toString('hex'));

    // Также можем получить хэш входящего сообщения
    if (tx.inMessage) {
        const inMsgCell = beginCell()
        .store(storeMessage(tx.inMessage))
        .endCell();
        const inMsgHash = inMsgCell.hash();
        console.log('Incoming Message Hash:', inMsgHash.toString('hex'));
            }
        }
    }

main().catch(console.error);
```
#### Expected output

The last 10 transactions for the specified address, including the transaction hash,
and if there is an incoming message — also displays the hash of that message:

```
Transaction Hash: 79a6406e5544e95bbe5db8c7e8189daaca240b2d6b4f21cc479c3082dd4c5cce
Incoming Message Hash: 4557aa15e21cf0501f3d82eaa26a23ab61c08a544490154bd12a1814d492db42
Transaction Hash: 1a86894bbe2f5af090d97f761f0367a16b713e93247056003e6d8b6a68a5165e
Incoming Message Hash: dfa0916ceee9dd26c6966d55446b23f88950e118432f870d092cfcde83a3b864
:
:
```

#### Normalized Message Hash

Normalization is a standardization concept that brings different representations into a unified form.
Messages in different interfaces are defined according to TL-B, but collisions sometimes occurred
where the structure was represented differently.

To solve this issue, a standard was introduced within the ecosystem to ensure consistent hash computation.
Normalization is defined in detail in [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467).

**The problem normalization solves:**

Functionally identical messages may be formed in different ways for the `src`, `import_fee`, and `init` fields.
As a result, messages with duplicate content may have different hashes.
This complicates transaction tracking and message deduplication.

**How normalization works:**

The normalized hash is computed by standardizing the following fields of an external-in message:

1. **Source Address (`src`)**: Set to `addr_none$00`
2. **Import Fee (`import_fee`)**: Set to `0`
3. **InitState (`init`)**: Set to an empty value
4. **Body**: Always saved as a reference

**Practical example of calculating a normalized hash:**

```typescript
import { toNano, beginCell, Cell, Address } from "@ton/core";

function normalizeExternalMessage(destAddress: Address, bodyCell: Cell): Cell {
    try {
        const normalizedExtMessage = beginCell()
            .storeUint(0b10, 2) // ext_msg prefix (10 in binary)
            .storeUint(0, 2) // src -> addr_none (НОРМАЛИЗАЦИЯ!)
            .storeAddress(destAddress) // Address.parse(destAddress.toString({ bounceable: false })) если пытаться использовать .address из WalletContractV4
            .storeCoins(0) // import_fee:Grams -> 0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(false) // init:(Maybe (Either StateInit ^StateInit)) -> nothing$0 (НОРМАЛИЗАЦИЯ!)
            .storeBit(true) // body:(Either X ^X) -> right$1 (НОРМАЛИЗАЦИЯ!)
            .storeRef(bodyCell) // Store body as reference (НОРМАЛИЗАЦИЯ!)
            .endCell();

        return normalizedExtMessage;
    } catch (error: any) {
        console.error("❌ Error in normalization:", error.message);
        throw error;
    }
}

// Пример использования
const messageBody = beginCell()
  .storeUint(0, 32) // opcode для простого перевода
  .storeStringTail('Normalized hash example')
  .endCell();

const destinationAddress = Address.parse('EQB...');
const normalizedExternalMessage = normalizeExternalMessage(destinationAddress, messageBody);
const normalizedHash = normalizedExternalMessage.hash().toString("hex");

console.log('Normalized Message Hash:', normalizedHash);
```

#### Expected output

```
Normalized Message Hash: ee53ccd1224c315597bdbafb2e722316d9471490b13dd9e1834903b094eb5964
```


**Practical example of calculating a non-normalized hash:**

Before April 2025, hashes were not normalized,
so if your code looks like this — normalization is required.


```typescript
import { mnemonicToWalletKey } from '@ton/crypto';
import { WalletContractV4, TonClient, toNano, beginCell, Address, internal } from '@ton/ton';

// Создаём клиент для доступа к testnet через TonCenter
const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'your api key' // публичный API-ключ
});

// Создаём тело сообщения — обычная строка с опкодом
const messageBody = beginCell()
    .storeUint(0, 32) // op code — произвольный, например, 0
    .storeStringTail("Hello TON!") // строка в теле
    .endCell();

// Оборачиваем тело во внутреннее сообщение (internal message)
const internalMessage = internal({
    to: Address.parse('0QD3....'), // получатель
    value: toNano('0.1'), // 0.1 TON
    body: messageBody
});

async function main() {
    // Получаем ключи кошелька из мнемоники
    const mnemonic = "your seed phrase";
    const keyPair = await mnemonicToWalletKey(mnemonic.split(' '));

    // Создаём wallet-смарт-контракт по публичному ключу
    const wallet = WalletContractV4.create({
        publicKey: keyPair.publicKey,
        workchain: 0
    });

    const contract = client.open(wallet);
    const seqno = await contract.getSeqno();

    // Создаём внешнее сообщение (external message)
    const externalMessage = await wallet.createTransfer({
        seqno,
        secretKey: keyPair.secretKey,
        messages: [internalMessage]
    });

    // Выводим хэш внешнего сообщения
    console.log("Non-normalized External Message Hash:", externalMessage.hash().toString("hex"));
}

main();

```

#### Expected output
```
Non-normalized External Message Hash: 8dd5c85be08e33341553cb1e5a2f08323e9ae9314d5ceac2e3a6c79f11151b5e
```

This algorithm may differ from the normalized one in any way.
If the lack of normalization has become an issue for a previously developed project,
the correct solution is to **migrate to normalized hashes throughout the entire project**.

### Sending a message and verifying delivery

One of the most important scenarios is sending a message
and making sure the blockchain has processed it.

**Step-by-step process:**

```typescript
import { internal, TonClient, Address, beginCell, WalletContractV4, SendMode } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';

async function sendAndVerifyMessage() {
  const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'your api key'
  });

  // Мнемоника и ключи
  const mnemonic = "your mnemonic".split(" ");
  const keyPair = await mnemonicToPrivateKey(mnemonic);

  const wallet = client.open(WalletContractV4.create({
    publicKey: keyPair.publicKey,
    workchain: 0
  }));

  // Тело сообщения с комментарием
  const messageBody = beginCell()
    .storeUint(0, 32)
    .storeStringTail('Hello TON!')
    .endCell();

  // Получаем seqno
  const seqno = await wallet.getSeqno();

  // Отправляем транзакцию
  await wallet.sendTransfer({
    secretKey: keyPair.secretKey,
    seqno,
    messages: [internal({
      to: Address.parse('0QD3o...'), // ваш адрес
      value: '0.05',
      body: messageBody
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
  });

  // Ждём 10 секунд
  await new Promise(resolve => setTimeout(resolve, 10000));

  // Проверяем, отправилось ли сообщение
  const newSeqno = await wallet.getSeqno();

  if (newSeqno > seqno) {
    console.log('Транзакция успешно отправлена!');

    const transactions = await client.getTransactions(wallet.address, {
      archival: true,
      limit: 5
    });

    const ourTx = transactions.find(tx =>
      tx.inMessage?.info.type === 'external-in' &&
      tx.description.type === 'generic'
    );

    if (ourTx) {
      console.log('Transaction Hash:', ourTx.hash().toString('hex'));
    }
  } else {
    console.log('Транзакция не была обработана');
  }
}

sendAndVerifyMessage().catch(console.error);
```

#### Expected output

```
Транзакция успешно отправлена!
Transaction Hash: 285f8df8f968f63680f8efaff004369f4e7aeb8619293da035cb8ca3899232f3
```

### Searching for a Transaction by BOC

When a user confirms the sending of an external message via TON Connect,
you receive a BOC (Bag of Cells).
You can use this BOC to find the corresponding transaction on the blockchain.

**Practical example:**

<details>

  ```typescript

  import { Cell, Address, beginCell, storeMessage, TonClient } from '@ton/ton';

  async function findTransactionByBOC(
  externalBOC: string,
  walletAddress: string
  ): Promise<string | null> {
  const client = new TonClient({
  endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
  apiKey: 'your api key'
});

  try {
  // Получаем хэш внешнего BOC
  const extHash = Cell.fromBase64(externalBOC).hash().toString('hex');
  console.log('Ищем транзакцию по BOC hash:', extHash);

  // Получаем последние транзакции кошелька
  const transactions = await client.getTransactions(
  Address.parse(walletAddress),
{ limit: 10 }
  );

  for (const tx of transactions) {
  const inMsg = tx.inMessage;
  if (inMsg?.info.type === 'external-in') {
  // Создаем хэш входящего сообщения
  const inHash = beginCell()
  .store(storeMessage(inMsg))
  .endCell()
  .hash()
  .toString('hex');

  if (extHash === inHash) {
  const txHash = tx.hash().toString('hex');
  console.log('Найдена транзакция:', txHash);
  return txHash;
}
}
}

  console.log('Транзакция не найдена');
  return null;
} catch (error) {
  console.error('Ошибка поиска транзакции:', error);
  return null;
}
}


  async function main() {
  // Пример BOC для теста (замените на реальный)
  const testBOC = 'где найти BOC???';
  const testWalletAddress = 'your address';

  await findTransactionByBOC(testBOC, testWalletAddress);
}

  // Запускаем тест
  if (require.main === module) {
  main().catch(console.error);
}

  ```

  **Expected output**
  ```
  Ищем транзакцию по BOC hash: 399ae70c7c4d4880d373727875c38ad243dc9b11775b14a19955f0040a684306
  Транзакция не найдена
  ```

</details>

### Practical tips

#### Checking transaction status via API

```typescript
// Проверяем статус транзакции по её хэшу
async function checkTransactionStatus(txHash: string, walletAddress: string) {
  try {
    const response = await fetch(
      `https://testnet.toncenter.com/api/v2/getTransactions?` +
      `address=${walletAddress}&hash=${txHash}`
    );
    const data = await response.json();

    if (data.result.length > 0) {
      console.log('Транзакция найдена в блокчейне');
      const viewerUrl = `https://testnet.tonviewer.com/transaction/${trxHash}`;
      console.log('Ссылка на транзакцию:', viewerUrl);
      return data.result[0];
    } else {
      console.log('Транзакция не найдена');
      return null;
    }
  } catch (error) {
    console.error('Ошибка при проверке транзакции:', error);
    return null;
  }
}

const walletAddress = 'your address';
const trxHash = 'your trx hash';

checkTransactionStatus(trxHash, walletAddress);
```

#### Expected output

```
Транзакция найдена в блокчейне
Ссылка на транзакцию: https://testnet.tonviewer.com/transaction/df51860233d75...
```

#### StateInit Hash for Address Verification

In [TON Connect](v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#backend-example),
it's often necessary to verify the match between a wallet address and its `StateInit`.
The hash of `StateInit` must match the hash part of the address.

**Practical example of address verification:**

1. Retrieve `StateInit`:


```typescript

import { WalletContractV4, beginCell } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';

async function getStateInit() {
    try {
        // Вам нужно заменить эти слова на ваши 24 слова (мнемоник)
        const mnemonic = "your mnemonic".split(" ");
        const keyPair = await mnemonicToPrivateKey(mnemonic);

        // Создаем кошелек v4
        const wallet = WalletContractV4.create({
            publicKey: keyPair.publicKey,
            workchain: 0
        });

        // Получаем stateInit
        const stateInitCell = beginCell()
            .storeRef(wallet.init.code)
            .storeRef(wallet.init.data)
            .endCell();

        const stateInitBase64 = stateInitCell.toBoc().toString('base64');

        console.log('StateInit (base64):', stateInitBase64);
        console.log('Wallet address:', wallet.address.toString({ bounceable: true }));
        console.log('Public key (hex):', Buffer.from(keyPair.publicKey).toString('hex'));

        return stateInitBase64;
    } catch (error) {
        console.error('Error:', error);
    }
}

getStateInit().catch(console.error);
```
#### Expected output

```
StateInit (base64): te6cckECFgEAAwMAAgABFQEU/wD0pBP0vPL....
Wallet address: EQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxW9m
Public key (hex): f102a5c140272019550b05e6a50b2072aa737dd3c5948622ddf1ca249b6e0f00
```

```typescript
import { Address, Cell, contractAddress } from '@ton/ton';

// Ваши данные:
const wantedAddress = Address.parse('your address');
const stateInitBase64 = 'your state init'; // <-- сюда вставьте свой StateInit (base64)

const cell = Cell.fromBase64(stateInitBase64);
// Обычно code = cell.refs[0], data = cell.refs[1]
const stateInit = {
  code: cell.refs[0],
  data: cell.refs[1]
};

// Восстанавливаем адрес из workchain и StateInit
const calculatedAddress = contractAddress(wantedAddress.workChain, stateInit);

console.log('Ожидаемый адрес:   ', wantedAddress.toString({ bounceable: false }));
console.log('Вычисленный адрес:', calculatedAddress.toString({ bounceable: false }));

if (calculatedAddress.equals(wantedAddress)) {
  console.log('✅ StateInit соответствует адресу!');
} else {
  console.log('❌ StateInit НЕ соответствует адресу!');
}
```

#### Expected output

```
Ожидаемый адрес:    UQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxTKj
Вычисленный адрес: UQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxTKj
✅ StateInit соответствует адресу!
```

#### Real time monitoring

<details>

  ```typescript
  // Пример функции для мониторинга входящих транзакций
  async function monitorIncomingTransactions(walletAddress: Address, client: TonClient) {
  let lastLt = '0';

  setInterval(async () => {
  try {
  const transactions = await client.getTransactions(walletAddress, {
  limit: 10,
  lt: lastLt
});

  for (const tx of transactions) {
  if (tx.lt > lastLt) {
  const txHash = tx.hash();
  console.log('Новая транзакция:', txHash.toString('hex'));

  // Обрабатываем входящие сообщения
  if (tx.inMessage) {
  const msgCell = beginCell()
  .store(storeMessage(tx.inMessage))
  .endCell();
  const msgHash = msgCell.hash();
  console.log('Хэш сообщения:', msgHash.toString('hex'));
}

  lastLt = tx.lt;
}
}
} catch (error) {
  console.error('Ошибка мониторинга:', error);
}
}, 5000); // проверяем каждые 5 секунд
}
  ```
</details>

### Best Practices

1. **Always store hashes**: Save hashes of important transactions and messages for later tracking.

2. **Use the correct hash type**: Use the transaction hash for tracking and the message hash for data verification.

3. **Consider confirmation time**: In TON, transactions typically finalise within 3–6 seconds, but this may take longer during periods of high network load.

4. **Implement retry logic**: If a transaction doesn’t appear on the blockchain within a minute, consider resending the message.

## Sending a Message

There are two important and practical cases for sending a message to the blockchain:

- You send a message from the backend, where you own the wallet and can sign and send it directly.
- You use **TON Connect** on the frontend, where you prepare the message and let the user sign and send it themselves.

### Sending from the Backend

If you have a wallet with a seed phrase, the message is sent like this:
Code [source](/v3/guidelines/dapps/cookbook/#how-to-transfer-ton-and-send-a-text-message-to-another-wallet)

### Sending from the Frontend (TON Connect)

In this case, you prompt the user to sign and send the message.

```
const myTransaction = {
validUntil: Math.floor(Date.now() / 1000) + 60, // 60 sec
messages: [
{
address: destination, // Address of smart contract to send internal message to
amount: amount, // Amount in nanotons to attach to the message
payload: Base64.encode(messageBody.toBoc())
}
]
}

tonConnectUI.sendTransaction(myTransaction)

```
## Get методы
Get methods
Build get method wrapper
Get balance
Get jetton wallet address
Get collection data

## Blockchain HTTP API
### TON main services

We will review services that build native infrastructure; other API providers most likely rely on one of these standard solutions.
We recommend evaluating a provider's quality independently based on historical performance and suitability for your specific use case.

#### TON Center
TON Center services are developed by the TON Core team using the Go stack. It includes two distinct services:
- **TON Center API V3**: Provides blockchain indexing solutions.
- **TON Center API V2**: Offers fast reading from and sending to the blockchain.

#### TON API
A solution focused on business needs, often providing ready-to-use implementations for typical tasks in TON.

#### TONX API
An API service that originated from TON Center but continued closed development, expanding interfaces for client-specific needs.

#### Tonhub API
An HTTP API service with a unique structure different from TON API and TON Center. This interface better serves some use cases.

---

### A Transaction is a Part of a Block

HTTP services read data from LiteServer nodes and deserialize it according to TL-B standards.
Data that undergoes minimal post-processing is often referred to as **RAW data**.
Such raw data is ideal for in-depth analytics where security and precision outweigh simplicity.

On the other hand, solutions that do not involve large asset movements — but require event analytics — are more efficiently implemented using **high-level interfaces**, i.e., APIs that apply post-processing before returning the data.

Transactions in TON are packed into blocks. Finalized BaseChain blocks are committed into MasterChain blocks.
Therefore, to extract transaction data, services read from both the MasterChain and the corresponding BaseChain blocks.

Additionally, because TON implements **sharding**, each MasterChain block points to shard blocks that must also be parsed.
Each shard block contains all transactions associated with that MasterChain block.

All WorkChain blocks share the same structure. For transaction analysis, the relevant section is `block_extra`.


```tlb
block#11ef55aa global_id:int32
info:^BlockInfo value_flow:^ValueFlow
state_update:^(MERKLE_UPDATE ShardState)
extra:^BlockExtra = Block;
```
The `block_extra` section of a block, in turn, contains the `account_blocks` structure.
It is within `account_blocks` that you'll find the transactions processed by all accounts within the corresponding shard for that block.

```tlb
block_extra in_msg_descr:^InMsgDescr
out_msg_descr:^OutMsgDescr
account_blocks:^ShardAccountBlocks
rand_seed:bits256
created_by:bits256
custom:(Maybe ^McBlockExtra) = BlockExtra;
```

Thus, in the process of reading the blockchain, services iteratively process from the last read block to the next finalized one. The resulting transactions are **RAW data** that can be provided to downstream services for further processing. Additionally, specialized services analyze and enhance this data to balance between implementation complexity and a trustless approach.

#### Account status

Account status describes the condition of the account from the perspective of a transaction but is **not** stored within the account itself. There are four possible `AccountStatus` values, each encoded as two bits in TL-B:

| Status      | TL-B Code | Description                                                                 |
|-------------|------------|------------------------------------------------------------------------------|
| `nonexist`  | `11`       | Account doesn't exist on the blockchain — no state and no balance.           |
| `uninit`    | `00`       | Account exists but contains no code or data. It may have a balance.          |
| `frozen`    | `01`       | Account has been deleted, but its state hash is retained. It cannot be used. |
| `active`    | `10`       | Account has a `StateInit` with code and data — an active smart contract.     |

The presence of `code` in `StateInit` makes the account executable and thus defines it as a smart contract.

:::important
Account status is used only within transactions (`orig_status` and `end_status`) and is **not** stored in the account itself. The actual account state is stored in the `AccountState` structure.
:::

### Approaches to retrieving transactions from Blockchain API

#### Key concepts:

- **Transaction**: A state update of an account triggered by an incoming message and optionally producing one or more outgoing messages. Analyzing the transaction body is fundamental to most services.
- **Trace**: A deterministic graph of all transactions triggered by a single external message. Useful for debugging or understanding business logic chains. Exchanges use it to verify asset movements.
- **Action**: A high-level abstraction representing a business operation. For example, a Jetton transfer between two users. It is used for visualization — not for transferring funds.

---

#### High-Level data analysis

**How to fetch a list of transactions or a single transaction via API:**

Use high-level interfaces like `GET /actions`, `GET /traces`, `GET /jetton/transfers`, `GET /nft`, etc.
This approach is suitable if you **do not move funds** or require deep validation.

For more advanced use cases (e.g., tracing all related transactions via `Traces`), these APIs help simplify complex logic analysis.

---

#### Searching for a transaction by message body

Use `GetTransaction by message (external/internal)` — only available via [API v3](https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_message).
This is ideal when monitoring a small number of accounts (≤ 10), like in wallet-v4 or wallet-v5 interactions.

:::note
Note that there can be a delay of up to 10 seconds; therefore, for real-time needs, also monitor the `pending` pool.
:::

---

#### Searching transactions by account address

Available via [API v2](https://toncenter.com/api/v2/#/accounts/get_transactions_getTransactions_get).
This method is broadly supported (even in LiteClient) and is practical for tracking up to ~100 accounts.

---

#### Scanning the blockchain for all transactions

This method is used when tracking 1,000+ accounts:

- **API v2**:
1. Fetch shards for a masterchain block.
2. Compute shard diffs.
3. Use `getBlockTransactionsExt` to fetch all transactions per shard.

See: [TON Center Cookbook](https://docs.toncenter.com/docs/ton-center-cookbook#how-to-scan-blockchain)

- **API v3**:
Instead of following v2 logic, use:
[GET /transactions/by-masterchain-block](https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block)

You must decide between a **simple high-trust implementation** using a major provider or a **complex trustless setup** that verifies blocks and transactions independently.

---

#### Transaction response from API

Each transaction in API responses (`Transaction[]`) mirrors its TL-B-defined structure but often includes additional computed fields for convenience.

One of the **most important computed fields** is the **transaction hash**, which is not part of the blockchain but generated by the API provider.

```json
"hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM="
```

In the blockchain, a regular transaction is a structure described by a complete body and a unique header.

```tlb
transaction$0111 account_addr:bits256 lt:uint64
    prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
    outmsg_cnt:uint15
    orig_status:AccountStatus end_status:AccountStatus
    ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
    total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
    description:^TransactionDescr = Transaction;
```

The header TransactionDescr defines the nature of the transaction in the blockchain. All user transactions for service operations are of the regular type — Ordinary.


```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

The API service deserializes the entire structure with precision down to string and numeric data types. As a result, the transaction body returned in JSON format:

```curl
curl -X 'GET' \
  'https://toncenter.com/api/v3/transactions?limit=10&offset=0&sort=desc' \
  -H 'accept: application/json'
```

Returns a very large structure (example for API/v3):

Briefly content of Transaction body consists of:
* Header data - transaction metadata lt, now(unix time) 
* Incoming message data - message, that initiated transaction
* Compute phase data - results of command executions
* Action phase data  - results of actions done after computed
* Block ref - data of the blockchain block belonging.
* Account state before
* Account state after

```json
 {
  "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF",
  "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
  "lt": "15371766000003",
  "now": 1696238450,
  "mc_block_seqno": 13353447,
  "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=",
  "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=",
  "prev_trans_lt": "15371704000004",
  "orig_status": "active",
  "end_status": "active",
  "total_fees": "12446659",
  "description": {
  ...
  },
  "compute_ph": {
   ....
  },
  "action": {
    ...
  },
  "block_ref": {
    ...
  },
  "in_msg": {
  ...
  },
  "out_msgs": [
   ...
  ],

  "account_state_before": {
    ...
  },

  "account_state_after": {
  ...
  }
}

```

<details>
  ```json
  {
    "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account of transcation
    "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
    "lt": "15371766000003", # logical time, may have same values for txs on different accounts but every transaction on a given account will have unique lt
    "now": 1696238450, # unix timestamp
    "mc_block_seqno": 13353447, # seqno of masterchain block
    "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=", # tx_hash of the root transaction of the trace
    "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=", # hash of previous transaction on this account
    "prev_trans_lt": "15371704000004", # lt of prev. transaction
    "orig_status": "active", # account status before transaction
    "end_status": "active", # ... after transaction
    "total_fees": "12446659", # ... sum of fees from description
    "description": {
    "type": "ord",
    "aborted": false,
    "destroyed": false,
    "credit_first": false,
    "storage_ph": {
    "storage_fees_collected": "48",
    "status_change": "unchanged"
  },
    "compute_ph": {
    "skipped": false,
    "success": true,
    "msg_state_used": false,
    "account_activated": false,
    "gas_fees": "8823000",
    "gas_used": "8823",
    "gas_limit": "400000",
    "mode": 0,
    "exit_code": 0,
    "vm_steps": 178,
    "vm_init_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    "vm_final_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  },
    "action": {
    "success": true,
    "valid": true,
    "no_funds": false,
    "status_change": "unchanged",
    "total_fwd_fees": "10871000",
    "total_action_fees": "3623611",
    "result_code": 0,
    "tot_actions": 1,
    "spec_actions": 0,
    "skipped_actions": 0,
    "msgs_created": 1,
    "action_list_hash": "9XTNK6e1Fmmhd3cdzI0XcNDYRAoP5f5L4bWPUD3KNIE=",
    "tot_msg_size": {
    "cells": "23",
    "bits": "8377"
  }
  }
  },
    # reference for the block of the transaction
    "block_ref": {
    "workchain": 0,
    "shard": "8000000000000000",
    "seqno": 14627985
  },
    # in message
    "in_msg": {
    "hash": "O9XCuICyXBWOs4hHMOYA0k6o4GPBsWbAkjFi2qbttQE=", # hash of whole message
    "source": "0:F0C9C78F021AC65839B4006321A68BBB32DE5025F84C853CB9D75EB4894D0848", # account who has sended this message
    "destination": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account who received this message (for in_msg should be same as account of transaction)
    "value": "400000000", # attached TONS
    "fwd_fee": "1494679", # fee for forwarding the message using Hypercube Routing
    "ihr_fee": "0", # fee for forwarding the message throught Instant Hypercube Routing (now IHR is not implemented so this should be added to value)
    "created_lt": "15371766000002", # logical time of creation (usually slightly differs from transaction lt, where this message appears as an out_msg)
    "created_at": "1696238450", # unix timestamp
    "opcode": "0x0f8a7ea5", # opcode
    "ihr_disabled": true,
    "bounce": true, # if bounce should be perfomed on failure
    "bounced": false, # if bounce has happened
    "import_fee": null,
    "message_content": { # message body
    "hash": "tWjTyEL/sabOLNt97uyCj5na740lW54GUcVa0UrSDao=", # hash of the message body
    # message body in base64 format
    "body": "te6cckEBAgEAiAABbQ+KfqUAAAAAdJizmkC/A/doAc9ztfOy5YIoBWjnofpWHchoFtAb/s4FvzXctxUu0Cf0ED8uUQMBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQIjm5Xw==",
    "decoded": null # text comment if it could be decoded
  },
    "init_state": null
  },
    "out_msgs": [
  {
    "hash": "FuV4JPR/uZZOCzZxWQ473bASToqChvKDLmnf5BiCspI=",
    "source": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # should coinside with transaction account for out_msg
    "destination": "0:794760D36E657A27CDB8D3D65F243D6B468CAD2C34AF413E7709390E4DBE9907",
    "value": "380306000",
    "fwd_fee": "7247389",
    "ihr_fee": "0",
    "created_lt": "15371766000004",
    "created_at": "1696238450",
    "opcode": "0x178d4519",
    "ihr_disabled": true,
    "bounce": true,
    "bounced": false,
    "import_fee": null,
    "message_content": {
    "hash": "o+VOluS6wdyl44k2AIFTcRBvdxZD/98275dunIWcVIA=",
    "body": "te6cckEBAgEAiAABbReNRRkAAAAAdJizmkC/A/doAeGTjx4ENYywc2gAxkNNF3ZlvKBL8JkKeXOuvWkSmhCQIH5cogYBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQPzgXtA==",
    "decoded": null
  },
    # init state in same format as message body
    # needed to deploy a new contract
    "init_state": {
    "hash": "eUdg025leifNuNPWXyQ9a0aMrSw0r0E+dwk5Dk2+mQc=",
    "body": "te6cckECFAEAA4AAAgE0AgEBhwgBz3O187LlgigFaOeh+lYdyGgW0Bv+zgW/Ndy3FS7QJ/UAN1wXvOOOdJfwh7sHnzxnFjjhTeJ04Bmd10caY4RPyrggAgEU/wD0pBP0vPLICwMCAWIEBQICywYHABug9gXaiaH0AfSB9IGoYQIBIAgJAIPSAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVICAUgKCwIBWAwNAMNCDHAJJfBOAB0NMDAXGwlRNfA/AQ4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwDeCCEBeNRRlSILqWMUREA/AO4DWCEFlfB7y6k1nwD+BfBIQX8vCAART6RDBwuvLhTYAfFQPTP/oA+kAh8ALtRND6APpA+kDUMFE2oVIqxwXy4sEowv/y4sJUNEJwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAySD5AHB0yMsCygfL/8nQBPpA9AQx+gAg10nCAPLixHeAGMjLBVAIzxZw+gIXy2sTzIDgIBIA8QAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQD9ztRND6APpA+kDUMAjTP/oAUVGgBfpA+kBTW8cFVHNtcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMn5AHB0yMsCygfL/8nQUA3HBRyx8uLDCvoAUaihggiYloCCCJiWgBK2CKGCCOThwKAYoSfjDyXXCwHDACOAREhMA2ztRND6APpA+kDUMAfTP/oA+kAwUVGhUknHBfLiwSfC//LiwoII5OHAqgAWoBa88uLDghB73ZfeyMsfFcs/UAP6AiLPFgHPFslxgBjIywUkzxZw+gLLaszJgED7AEATyFAE+gJYzxYBzxbMye1UgAHBSeaAYoYIQc2LQnMjLH1Iwyz9Y+gJQB88WUAfPFslxgBDIywUkzxZQBvoCFctqFMzJcfsAECQQIwAOEEkQODdfBAB2wgCwjiGCENUydttwgBDIywVQCM8WUAT6AhbLahLLHxLLP8ly+wCTNWwh4gPIUAT6AljPFgHPFszJ7VTOKoYI",
    "decoded": null
  }
  }
    ],
    # account state before the transaction
    "account_state_before": {
    "hash": "ICpM+dm0PYhxtwS/EnIwMAvOQbtDhVWMnPtMAlw5Dog=", # hash of whole account state
    "balance": "37821399", # balance
    "account_status": "active", # status of account (active, nonexist = deleted, frozen, uninitialized)
    "frozen_hash": null, # hash of state when it became frozen
    "data_hash": "XeSmBiLWvwn00CWu5oq/q9Q6d4luPKxnOWC4NgEeugU=", # hash of data
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc=" # hash of code
  },
    # account state after the transaction
    "account_state_after": {
    "hash": "7vvsHBjy5KoM/rIs6U8nHZt0pYOW5I3oTbBirxVK+Go=",
    "balance": "37821351",
    "account_status": "active",
    "frozen_hash": null,
    "data_hash": "aD0LD2LpPQYYR81n5b/EBHCPYmhBo4soNdvPoTL+xIk=",
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc="
  }
  }
  ```
</details>

Depending on the task, the fields of interest may vary. Below are the most relevant ones:

- Native – present in the blockchain. The description refers to the field name defined in TL-B `block.tlb` schemas.
- Postprocessing – calculated additionally by the API provider.
- Native object extended inside – this object exists on-chain, but the data is extended on the API side. See a separate table for details.

| Field              | Origin                     | Description                                                                                                                       | Example                                                        |
|--------------------|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------|
| `trace_id`         | Postprocessing             | `tx_hash` of the root transaction of the trace                                                                                   | `13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=`                |
| `prev_trans_hash`  | Native                     | `tx_hash` of the previous transaction                                                                                             | `6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=`                |
| `account`          | Native                     | Account address where the transaction occurred; returned in RAW format                                                           | `0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF` |
| `hash`             | Postprocessing             | Hash of the current transaction                                                                                                   | `/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=`                |
| `lt`               | Native                     | Logical time of the transaction; unique per account. TL-B field name: `lt`                                                       | `15371766000003`                                              |
| `now`              | Native                     | UNIX timestamp of the transaction. TL-B field name: `now`                                                                         | `1696238450`                                                  |
| `mc_block_seqno`   | Postprocessing             | Masterchain block sequence number that includes this transaction. Not stored on-chain, added by HTTP service                     | `13353447`                                                    |
| `trace_id`         | Postprocessing             | Hash of the root transaction in the trace chain. `trace` is an entity formed by TON Center API v3                                | `13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=`                |
| `prev_trans_hash`  | Native                     | Hash of the previous transaction for this account. TL-B field: `prev_trans_hash`                                                 | `6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=`                |
| `prev_trans_lt`    | Native                     | Logical time of the previous transaction for this account. TL-B field: `prev_trans_lt`                                           | `15371704000004`                                              |
| `orig_status`      | Native                     | Account status before the transaction. TL-B field: `orig_status`                                                                 | `active`                                                      |
| `end_status`       | Native                     | Account status after the transaction. TL-B field: `end_status`                                                                   | `active`                                                      |
| `total_fees`       | Native                     | Total amount of fees associated with the transaction. TL-B field: `total_fees`                                                   | `12446659`                                                    |
| `in_msg`           | Native object extended inside | Input message body object                                                                                                       | `"in_msg": {...}`                                             |


TODO определить набор полей которые здесь полезно рассмотреть.


## Transaction

Any change to an account’s state in the TON blockchain is recorded through transactions. Unlike messages, transactions cannot "move", "be sent", or "be received". These two terms are often confused, but it’s important to understand that a transaction is a record that captures all changes that occurred with a specific account.

### TL-B Structure of the Transaction Body

Before we dive into how transactions work in TON, let’s first examine their structure using TL-B. To begin with, note that there are several types of transactions, but in this tutorial, we’ll focus only on ordinary transactions. These are the ones relevant for handling payments and developing any product.

```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

According to TL-B, a transaction consists of the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `credit_first` | `Bool` | Indicates whether the credit phase should come first. This depends on whether [bounce is enabled](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.cpp#L3530). This will be discussed in more detail in one of the next sections. |
| `storage_ph` | `Maybe TrStoragePhase` | The phase responsible for handling storage-related fees for the account. |
| `credit_ph` | `Maybe TrCreditPhase` | The phase responsible for processing incoming funds that were included with the inbound message, if it is internal ([#1](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2926), [#2](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2935)). |
| `compute_ph` | `TrComputePhase` | The phase responsible for executing the smart contract code (stored in the account’s `code` cell). |
| `action` | `Maybe ^TrActionPhase` | The phase responsible for handling actions generated during the execution of the smart contract code. |
| `aborted` | `Bool` | Indicates whether the transaction was aborted during any of the phases. If this field is `true`, the transaction was not completed, and all changes from the `compute_ph` and `action` phases were not applied. |
| `bounce` | `Maybe TrBouncePhase` | The phase responsible for handling errors that occurred during the `compute_ph` or `action` phases. |
| `destroyed` | `Bool` | Indicates whether the account was destroyed during the execution of the transaction. |

:::info
Other types of transactions, such as [trans_storage](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L352-L353), [trans_tick_tock](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L355-L357), [trans_split_prepare](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L362-L366), and others are used for events that are invisible to the end user. For example, shard splitting and merging, tick-tock transactions, and so on.

Since they are not relevant to tasks related to DApp development, we will not cover them in this tutorial.
:::

### Credit phase

This phase is pretty small and straightforward. If we look at the blockchain source code, we’ll see that the main logic of this phase is to top up the contract’s balance with the remaining funds from the incoming message:

```cpp
  credit_phase->credit = msg_balance_remaining;
  if (!msg_balance_remaining.is_valid()) {
    LOG(ERROR) << "cannot compute the amount to be credited in the credit phase of transaction";
    return false;
  }
  // NB: msg_balance_remaining may be deducted from balance later during bounce phase
  balance += msg_balance_remaining;
  if (!balance.is_valid()) {
    LOG(ERROR) << "cannot credit currency collection to account";
    return false;
  }
```

This phase is serialized in TL-B as follows:

```tlb
tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;
```

Here we see that the phase consists of two fields:

| Field | Type | Description |
| --- | --- | --- |
| `due_fees_collected` | `Maybe Grams` | The amount of storage fees that were collected. This happens if the account had no balance and a debt had accumulated. |
| `credit` | `CurrencyCollection` | The amount that was credited to the account during message receipt. |


### Storage phase

This phase handles the processing of storage-related fees for the account. Let's start by looking at the TL-B scheme:

```tlb
tr_phase_storage$_ storage_fees_collected:Grams
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;
```

Here we see that the phase consists of the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `storage_fees_collected` | `Grams` | The amount of storage fees that were collected from the account. |
| `storage_fees_due` | `Maybe Grams` | The amount of storage fees that were charged but not collected. This occurs when the account has no balance and a debt has accumulated. |
| `status_change` | `AccStatusChange` | The change in account status after the transaction was executed. |

`storage_fees_due` has type `Maybe` because if the contract has a balance, this value is not present. It's only needed to represent debt. `AccStatusChange`, in turn, indicates whether the account status changed after this phase. For example, if the debt exceeds 0.1 TON, the account state will [freeze](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L949C11-L953C12), and after 1 TON — it will be [deleted](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L936C11-L946C12).

### Compute phase

One of the most complex phases of a transaction is the compute phase. This is the phase where the smart contract code stored in the account is executed. This time, the TL-B contains multiple schemas:

```tlb
tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;
```

To start with, note that the compute phase can be skipped, and the reason for skipping may be one of the following:

| Skip Reason | Description |
| --- | --- |
| `cskip_no_state` | The smart contract has no state (and thus no code), so it cannot be executed. |
| `cskip_bad_state` | This error is thrown in two cases: [an invalid value for the `fixed_prefix_length` field](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1721), or a StateInit passed in the message [does not match the account address](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1726). |
| `cskip_no_gas` | The incoming message did not include enough TON to execute the smart contract code. |
| `cskip_suspended` | The account was frozen, so code execution is not allowed. This was used to freeze early miner accounts as part of TON tokenomics stabilization. |

:::tip
The `fixed_prefix_length` field allows setting fixed leading bits of an account address so that it is located in a specific shard. This is outside the scope of this tutorial, but you can read more [here](https://github.com/ton-blockchain/ton/blob/master/doc/GlobalVersions.md#anycast-addresses-and-address-rewrite).
:::

Once we understand the reasons for skipping the compute phase, we can examine what happens after the smart contract code has been executed:

| Field | Type | Description |
| --- | --- | --- |
| `success` | `Bool` | Indicates whether the compute phase completed successfully. If this is `false`, then all changes made during this phase were discarded. |
| `msg_state_used`, `account_activated`, `mode`, `vm_init_state_hash`, `vm_final_state_hash` | - | These fields are not used in the current blockchain version and are recorded as zero values. |
| `gas_fees` | `Grams` | The amount of fees paid for executing the smart contract code. |
| `gas_used`, `gas_limit` | `VarUInteger` | The amount of gas used and the gas limit set for smart contract execution. |
| `gas_credit` | `Maybe (VarUInteger 3)` | Used in external messages. Since they cannot carry TON, a small amount of gas is allocated so that the smart contract code can run and decide whether it's ready to continue execution using its own balance. |
| `exit_code` | `int32` | The virtual machine exit code. If the code is 0 or 1 (alternative success), the smart contract code executed successfully. If it’s non-zero, it means the code failed (except when `commit` is used). <br></br> For convenience, people often refer to this as the “smart contract exit code,” though that’s not entirely accurate. |
| `exit_arg` | `Maybe int32` | An argument thrown by the virtual machine in case of an error. Useful for debugging smart contract code. |
| `vm_steps` | `uint32` | Number of steps executed by the virtual machine. |

:::tip
The `commit` instruction is used to finalize changes made up to that point and apply them even if an error occurs later in the phase. It can only be reverted if the Action Phase fails.
:::

### Action phase

After the smart contract code has executed, the action phase begins. If any actions were generated during code execution, they are processed during this phase. There are four types of actions:


```tlb
action_send_msg#0ec3c86d mode:(## 8)
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;
```

| Type | Description |
| --- | --- |
| `action_send_msg` | Sends a message. |
| `action_set_code` | Sets new smart contract code. |
| `action_reserve_currency` | Reserves funds on the account. Very useful for gas management. |
| `action_change_library` | Changes the library used by the smart contract. |

These actions are executed in the order in which they were created during code execution. A maximum of [255 actions](https://github.com/ton-blockchain/ton/blob/72056a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.h#L165) can be created.

Now let’s take a look at the TL-B scheme that describes the action phase:

```tlb
tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;
```

Here we see that the phase consists of the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `success` | `Bool` | Indicates whether the action phase completed successfully. If this is `false`, then all changes made during this phase were discarded. Changes made during the compute phase are also rolled back. |
| `valid` | `Bool` | Indicates whether the action phase was valid. If this is `false`, it means that invalid actions were created during smart contract execution. Each action type has its own set of validity criteria. |
| `no_funds` | `Bool` | Indicates whether the account had sufficient funds to execute the actions. `false` means the Action Phase was aborted due to insufficient funds. |
| `status_change` | `AccStatusChange` | Change in the account's status after executing the action phase. Since account deletion is done through actions (using mode 32), this field may contain information about whether the account was deleted. |
| `total_fwd_fees` | `Maybe Grams` | Total forwarding fees paid for messages created during action execution. |
| `total_action_fees` | `Maybe Grams` | Total fees paid for executing actions. |
| `result_code` | `int32` | Result code of action execution. If the code is 0, it means all actions completed successfully. |
| `result_arg` | `Maybe int32` | Argument returned in case of error. Useful for debugging smart contract code. |
| `tot_actions` | `uint16` | Total number of actions created during smart contract execution. |
| `spec_actions` | `uint16` | Number of special actions (everything except `action_send_msg`). |
| `skipped_actions` | `uint16` | Number of actions that were skipped during execution. Refers to message sends that had issues but were created with the `ignore_errors` flag (2). |
| `msgs_created` | `uint16` | Number of messages created during action execution. |
| `action_list_hash` | `bits256` | Hash of the action list. |
| `tot_msg_size` | `StorageUsed` | Total size of created messages. |

### Bounce phase

If either the compute phase or action phase ends with an error and the incoming message had the `bounce` flag set, the bounce phase will be executed:

:::note
For the bounce phase to start due to an error in the action phase, the failed action must have been created with flag 16, which indicates a bounce on failure.
:::

```tlb
tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
```

`tr_phase_bounce_negfunds` is not used in the current version of the blockchain, so we will consider the remaining two:

| Type | Description |
| --- | --- |
| `tr_phase_bounce_nofunds` | Indicates that there were not enough funds to process the message that was supposed to be returned to the sender. |
| `tr_phase_bounce_ok` | Indicates that the message was successfully processed and sent back to the sender. |

Here, `msg_fees` and `fwd_fees` are calculated based on the total `fwd_fees` for processing the message. One-third of this fee is paid immediately and recorded in `msg_fees`, while the remaining part is recorded in `fwd_fees`.

### Full transaction body

Now that we’ve covered the transaction header and its description, we can look at what a full transaction in TON looks like. First, let’s examine the TL-B scheme:

```tlb
transaction$0111 account_addr:bits256 lt:uint64
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;
```

Here we see that a transaction consists of the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `account_addr` | `bits256` | Address of the account to which this transaction belongs. |
| `lt` | `uint64` | Logical time of the transaction. |
| `prev_trans_hash` | `bits256` | Hash of the previous transaction executed on this account. |
| `prev_trans_lt` | `uint64` | Logical time of the previous transaction on this account. |
| `now` | `uint32` | Timestamp of transaction creation in Unix format. |
| `outmsg_cnt` | `uint15` | Number of outbound messages created during transaction execution. |
| `orig_status` | `AccountStatus` | Initial status of the account before the transaction. |
| `end_status` | `AccountStatus` | Status of the account after the transaction. |
| `in_msg` | `Maybe ^(Message Any)` | Incoming message processed during transaction execution. For ordinary transactions, this is always present. |
| `out_msgs` | `HashmapE 15 ^(Message Any)` | Outgoing messages created during the transaction. |
| `total_fees` | `CurrencyCollection` | Total fees paid for executing the transaction. |
| `state_update` | `^(HASH_UPDATE Account)` | Contains the hash of the account’s previous state and the hash of the new state. |
| `description` | `^TransactionDescr` | Transaction description containing details about all execution phases. This field was discussed earlier. |

The `orig_status` and `end_status` fields describe how the account state changed as a result of the transaction. There are four possible statuses:

```tlb
acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;
```

### How to get a transaction using api/v2

Among the available and supported Open Source APIs, we can use [APIv2](https://toncenter.com/api/v2/) and [APIv3](https://toncenter.com/api/v3/index.html#/), both provided by TON Center. APIv2 is a lower-level interface and provides only very basic blockchain data. There are two ways to retrieve a transaction:

- Use the `/api/v2/getTransactions` endpoint:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import axios from 'axios';

    async function main() {
    const client = axios.create({
    baseURL: 'https://toncenter.com/api/v2',
    'timeout': 5000,
    headers: {
    'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
  }
  });

    const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
    const response = await client.get('/getTransactions', {
    params: {
    address: address,
    limit: 1,
    to_lt: 0,
    archival: false
  },
    headers: {
    'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
  }
  });
    console.log(response.data)
  }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>


- Use `JSON-RPC` protocol:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import { Address, TonClient } from '@ton/ton';

    async function main() {
    const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
    apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
  });

    const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
    const response = await client.getTransactions(address, {
    limit: 1,
  });
    console.log(response[0]);
  }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>

The recommended method is to use the `JSON-RPC` protocol, since you can take advantage of an existing SDK where all fields are predefined and properly typed. This way, you don't need to manually interpret each field.

:::note
When retrieving transactions, you might encounter the error `LITE_SERVER_UNKNOWN: cannot compute block with specified transaction: cannot find block (0,ca6e321c7cce9ece) lt=57674065000003: lt not in db`.

This means that the transactions on this account happened a long time ago, and the blocks containing them are no longer stored on the LiteServer. In such cases, you can use `archival: true` to request data from an archival node.
:::

### How to get a transaction using api/v3

`APIv3` is more advanced and convenient for retrieving various events from the blockchain. For example, it allows you to fetch information about NFT transfers, token operations, and even transactions in `pending` status. In this tutorial, we'll focus only on the `transactions` endpoint, which returns finalized transactions:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import axios from 'axios';

    async function main() {
    const client = axios.create({
    baseURL: 'https://toncenter.com/api/v3',
    'timeout': 5000,
    headers: {
    'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
  }
  });

    const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
    const response = await client.get('/transactions', {
    params: {
    account: address,
    limit: 1,
    to_lt: 0,
    archival: false
  }
  });
    console.log(response.data.transactions[0])
  }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>

If we look at the response, we’ll notice that it’s significantly different from the `APIv2` response. The main difference is that this version **indexes** transactions, whereas the previous version was essentially a wrapper around LiteServer communication. This means the data is fetched directly from the server's database.

As a result, we receive already-processed information. For example, if we dig into the response, we can see that the `account_state_before` and `account_state_after` fields contain not just the state hashes, but full account information — including code, data, TON balance, and even ExtraCurrency balance:


```json
[
  account_state_before: {
    hash: 'Rljfqi3l3198Fok7x1lyf9OlT5jcVRae7muNhaOyqNQ=',
    balance: '235884286762',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: 'uUe+xBA4prK3EyIJ8iBk8unWktT4Grj+abz4LF2opX0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  },
  account_state_after: {
    hash: 'asmytWJakUpuVVYtuSMgwjmlZefj5tV5AgnWgGYP+Qo=',
    balance: '225825734714',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: '6L0wUi1S55GRvdizozJj2GkCqjKSx8iK7dEHlTOe8d0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  }
]
```

Additionally, the response includes an `address_book` field, which contains an array of addresses that were interacted with during the transaction execution.

### Transaction fields in the SDK

When inspecting the response obtained via the `JSON-RPC` protocol in `@ton/ton@`, we can see that in addition to the fields discussed above, there are also `hash` and `raw`. These fields are not part of the transaction structure on the blockchain itself — they are added by the SDK for convenience.

The `hash` field provides a function that can be used to compute the transaction hash, while the `raw` field contains the transaction's BOC. This allows us to parse the transaction either using a built-in method from the SDK or manually:


<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import { Address, loadTransaction, TonClient } from '@ton/ton';

    async function main() {
    const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
    apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
  });

    const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
    const response = await client.getTransactions(address, {
    limit: 1,
  });

    const transaction = response[0];
    console.log(loadTransaction(transaction.raw.beginParse()));
    console.log(`Transaction hash: ${transaction.hash().toString('hex')}`);
  }

    main().finally(() => console.log("Exiting..."));
    ```
  </TabItem>
</Tabs>



### Which API should you use?

After reviewing APIv2 and APIv3, the question may arise: which one should you choose? The answer depends entirely on your specific use case. As a general recommendation, you can use the `JSON-RPC` protocol from APIv2, since this allows you to leverage a ready-made SDK that includes all necessary methods and types.

If this functionality doesn't meet your needs, consider a full or partial switch to APIv3 or explore other APIs in the ecosystem that might offer more comprehensive data.

### Action: User Context (a.k.a. Event)

Before we dive into user-facing operations and how to handle them, let’s recap what we’ve learned about transactions:

- A transaction is a record of all changes made to a specific account.
- A transaction consists of several phases that process incoming messages, execute smart contract code, and handle generated actions.
- Each phase has a description that provides details about what occurred during execution.
- A transaction can either complete successfully or fail, depending on whether all phases were completed and whether the generated actions were valid.
- Ordinary transactions always contain an incoming message but may or may not include outgoing messages.
- Transactions can be retrieved using either APIv2 or APIv3, both of which present the data in a convenient format.
- APIv3 indexes transactions and returns processed data, while APIv2 is merely a wrapper over LiteServer.
- The SDK may include additional fields such as `hash` and `raw` for convenience, allowing you to compute the transaction hash and access the BOC directly.

Previously, we discussed actions from a technical standpoint. However, in many API services, the term "action" is used to describe user-level operations. It’s important to remember that TON is an asynchronous blockchain, meaning a single logical operation may consist of a chain of multiple transactions. In this context, the full picture is what matters — not individual transactions.

For example, transferring Jettons from one wallet to another involves at least 3 separate transactions. Different services refer to these chains using different terms such as "action", "event", or "operation". To avoid confusion with technical terms used earlier, we'll use the term `Event`.

:::tip
Keep in mind that not every Jetton transfer is considered a `Jetton Transfer Event`. For example, if you're sending Jettons to a DEX to receive a different token, it would be classified as a `Swap Event`.

The context can vary significantly depending on what you're doing with the Jettons. API services typically pre-parse the `forward_payload` and evaluate many other parameters to determine the exact type of operation and present it clearly to the user. This applies not only to Jettons but also to NFTs and other on-chain operations.
:::

### Event success in the ecosystem: Ordinary TON Transfer

As discussed earlier, everything in TON is asynchronous, so the success of a single transaction doesn’t necessarily mean that the entire chain of operations has succeeded or will succeed in the future. Therefore, we need a more abstract notion of success.

Let’s consider a simple example: an ordinary TON transfer from one wallet to another. This consists of two transactions:

1. The sender’s wallet receives an external message with a signature for verification. After processing this message, the sender’s smart contract creates outbound messages as specified in the body of the external message.
2. The recipient’s wallet receives the incoming message with the specified TON amount.

To determine whether the transfer was successful, it makes sense to check the second transaction. If the recipient’s account has a transaction triggered by an incoming message from our wallet, and the funds were not returned (we'll cover this below), we can consider the transfer successful.

Suppose we want to check for deposits to our wallet: `UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL`. For convenience, we’ll use APIv3 and request the latest 10 transactions on this account:


<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import { fromNano } from '@ton/core';
    import axios from 'axios';

    async function main() {
    const client = axios.create({
    baseURL: 'https://toncenter.com/api/v3',
    'timeout': 5000,
    headers: {
    'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
  }
  });

    const address = 'UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL';
    const response = await client.get('/transactions', {
    params: {
    account: address,
    limit: 10,
    to_lt: 0,
    archival: false
  }
  });

    for (const transaction of response.data.transactions) {
    const description = transaction.description;
    if (description.type !== 'ord') {
    continue;
  }

    const inMsg = transaction.in_msg;
    if (inMsg.created_lt === null) {
    continue; // Skip external messages
  }
    const bouncePhase = description.bounce;

    if (bouncePhase && bouncePhase.type === 'ok') {
    console.log(`Fake deposit detected: ${transaction.hash}`);
    continue;
  }

    console.log(`Deposit detected: ${transaction.hash}. Value: ${fromNano(inMsg.value)} TON.`);
  }
  }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>


After retrieving the transactions, we need to verify the following:

1. The transaction must be an ordinary one, meaning `description.type` should equal `ord`.
2. The incoming message must be internal. This means the `created_lt` field must be present.
3. If the transaction description includes a `bounce` field (this applies only to the `transactions` endpoint in APIv3), it indicates that a bounce phase was triggered. In this case, we must check whether it completed successfully, which would mean the funds were returned to the sender.
4. If all checks pass, we can consider the deposit successfully received on the wallet.

:::danger
Note that the provided code is just an example and not a full-fledged deposit tracking solution. In production applications, you should process not just the last 10 transactions but all transactions that occurred since the last check.

Also keep in mind that the expected field values in a fake deposit scenario may differ depending on the API service. This example reflects the response format of Toncenter's APIv3 `transactions` endpoint only.
:::

If we run this code, we’ll get the following output:

```
Fake deposit detected: 4vXGhdvtfgFx8tkkaL17POhOwrUZq3sQDVSdNpW+Duk=
```

If we take a look at this transaction in the [explorer](https://tonviewer.com/transaction/e2f5c685dbed7e0171f2d92468bd7b3ce84ec2b519ab7b100d549d3695be0ee9), we’ll see that the funds were indeed returned to the sender.

:::note
If we request transactions for this account using APIv2, we won't get any results. This is because the transaction data was only recorded in the block itself, and APIv3’s indexer was able to index it.

However, since this account has no state (not even a single balance top-up), there are no transactions directly associated with it. If there had been at least one deposit, the account state would have changed from `nonexist` to `uninit`, and then APIv2 would have been able to return the transaction.
:::

### Event success in the ecosystem: Jetton Transfer

Now let’s consider a more complex example — a Jetton transfer. To start, here’s what a Jetton transfer looks like:


1. external_in -> User_A - > internal (op::jetton_transfer)
2. internal (op::jetton_transfer) -> User_A_Jetton_Wallet -> internal (op::internal_transfer)
3. internal (op::internal_transfer) -> User_B_Jetton_Wallet


As we can see, in this case there are 3 transactions involved, and the Jetton transfer is only truly complete once the third transaction has been successfully processed. After the third transaction, 2 additional messages may be sent:

1. internal (op::jetton_transfer_notification) -> User_B | If `forward_amount` is set
2. internal (op::excesses) -> response_destination | If `response_destination` is set

However, to verify the transfer, we only need the third transaction.
To simplify the example, let’s assume we want to check for incoming Jettons on a specific wallet:
`EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX`, for the USDT Jetton:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    <details>
      <summary>
        Source code
      </summary>

      ```js
      import { Address, TonClient } from '@ton/ton';

      // Changed version of
      // https://github.com/ton-org/ton-core/blob/b2e781f67b41958e4fde0440752a27c168602717/src/utils/convert.ts#L69C1-L96C2
      export function fromMicro(src: bigint | number | string) {
      let v = BigInt(src);
      let neg = false;
      if (v < 0) {
      neg = true;
      v = -v;
    }

      // Convert fraction
      let frac = v % 1000000n;
      let facStr = frac.toString();
      while (facStr.length < 6) {
      facStr = '0' + facStr;
    }
      facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)![1];

      // Convert whole
      let whole = v / 1000000n;
      let wholeStr = whole.toString();

      // Value
      let value = `${wholeStr}${facStr === '0' ? '' : `.${facStr}`}`;
      if (neg) {
      value = '-' + value;
    }

      return value;
    }

      async function main() {
      const client = new TonClient({
      endpoint: "https://toncenter.com/api/v2/jsonRPC",
      apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
    });

      const address = Address.parse('EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX');
      const response = await client.getTransactions(address, {
      limit: 10,
      archival: true,
    });

      for (const transaction of response) {
      if (transaction.description.type !== 'generic') {
      continue;
    }

      // Check if the compute phase is present and successful
      if (transaction.description.computePhase.type !== 'vm') {
      continue;
    }
      if (transaction.description.computePhase.exitCode !== 0) {
      continue;
    }

      // Check if the action phase is present and successful
      if (transaction.description.actionPhase && transaction.description.actionPhase.resultCode !== 0) {
      continue;
    }

      if (transaction.description.aborted === true) {
      continue;
    }

      if (transaction.inMessage.info.type !== 'internal') {
      continue;
    }

      const body = transaction.inMessage.body.beginParse();
      try {
      /*
      internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
               response_address:MsgAddress
               forward_ton_amount:(VarUInteger 16)
               forward_payload:(Either Cell ^Cell)
               = InternalMsgBody;
      */

      const op = body.loadUint(32);
      if (op !== 0x178d4519) { // op::internal_transfer
      continue;
    }
      const queryId = body.loadUintBig(64);
      const amount = body.loadCoins();
      const from = body.loadAddress();
      const responseAddress = body.loadMaybeAddress();
      const forwardTonAmount = body.loadCoins();
      const eitherForwardPayload = body.loadBoolean();
      const forwardPayload = eitherForwardPayload ? body.loadRef() : body.asCell();

      console.log(`Deposit detected:
    Transaction hash: ${transaction.hash().toString('hex')}
    Query ID: ${queryId}
    Amount: ${fromMicro(amount)} USDT
    From: ${from.toString({ testOnly: true })}
    Response Address: ${responseAddress ? responseAddress.toString({ testOnly: true }) : 'None'}
    Forward TON Amount: ${forwardTonAmount.toString()} TON
    Forward Payload: ${forwardPayload.toBoc().toString('hex')}`);
    } catch (e) {
      console.error(`Error processing transaction ${transaction.hash().toString('hex')}:`, e);
    }
    }
    }

      main().finally(() => console.log("Exiting..."));
      ```

    </details>

  </TabItem>
</Tabs>


First, we retrieve the last 10 transactions from the USDT Jetton Wallet smart contract.
Then we need to validate the following:

1. The transaction must be ordinary, meaning `description.type` should be equal to `generic`.
2. The compute phase must be successful, so `description.computePhase.type` must be `vm`, and `description.computePhase.exitCode` must be `0`.
3. If an action phase is present, it must also be successful — `description.actionPhase.resultCode` must be `0`.
4. The incoming message must be internal — `inMessage.info.type` should be `internal`.
5. The body of the incoming message must contain an `internal_transfer` operation, meaning `body.loadUint(32)` should return `0x178d4519`.
6. If all checks pass, we can consider the deposit successfully credited to the wallet.

To parse the body of the incoming message, we use the TL-B schema from [TEP-0074](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md):

```tlb
internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                     response_address:MsgAddress
                     forward_ton_amount:(VarUInteger 16)
                     forward_payload:(Either Cell ^Cell)
                     = InternalMsgBody;
```

:::note
It's important to understand that this was a very simplified example.
In real-world applications, the logic for handling deposits may differ.
For more detailed guidance on how to handle such events, refer to the
[dedicated article](/v3/guidelines/dapps/asset-processing/jettons).
:::

### Event Success in the Ecosystem: NFT Transfer

An NFT is a smart contract that stores content.
This can be [either a link to the content or the content itself](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md).
Additionally, the contract holds the owner’s address.
Transferring an NFT means updating this field.

To do this, the owner must send a special message formatted according to
the [TL-B schema](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#tl-b-schema)
described in [TEP-0062]:


```tlb
transfer query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)  forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)  = InternalMsgBody;
```

This process is similar to a Jetton Transfer, with one key difference:
the event is considered successful if the field storing the owner's address has changed to the expected value.
If a `response_destination` is specified, any remaining funds are returned to that address:


```tlb
excesses query_id:uint64 = InternalMsgBody;
```

Additionally, if a `forward_amount` is specified, the given amount of TON
along with the `forward_payload` will be sent to the new owner of the NFT:

```tlb
ownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody;
```

The `custom_payload` field is not required for standard NFTs.
It exists solely to allow more complex NFT contracts to pass data
without breaking compatibility with the standard.

To retrieve the owner of an NFT, we will use the `get_nft_data` GET method:

```func
(int, int, slice, slice, cell) get_nft_data() method_id {
  (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
  return (init?, index, collection_address, owner_address, content);
}
```

This means we won’t need to parse transactions or perform complex checks.
We can simply retrieve the NFT data and check the owner's address:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js
    import { Address } from '@ton/core';
    import { TonClient } from '@ton/ton';

    async function main() {
    const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
    apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
  });

    const nftAddress = Address.parse('EQB9Jp075VrO2IXDPEqdxGb_3lBOkKXpvRYV1zFvYp-UVMUY');
    const result = await client.runMethod(nftAddress, 'get_nft_data', []);
    result.stack.skip(3); // init?, index, collection_address
    const nftOwner = result.stack.readAddress();
    console.log(`NFT owner: ${nftOwner.toString()}`);
  }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>


:::note
As with the two previous examples, it's important to note that this is just a simplified case.
In real-world scenarios, the system will be more complex.
For more detailed information, refer to the [dedicated article](/v3/guidelines/dapps/asset-processing/nft-processing/nfts).
:::

### How to Analyze a Contract and Its TL-B Schema to Build Success Criteria Logic

In this section, we’ll use the [Jetton Wallet contract source code](https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-wallet.fc)
and the [TL-B schema](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#tl-b-schema)
to understand how to determine whether an operation has been successfully completed.

To do this, we first need to broadly analyze the available operations in the contract:

```func
  if (op == op::transfer()) { ;; outgoing transfer
    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
    return ();
  }

  if (op == op::internal_transfer()) { ;; incoming transfer
    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
    return ();
  }
```

In this code, we see that there are two operations related to sending and receiving jettons:

1. `op::transfer` — this operation is executed when sending jettons. It calls the `send_tokens` function, which is responsible for sending jettons to another wallet.
2. `op::internal_transfer` — this operation is executed when receiving jettons. It calls the `receive_tokens` function, which is responsible for receiving jettons into the wallet.

Let's break down the sending process. First, let's look at what the incoming message consists of:

```tlb
transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
           response_destination:MsgAddress custom_payload:(Maybe ^Cell)
           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;
```

Here we can see that this message is quite similar to the `internal_transfer` message we looked at earlier. It specifies who to send the jettons to, how many to send, where to return any remaining funds, and optionally, a payload to forward to the jetton recipient.

Now let’s look at the `send_tokens` function, which is responsible for sending jettons:

<details>
  <summary>

    `send_tokens` function

  </summary>

  ```func
  () send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  slice to_owner_address = in_msg_body~load_msg_addr();
  force_chain(to_owner_address);
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  balance -= jetton_amount;

  throw_unless(705, equal_slices(owner_address, sender_address));
  throw_unless(706, balance >= 0);

  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);
  slice to_wallet_address = calculate_jetton_wallet_address(state_init);
  slice response_address = in_msg_body~load_msg_addr();
  cell custom_payload = in_msg_body~load_dict();
  int forward_ton_amount = in_msg_body~load_coins();
  throw_unless(708, slice_bits(in_msg_body) >= 1);
  slice either_forward_payload = in_msg_body;
  var msg = begin_cell()
  .store_uint(0x18, 6)
  .store_slice(to_wallet_address)
  .store_coins(0)
  .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
  .store_ref(state_init);
  var msg_body = begin_cell()
  .store_uint(op::internal_transfer(), 32)
  .store_uint(query_id, 64)
  .store_coins(jetton_amount)
  .store_slice(owner_address)
  .store_slice(response_address)
  .store_coins(forward_ton_amount)
  .store_slice(either_forward_payload)
  .end_cell();

  msg = msg.store_ref(msg_body);
  int fwd_count = forward_ton_amount ? 2 : 1;
  throw_unless(709, msg_value >
  forward_ton_amount +
  ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response
  ;; but last one is optional (it is ok if it fails)
  fwd_count * fwd_fee +
  (2 * gas_consumption() + min_tons_for_storage()));
  ;; universal message send fee calculation may be activated here
  ;; by using this instead of fwd_fee
  ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)

  send_raw_message(msg.end_cell(), 64); ;; revert on errors
  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

  ```

</details>


Even though the code might seem complex, it’s actually quite straightforward:

1. First, the required fields are read from `in_msg_body`, which represents the body of the incoming message.
2. Based on these fields, the contract verifies that the sender is the owner of the jettons and that the balance is sufficient for the transfer.
3. The recipient’s jetton wallet address is derived from the recipient's address.
4. It checks that the incoming message includes enough TON to cover the fees for sending the jettons (and for refunding them in case of an error), and, if necessary, enough to cover delivery of the `forward_payload`.
5. A message is created and sent to the recipient’s jetton wallet. This message contains the `internal_transfer` payload we already know.
6. The contract updates its storage.

Now let’s examine the receiving logic:

<details>
  <summary>

    `receive_tokens` function

  </summary>

  ```func

  () receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
  ;; NOTE we can not allow fails in action phase since in that case there will be
  ;; no bounce. Thus check and throw in computation phase.
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  balance += jetton_amount;
  slice from_address = in_msg_body~load_msg_addr();
  slice response_address = in_msg_body~load_msg_addr();
  throw_unless(707,
  equal_slices(jetton_master_address, sender_address)
  |
  equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)
  );
  int forward_ton_amount = in_msg_body~load_coins();

  int ton_balance_before_msg = my_ton_balance - msg_value;
  int storage_fee = min_tons_for_storage() - min(ton_balance_before_msg, min_tons_for_storage());
  msg_value -= (storage_fee + gas_consumption());
  if(forward_ton_amount) {
  msg_value -= (forward_ton_amount + fwd_fee);
  slice either_forward_payload = in_msg_body;

  var msg_body = begin_cell()
  .store_uint(op::transfer_notification(), 32)
  .store_uint(query_id, 64)
  .store_coins(jetton_amount)
  .store_slice(from_address)
  .store_slice(either_forward_payload)
  .end_cell();

  var msg = begin_cell()
  .store_uint(0x10, 6) ;; we should not bounce here cause receiver can have uninitialized contract
  .store_slice(owner_address)
  .store_coins(forward_ton_amount)
  .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
  .store_ref(msg_body);

  send_raw_message(msg.end_cell(), 1);
}

  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
  var msg = begin_cell()
  .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000
  .store_slice(response_address)
  .store_coins(msg_value)
  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
  .store_uint(op::excesses(), 32)
  .store_uint(query_id, 64);
  send_raw_message(msg.end_cell(), 2);
}

  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

  ```

</details>

In this function we see the following steps:

1. The contract reads the required fields from the body of the incoming message.
2. It increments the token balance counter by the specified amount.
3. It verifies that the sender is either a valid wallet or the jetton master contract.
4. Some calculations are performed for gas management, to handle the contract’s storage fees.
5. If `forward_ton_amount` is specified in the message, a message is created and sent to the actual recipient of the jettons.
6. If `response_address` is provided, a message is created and sent to that address with the remaining funds.

Now we know that the recipient's balance is credited only after the successful execution of the transaction initiated by the `internal_transfer` message. In case of failure, a bounce message is generated and sent to the sender’s jetton wallet. By examining the contract code, we can see that handling of such a message is implemented:


```func
slice cs = in_msg_full.begin_parse();
int flags = cs~load_uint(4);
if (flags & 1) {
  on_bounce(in_msg_body);
  return ();
}
```

When a bounce message is received, the contract invokes the `on_bounce` function:

```func
() on_bounce (slice in_msg_body) impure {
  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  int op = in_msg_body~load_uint(32);
  throw_unless(709, (op == op::internal_transfer()) | (op == op::burn_notification()));
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  balance += jetton_amount;
  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}
```

Here we see that the contract simply returns the tokens to the balance. In this case, there's no need to verify the sender of the message, since a bounce message cannot be faked. If such a message is received, it means that we previously sent a message with the specified content, so we can safely read the amount of tokens and return them to the balance.
