import { BlockMath, InlineMath } from 'react-katex';
import 'katex/dist/katex.min.css';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Interact with transactions

## How can I check if my transaction was successful using the API?
//TODO briefing: what you will learn in this guide

## Terminology

### Actor 

An **actor** is an abstract behavioral model, formalized as a computational object that reacts to incoming messages, changes its internal state, creates new actors, and sends messages to others. Actors are isolated: they do not have access to each other’s state and interact only through message passing.

In other words:

An actor is an independent entity with its state and behavior. Actors interact by exchanging messages. Each actor can:
* change its state
* send messages to other actors
* spawn new actors


![](/img/docs/blockchain-fundamentals/actor_eng_light.svg)


### Actor model

The **actor model** is a model of concurrent computation in which a system is described as a collection of actors that interact through message passing.

Key properties of the model:
* actor isolation
* asynchronous communication
* any computational abstraction can be implemented as an actor

The model is used to precisely describe and analyze distributed systems. For example:
* Email can be modelled as an actor system: users are represented as actors and email addresses serve as actor addresses.
* Web services with endpoints (e.g., SOAP) can be interpreted as actors that handle messages sent to their addresses.


### Account

An **account** in TON is an actor characterized by the following components:
* **Account properties** — common properties of any account: *ID, balance, status, and last transaction (`last_tx`)*
* **Data** — user defined data
* **Code** — custom logic defining the account's behavior

The general state fully defines all account types in TON. Examples:
* `(ID1, 0 TON, unexist)`
* `(ID2, 10 TON, uninit, last_tx)`
* `(ID3, -0.5 TON, frozen)`


![](/img/docs/blockchain-fundamentals/account_eng.svg)


### Smart contract

A **smart contract** is an account whose *code* and *data* are already deployed to the blockchain in addition to its general state.

![](/img/docs/blockchain-fundamentals/smart_contract_eng.svg)

#### Difference between an account and a smart contract

- An **account** is an actor that has a general state — such as balance, address, and status — and may optionally include code and data.

Example: `(ID1, 0 TON, unexist)` or `(ID2, 2 TON, inited, last_tx, data, code)`
- A **smart contract** is an actor with **deployed** code and data that define its specific behavior.

Example: `(ID2, 2 TON, inited, data, code)`


#### Entity structure in TON Blockchain

![](/img/docs/blockchain-fundamentals/structure_eng.svg)

### Asynchrony

In TON, contracts or actors do not call each other directly. Instead, they communicate by sending messages, each of which is processed independently of the others. All interaction happens through asynchronous message passing.

**Asynchrony** is a property of communication, meaning that a message does not need to be processed immediately. This implies the following:
1. *No immediate response is guaranteed*. The receiver may delay responding or may not respond at all.
2. *The sender does not wait for a reply*. After sending a message, an actor continues handling other messages or tasks without blocking or waiting for a response to the previous one—even if that response never arrives.
3. *Message ordering is preserved*. All incoming messages are processed in the order they are received. However, if a message is malformed or incomplete, it is skipped, and the next message is processed without delay.

This is different from synchronous models, where the flow is: call → wait for a response → continue.
In TON, a result can only be received as a separate message — and only if it is explicitly sent.

![](/img/docs/blockchain-fundamentals/actors_msging_eng.svg)

### Structure and communication of actors in TON

#### Account

Earlier, we mentioned that an account is an actor defined by the following components:

* Account properties (ID, balance, status, last_tx)
* Data
* Code

In practice, the actual data layout is more complex, but the logical distinction between an account and a smart contract remains the same. To describe data structures, in TON, TL-B schemas are used. These define how data is laid out at the bit level.

Let’s take a look at how an account is defined.
The account structure consists of several nested objects:

```tlb
account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```

* Address — `MsgAddressInt`
* Balance — `CurrencyCollection`
* State — `AccountState`, which defines the account’s behavior
* Logical time of the account's last applied transaction — `last_trans_lt`
* Storage statistics — `StorageInfo`

<details>

  ```tlb

  account_none$0 = Account;
  account$1 addr:MsgAddressInt storage_stat:StorageInfo
  storage:AccountStorage = Account;

  account_storage$_ last_trans_lt:uint64
  balance:CurrencyCollection state:AccountState
  = AccountStorage;

  account_uninit$00 = AccountState;
  account_active$1 _:StateInit = AccountState;
  account_frozen$01 state_hash:bits256 = AccountState;

  acc_state_uninit$00 = AccountStatus;
  acc_state_frozen$01 = AccountStatus;
  acc_state_active$10 = AccountStatus;
  acc_state_nonexist$11 = AccountStatus;


  _ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

  ```
</details>

Let’s clarify which properties are part of the **account properties**, according to the TL-B schema:

* ID → `MsgAddressInt`
* Balance → `CurrencyCollection`
* Status → `AccountState`
* Last transaction logical time (`last_trans_lt`) — also part of the general state

Meanwhile, the data and code are defined within the state:` AccountState` field.

Now, let’s take a closer look at the account properties and how it’s represented in the data layout.

#### Account status

TON defines account states `AccountState` as follows:

| Status   | TL-B code | Description                                                                                                                                                                                                                                  |
|----------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `uninit` | `00`      | The account exists but contains no code or data. It may hold a non-zero balance but is not initialized yet.                                                                                                                                  |
| `frozen` | `01`      | The account is frozen: its code and data are deleted, but a hash of the previous state is retained. It can't be used, but it can be restored. The account has zero or negative balance, or doesn't meet the workchain’s minimum requirement. |
| `active` | `10`      | The account includes a `StateInit`, which stands for State Initialized, with deployed code and data, meaning that it's already initialized. It is an active smart contract, ready to process incoming messages.  |


```tlb
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;
```

The diagram below illustrates the lifecycle of an account in the TON blockchain, showing how its state changes under different conditions.


![](/img/docs/blockchain-fundamentals/account_states.svg)


#### Smart contract

Smart contracts are a set of promises in digital form, including protocols that govern how the parties fulfil these promises.

In TON, typically by smart contract recognize:
- The program code executed, as described in FunC, Tact, or Tolk, in the blockchain.
- The account that implements business logic and content code.

In technical terms, a smart contract in TON is an `Account` in the active state (`AccountState = active`) with:
* an initialized `code` field in `StateInit` — containing the executable logic
* an initialized `data` field in `StateInit` — storing the persistent contract state


#### Address

An address in TON is a unique identifier for a smart contract required for interaction between network participants.
The account itself has an address, but we define the address entirely for arbitrary use only through a smart contract.
It consists of the following components:


* **WorkChain ID** — a 32-bit signed integer indicating the WorkChain to which the account belongs (e.g., -1 for the MasterChain, 0 for the BaseChain).
* **Account ID** — a 256-bit hash of the `StateInit` structure, which includes the contract’s initialized `code`, `data`, and optionally a `library`, precisely as they were *at the time of deployment*. This hash is based solely on the original `StateInit`; later updates to the contract state do **not** affect the account_id.

The address is defined as:

<BlockMath math="{Address} := ({workchain\_id},{account\_id})" />, where <BlockMath math="{account\_id}:= {HASH(StateInit)}" />

An address corresponds to the first initialized state of a contract and can be calculated even **before** the contract is deployed.
This allows you to use the address ahead of time — for example, to receive tokens or set up interactions.

:::important
An address depends only on the `StateInit` used *at the moment of the contract's first deployment*. Even a small change to the `code`, `data`, or `library` in this initialized state results in a completely different `account_id` — and, therefore, a different **address**.

In fact, during message processing, validators verify the sender’s address — if it’s incorrect, they silently replace it with the correct one.
:::

#### Message feature

A message is a set of instructions intended for a single actor.

#### Transaction feature

A transaction represents an update to an account's state triggered by an incoming message.
It may also produce one or more outgoing messages, depending on the contract logic.

In TON, a transaction is required to update an account's state in response to an incoming message and, if necessary, to continue interacting with other accounts by sending outgoing messages.

#### Asynchronous nature of transactions

In TON, accounts interact exclusively through messages — this is the core of actor-based communication.
Each message triggers a transaction, which records the entire context: the triggering message, state updates, and any generated outbound messages.

Transactions are processed **asynchronously**, meaning that each account’s updates and message handling occur independently over time.

#### Blockchain

**Blockchain** is a distributed ledger consisting of blocks, each containing a set of data. These blocks are cryptographically linked to one another via hashes, forming an immutable chain. This entire chain is replicated and consistently maintained across all participants in the network.

#### AccountChain

**AccountChain** is a chain of transactions executed on a single account in the TON blockchain.
It forms a linear sequence: `Tx1 → Tx2 → Tx3 → …`, where each transaction references the previous one.
For efficient processing and consensus, transactions are grouped into blocks — for example:
`[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]`.

These blocks also include incoming and outgoing message queues, recording all events and state changes for the account during that period.

In other words, an AccountChain is a *micro-blockchain* scoped to a single account.
Like a regular blockchain, it is a linear, append-only sequence of transactions — but dedicated to just one account.
It stores and orders the entire history of that account’s operations and interactions, ensuring transparency and traceability.

At the network level, many such chains are grouped into a **ShardChain** or simply **shard**, which manages a collection of accounts. This abstraction supports logical grouping *AccountChains* across physical infrastructure *ShardChain ↔ Validator*.

The diagram below provides a graphical representation of an AccountChain and its structure.
![](/img/docs/blockchain-fundamentals/accountchain.svg)

#### ShardChain

A **ShardChain** is a blockchain that aggregates multiple AccountChains.
While an AccountChain represents the transaction history of a single account, a ShardChain processes and stores data for a group of accounts that share a common binary address prefix (e.g., all addresses starting with `0b00101`).
Conceptually, a ShardChain can be seen as a **horizontal** blockchain composed of **ShardBlocks**, each of which contains AccountBlocks. ShardChains also facilitate message routing between accounts, ensuring both delivery and order: if one message is sent before another, it will arrive first.

ShardChains are a fundamental unit of TON’s architecture, enabling parallel transaction processing within a scalable and deterministic system.
Each validator is responsible for a specific ShardChain or a group of them, allowing the network to process transactions concurrently across different shards.

![](/img/docs/blockchain-fundamentals/shardchain.svg)

#### WorkChain

A **WorkChain** is an independent blockchain within TON that groups multiple ShardChains or shards.
Unlike a ShardChain, a WorkChain may define its own protocol rules.

TON supports up to 2³² WorkChains, each of which can be divided into up to 2⁶⁰ ShardChains.

#### Types of WorkChain: MasterChain and BaseChain

**BaseChain** is the primary execution chain used for everyday transactions and smart contracts.
It is optimized for low fees, making it suitable for regular users and developers.

![](/img/docs/blockchain-fundamentals/basechain.svg)


**MasterChain** is the main coordinating blockchain, including one ShardChain. It contains:
* protocol parameters
* the current validator set and their stakes
* validator account chains
* metadata about all active WorkChains and ShardChains
* hashes of the latest blocks from all other chains

Gas costs are intentionally high in the MasterChain to ensure stability, prioritize critical operations, and prevent spam.

![](/img/docs/blockchain-fundamentals/masterchain.svg)


Thanks to the hierarchical structure of WorkChains and ShardChains, TON forms a **blockchain of blockchains** — a scalable architecture where each chain operates independently, and all blocks reference their predecessors via cryptographic hashes.

![](/img/docs/blockchain-fundamentals/chain-of-chains.svg)

#### Testnet and Mainnet

#### Mainnet (the main network)

The **Mainnet** is the live production network where:

* all transactions are real
* real tokens are used (e.g., actual Toncoin)

All users and projects operating in production use the Mainnet.

#### Testnet (the test network)

The **Testnet** is a sandbox environment for developers — a copy of the main network but without risk. In Testnet:

* test coins are used, which have no real value
* contracts, transactions, DApps, and errors can be safely tested
* the blockchain can be reset or altered at any time

Testnet is essential for safe development and debugging before launching to the main network.


## Messages

In the TON blockchain, a **message** is the fundamental unit of interaction between accounts (smart contracts). All actions, state changes, and logic execution within accounts are triggered by messages.

## Transaction and message real-life examples

Let’s explore how transactions and messages work in TON through an analogy.
Imagine the TON blockchain as a unique city in the global world — the Internet.
In this city, the rules are strict: residents **never meet in person**, and the **only** way to communicate is via a postal service.
People receive messages asking them to perform a task, complete it privately in their homes, and then send the results back to others.

Each person checks their mailbox and picks up *exactly one incoming message*, then locks themselves inside and doesn’t come out until the task is completed.
While they’re working, new letters may arrive — but they *ignore them completely*.

If they realize mid-task that some necessary information is missing, they *cannot pause to ask for clarification*.
In that case, they must declare the task as failed and, at best, return leftover resources along with scraps of the original instructions.

If the task is successful, the person, as specified in the original message:
* send new messages to other residents, or
* store the resulting items safely in their home.

After finishing, they return to their mailbox and retrieve the **next** incoming message.

Now imagine that for each work session, the person keeps a **detailed journal**.
To keep their work organized and separate, each journal entry is called a **transaction**.
Each transaction contains:
* the full content of the incoming message (the task),
* a note on what was produced and where it was stored,
* and, optionally, information about any messages sent to others.

Messages delivered via the postal system between residents are called **internal messages**.
Messages from the outside world also reach the city. These have a specified recipient, but their sender is unknown — they are known as **external incoming** or **external-in messages**.

While external-in and internal messages fulfil a similar role from the actor’s perspective, each actor may handle them differently. Some may process them normally, while others might completely ignore messages from the outside world — like someone who refuses to open letters from strangers.

#### Message structure: TL-B

Now, let’s look at the data contained in the messages.
As mentioned earlier, both external and internal messages can carry data — but how exactly is this data encoded?

In TON, all data is represented using **cells**.
To serialize data into a cell, TON relies on a well-established standard called **TL-B** (Type Language – Binary).

## Particular message structure

```
message$_ {X:Type} info:CommonMsgInfo
init:(Maybe (Either StateInit ^StateInit))
body:(Either X ^X) = Message X;
```

* `info: CommonMsgInfo` — contains metadata about the message.
* `init: (Maybe (Either StateInit ^StateInit))` — optional field used to initialize a new account or update the existing one.
* `body: (Either X ^X)` —  the main payload of the message; can be embedded directly or stored as a reference.


### Message types

There are three types of messages in TON:

* External incoming: sent from outside the blockchain → received by a smart contract
* Internal: sent from a smart contract → received by a smart contract
* External outgoing: sent from a smart contract → received outside the blockchain (unknown actor)

### External incoming

#### Functional role

**External incoming** or **external-in** messages serve as the primary entry point for the outside world to interact with the TON blockchain. Any user can send arbitrary data to any smart contract, and it’s up to the contract to decide how to handle it.
Technically, any account can receive external messages. However, how a specific contract processes an external-in message depends entirely on its internal logic. The most common type of contract that handles such messages is the **wallet contract**.

Typical sources of external-in messages include:

* users of wallet applications
* validators
* DApp services

Although external-in messages are rarely used in the core logic of smart contracts, they are essential for integrating external actions into the blockchain. Any interaction that originates outside TON — such as sending TON or interacting with a DEX — begins with an external-in message.
The most common example of this is a wallet contract, which receives the user’s instruction and then relays it by sending *internal messages* to other contracts.

#### Sending an external-in message

The term **message** is closely related to a **transaction**, but they serve different purposes and should not be confused:

* A **message** is a data packet exchanged between smart contracts that contains instructions for an action.
* A **transaction** is the result of executing a smart contract in response to an incoming message. During execution, the contract may update its state and produce one or more outgoing messages.

An **external-in message** is a message whose `CommonMsgInfo` header uses the `ext_in_msg_info$10` structure.


```
message$_ {X:Type} info:CommonMsgInfo
init:(Maybe (Either StateInit ^StateInit))
body:(Either X ^X) = Message X;
```

**TL-B:**
```
//external incoming message
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt
import_fee:Grams = CommonMsgInfo;
```

Since an external-in message is sent into the blockchain from the outside, the initiator is an external actor. This can be either a wallet contract or custom code interacting with blockchain API services.

To send an external-in message to a smart contract, you need to:
* Construct a data structure that conforms to the TL-B schema
* Submit this structure to the blockchain using an API service

For example, in **Blueprint**, there is a built-in helper that dynamically assembles this structure for the developer.

```typescript title="external-in.ts"
//@ton/blueprint 0.36.1
import { Address, beginCell } from '@ton/ton';
import { NetworkProvider } from '@ton/blueprint';

export async function run(provider: NetworkProvider, args: string[]) {
    //Mainnet address : 'EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2'
    const address = Address.parse('EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2');

    //Switch address for the Testnet :
    //const address = Address.parse('kQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16z768');

    // Get current seqno using blueprint's provider
    const contractProvider = provider.provider(address);
    const result = await contractProvider.get('seqno', []);
    const currentSeqno = result.stack.readNumber();

    // Send external message with current seqno
    return contractProvider.external(beginCell().storeUint(currentSeqno, 32).endCell());
}

```

:::info How to use examples with Blueprint

1. Prepare a wallet application (e.g., Tonkeeper) that you’ll use to send the external message
2. Install the Blueprint project locally:
`npm create ton@latest`
3. Add the provided script to your Blueprint project under the `scripts` directory, for example:
`blueprintproject/scripts/yourscript.ts`
4. Run the script with the command:
`npx blueprint run yourscript`

:::


### Internal

#### Functional role

An **internal message** is a message sent from one smart contract to another within the TON blockchain.
When a contract receives an internal message, it can reliably determine:
* how many TON coins are attached
* which contracts are the sender and the recipient

The blockchain ensures the integrity of this information, allowing the contract to be trusted and used safely.
**TL-B:**

A contract always initiates internal messages — they are the result of a transaction’s execution.
In other words, as the name implies, the sender of an internal message is always a smart contract.

The most common way to send an internal message is by first sending an external message to a contract that contains the logic to forward the internal message to another contract.

```
//internal message
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
src:MsgAddressInt dest:MsgAddressInt
value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```


| Structure        | Description                                                                                     |
|------------------|-------------------------------------------------------------------------------------------------|
| `int_msg_info$0` | Indicates an internal message. The `$0` tag means that `CommonMsgInfo` starts with a 0 bit.     |
| `ihr_disabled`   | Flag indicating whether Hypercube Routing (IHR) is disabled.                                    |
| `bounce`         | If set to 1, the message will be bounced in case of a processing error.                         |
| `bounced`        | Indicates that the message is a result of a bounce.                                             |
| `src`            | Address of the smart contract that sent the message.                                            |
| `dest`           | Address of the destination smart contract.                                                      |
| `value`          | Structure describing the amount and type of value transferred in the message.                   |
| `ihr_fee`        | Fee for delivery via Hypercube Routing.                                                         |
| `fwd_fee`        | Fee for forwarding the message.                                                                 |
| `created_lt`     | Logical time at which the message was created, used for ordering contract actions.              |
| `created_at`     | Unix timestamp of when the message was created.                                                 |


The first thing a developer needs to specify is the amount of Toncoin attached to the internal message `value` and the destination address `dest`.

In this example, an external message is sent to the wallet contract with additional instructions for sending an internal message. As a result of processing the transaction, the wallet contract sends an outgoing internal message with the specified `value` and recipient `address`.

```typescript title="internal.ts"
//@ton/blueprint 0.36.1
import { Address } from '@ton/ton';
import { NetworkProvider } from '@ton/blueprint';

export async function run(provider: NetworkProvider, args: string[]) {
    const address = Address.parse('kQBUCuxgGsF6znHM_yNmnV_EwtlmdvmDzqTxiWHJip2ux6Wn');
    const contractProvider = provider.provider(address);

    return contractProvider.internal(provider.sender(), {
        value: '0.01',
    });
}
```

### External outgoing

**External outgoing** messages, also known as logs, are a special type of message generated by smart contracts that are *not addressed to any specific recipient*.
Instead, they serve as logs or signals that can be tracked outside the blockchain.
While these messages are rarely used in core smart contract logic, they are important for tasks such as:
* indexing and monitoring the blockchain state
* triggering off-chain processes like notifying external services or updating user interfaces

For example, a decentralized exchange (DEX) contract might emit an external outgoing message after a successful token swap — to notify external systems or users about the event.

**TL-B:**
```
//external outgoing message
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

#### Bounce of messages

A **bounce message** is automatically sent back to the sender when a transaction fails — for example, if the recipient smart contract doesn't exist or if its execution ends with an error.
This mechanism not only signals the failure but also allows the sender to respond appropriately, such as by refunding tokens or displaying an error message to the user.

Most internal messages between smart contracts should be bounceable — meaning they have the bounce flag set — so that in case of failure:
* the message is returned to the sender
* any remaining funds after deducting fees are refunded

Smart contracts, in turn, must:
* check the bounced flag in incoming messages
* either ignore bounced messages (exit with `code = 0`)
* or explicitly handle the error


You can run the following script in Blueprint to compare the differences between bounceable and non-bounceable messages visually.

Use one of the methods below to run the script:

#### Option 1: using environment variables in the command line

```bash
WALLET_MNEMONIC="unfold your mnemonics ... is added here" \
WALLET_VERSION="v4r2" \
npx blueprint run sendBounceableMessages --testnet --mnemonic
```

#### Option 2: using a `.env` file

Create a `.env` file in the source directory:

```bash
WALLET_MNEMONIC="unfold your mnemonics ... is added here"
WALLET_VERSION="v4r2"
```

Then run:

```
npx blueprint run sendBounceableMessages --testnet --mnemonic
```

**Note**: TON Connect (e.g., the `--tonconnect` flag) cannot be used here because wallet extensions like Tonkeeper do not allow dApps to control the `bounce` flag for security reasons. They always send bounceable messages. To maintain this flag, you need to create and sign the message manually using a mnemonic.


```typescript title="sendBounceableMessages.ts"
import { Address, toNano, beginCell, internal } from '@ton/core';
import { NetworkProvider } from '@ton/blueprint';
import { mnemonicToWalletKey } from '@ton/crypto';
import { WalletContractV3R2, WalletContractV4 } from '@ton/ton';

export async function run(provider: NetworkProvider): Promise<void> {
    // --- Get wallet data from environment variables ---
    const mnemonic = process.env.WALLET_MNEMONIC;
    const versionStr = process.env.WALLET_VERSION || 'v4r2';

    if (!mnemonic) {
        throw new Error('WALLET_MNEMONIC environment variable is not set. Please see instructions in the script file.');
    }

    // --- Initialize wallet from mnemonic ---
    const keyPair = await mnemonicToWalletKey(mnemonic.split(' '));
    const secretKey = keyPair.secretKey;

    let wallet;
    if (versionStr === 'v3r1' || versionStr === 'v3r2') {
        wallet = WalletContractV3R2.create({ workchain: 0, publicKey: keyPair.publicKey });
    } else if (versionStr === 'v4r1' || versionStr === 'v4r2') {
        wallet = WalletContractV4.create({ workchain: 0, publicKey: keyPair.publicKey });
    } else {
        throw new Error(
            'Unsupported wallet version: ' + versionStr + '. Supported versions are v3r1, v3r2, v4r1, v4r2.',
        );
    }
    const myAddress = wallet.address;
    console.log(`Using wallet ${versionStr} at address: ${myAddress.toString()}`);

    // --- Check if wallet is deployed ---
    if (!(await provider.isContractDeployed(myAddress))) {
        console.log('Wallet is not deployed. Please send some TON to this address and try again.');
        return;
    }

    // This is a valid address, but its purpose is for burning.
    // 0:0000000000000000000000000000000000000000000000000000000000000000
    // https://ton.org/address/
    // We will send messages to it to demonstrate bounce handling.
    const burnAddress = Address.parse('EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c');

    // --- Get current seqno ---
    const walletProvider = provider.provider(myAddress);
    let seqno = await wallet.getSeqno(walletProvider);
    console.log(`   Current seqno: ${seqno}`);

    // --- Create messages ---

    // This message is sent to a burn address, but it is marked as "bounceable".
    // The transaction will fail on the recipient's side (as it's just a blackhole),
    // and the value (minus fees) will be returned to the sender.
    const bounceableMessage = internal({
        to: burnAddress,
        value: toNano('0.005'),
        body: beginCell().storeUint(0, 32).storeStringTail('bounceable test').endCell(),
        bounce: true,
    });

    // This message is also sent to a burn address, but it is marked as "non-bounceable".
    // The value sent with this message will be lost forever.
    const nonBounceableMessage = internal({
        to: burnAddress,
        value: toNano('0.005'),
        body: beginCell().storeUint(0, 32).storeStringTail('non-bounceable test').endCell(),
        bounce: false,
    });

    // --- Create a transfer with both messages ---
    console.log('Sending one external message with two internal messages (one bounceable, one non-bounceable)...');

    const transfer = wallet.createTransfer({
        seqno: seqno,
        secretKey: secretKey,
        messages: [bounceableMessage, nonBounceableMessage], // Send both in one transaction
    });

    await walletProvider.external(transfer);
    console.log('External message sent successfully!');
}

```

#### Expected output
```
Using file: sendBounceableMessages
Connected to wallet at address: 0QD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxYkp
Using wallet v4r2 at address: EQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxW9m
   Current seqno: 36
Sending one external message with two internal messages (one bounceable, one non-bounceable)...
External message sent successfully!
```

:::important
The contents of a bounce message **must not** be executed as a regular request; it is intended only for error signalling and refund processing.
:::

### Custom messages for executing contract operations

We've covered the native communication mechanisms in TON — *external* and *internal* messages.
To trigger specific logic within a smart contract, you need to attach a **payload** to the standard message.
For internal messages, this optional payload is included in the `body` field.
There are two main ways to define the structure of the message body:
* Based on a TL-B schema provided in the documentation or contract source.
* By analyzing the contract code and effectively reversing the deserialization logic.

#### Serializing internal messages according to TL-B

Let's take the `nft-item.fc` contract as an example. The standard defines a TL-B schema for the message required to transfer ownership to another user.

From a technical standpoint, this is an internal message sent from the current owner's contract containing the *operation code* for transfer and *the new owner's address*.


```tlb

transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`

```

The TON SDK provides predefined primitives for the most common structures, so complex ones are typically encoded using **built-in helpers**.

```ts title="nft-item.ts"
import { Address, beginCell, toNano } from '@ton/ton';
/*
`transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`
*/

const messageBody = beginCell()
    .storeUint(0x5fcc3d14, 32) // opcode for NFT transfer
    .storeUint(0, 64) // query id, by default 0
    .storeAddress(destinationAddress) //
    .storeAddress(destinationAddress) // response destination for lasts funds
    .storeBit(0) // if 0, no custom payload
    .storeCoins(toNano('0.01')) // forward amount - if >0, will send additional message to destination as a wallet notification message
    .endCell();

```

A preconfigured example is available for testing the sending process.
To run it, you need to specify the wallet address and the NFT contract address.

```ts title="nft.ts"
//@ton/blueprint 0.36.1
import { Address, beginCell, toNano } from '@ton/ton';
import { NetworkProvider } from '@ton/blueprint';

export async function run(provider: NetworkProvider, args: string[]) {
    // PREPARE INTERNAL MESSAGE TRANSFER
    const nftItemAddress = Address.parse('kQBUCuxgGsF6znHM_yNmnV_EwtlmdvmDzqTxiWHJip2ux6Wn');
    const destinationAddress = Address.parse('0QABa48hjKzg09hN_HjxOic7r8T1PleIy1dRd8NvZ3922CW7');

    const address = nftItemAddress;
    const contractProvider = provider.provider(address);
    /*
    `transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
    custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;`
     */
    const messageBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // opcode for NFT transfer
        .storeUint(0, 64) // query id
        .storeAddress(destinationAddress)
        .storeAddress(destinationAddress) // response destination
        .storeBit(0) // if 0, no custom payload
        .storeCoins(toNano('0.01')) // forward amount - if >0, will send additional message to destination as a wallet notification message
        .endCell();

    return contractProvider.internal(provider.sender(), {
        value: toNano('0.5'),
        body: messageBody,
    });
}

```

### Internal message serializer according to contract code


Suppose you need to compose a message for a smart contract. As an example, we'll use the Jetton wallet and wallet V3 contracts.
There are two types of receiving functions commonly used:

- [() recv_internal(cell in_msg_full, slice in_msg_body) impure](https://github.com/ton-blockchain/jetton-contract/blob/3d24b419f2ce49c09abf6b8703998187fe358ec9/contracts/jetton-wallet.fc#L187)

To correctly serialize an internal message for this smart contract, we must examine how the contract deserializes incoming messages.


```func
() send_jettons(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure inline_ref {
    ;; see transfer TL-B layout in jetton.tlb
    int query_id = in_msg_body~load_query_id();
    int jetton_amount = in_msg_body~load_coins();
    slice to_owner_address = in_msg_body~load_msg_addr();
    check_same_workchain(to_owner_address);
    (int status, int balance, slice owner_address, slice jetton_master_address) = load_data();
    throw_unless(error::not_owner, equal_slices_bits(owner_address, sender_address));

    balance -= jetton_amount;
    throw_unless(error::balance_error, balance >= 0);

    cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, my_code());
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    slice response_address = in_msg_body~load_msg_addr();
    in_msg_body~skip_maybe_ref(); ;; custom_payload
    int forward_ton_amount = in_msg_body~load_coins();
    check_either_forward_payload(in_msg_body);
    slice either_forward_payload = in_msg_body;
}

() recv_internal(int my_ton_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    if (msg_flags & 1) { ;; is bounced
        on_bounce(in_msg_body);
        return ();
    }
    slice sender_address = in_msg_full_slice~load_msg_addr();
    int fwd_fee_from_in_msg = in_msg_full_slice~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of forward_payload costs

    int op = in_msg_body~load_op();

    ;; outgoing transfer
    if (op == op::transfer) {
        send_jettons(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }
}
```

Now, we need to use this function as a reference to construct a valid message:

To run the script and send an internal message, follow these steps:

1. Request Testnet TON from https://t.me/testgiver_ton_bot
2. Request Testnet USDT from https://t.me/testnet_usdt_giver_bot
3. Replace the `jettonWalletAddress` in the script with your own Jetton wallet address.
4. Run the script `npx blueprint run sendInternalMessage --testnet --tonconnect`


```ts title="sendInternalMessage.ts"
import { Address, toNano, beginCell } from '@ton/core';
import { NetworkProvider } from '@ton/blueprint';


export async function run(provider: NetworkProvider): Promise<void> {
    const sender = provider.sender();
    const myAddress = sender.address;
    if (!myAddress) {
        throw new Error('Wallet not connected!');
    }

    console.log(`Sending internal message from wallet: ${myAddress.toString()}`);

    // Attention: Replace with your real Jetton Wallet address
    const jettonWalletAddress = Address.parse('0QD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxYkp');

    // --- Correct body for () send_jettons ---
    const jettonTransferBody = beginCell()
        .storeUint(0xf8a7ea5, 32) // op::internal_transfer
        .storeUint(0, 64) // query_id
        .storeCoins(1) // jetton_amount 0.000001 for testnet USDT
        .storeAddress(myAddress) // to_address (sending to myself)
        .storeAddress(myAddress) // response_address for excesses
        .storeMaybeRef(null) // custom_payload
        .storeCoins(toNano('0.000000001')) // forward_ton_amount lowest possible amount to get jetton notify message
        .storeMaybeRef(null) // forward_payload
        .endCell();

    // --- This wrapper will handle basic internal message ---
    await sender.send({
        to: jettonWalletAddress,
        value: toNano('0.02'), // To handle gas
        body: jettonTransferBody,
    });

    console.log('Internal message on Jetton Wallet successfully sent!');
}
//=======================================================================
// TEP - 74
// https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md

/*
transfer#0f8a7ea5
  query_id:uint64
  amount:Coins
  destination:MsgAddress
  response_destination:MsgAddress
  custom_payload:(Maybe ^Cell)
  forward_ton_amount:Coins
  forward_payload:(Either Cell ^Cell)
  = JettonMsg;
*/

```


- [() recv_external(slice msg_body) impure](https://github.com/aSpite/wallet-tutorial/blob/73c213add90ff115e45e58d0bcd9f1ea1fd44c89/JavaScript%20-%20TypeScript/src/wallet_v3.fc#L7)

Although you can use `blueprint --tonconnect` to send internal messages, it does **not** support external messages.
This limitation exists because TON Connect does **not** expose low-level signing capabilities due to the following reasons:


1. **Security by design**: wallets (e.g., Tonkeeper) do not expose raw private keys to dApps.
2. **TON Connect abstraction**: the provider hides the wallet's internal implementation behind a unified interface.
3. **Limited API surface**: blueprint is designed for contract deployment and testing, not for manual message signing.

That is why we use mnemonic method of the blueprint instead of TON Connect:

```func
() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until <= now());
  var ds = get_data().begin_parse();
  var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256));
  ds.end_parse();
  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, subwallet_id == stored_subwallet);
  throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
  accept_message();
  cs~touch();
  while (cs.slice_refs()) {
    var mode = cs~load_uint(8);
    send_raw_message(cs~load_ref(), mode);
  }
}
```

Use one of the methods below to run the following script:

#### Option 1: using environment variables in the command line

```bash
WALLET_MNEMONIC="unfold your mnemonics ... is added here" \
WALLET_VERSION="v4r2" \
npx blueprint run sendExternalMessage --testnet --mnemonic
```

#### Option 2: using a `.env` file

Create a `.env` file in the source directory:

```bash
WALLET_MNEMONIC="unfold your mnemonics ... is added here"
WALLET_VERSION="v4r2"
```

Then run:

```
npx blueprint run sendExternalMessage --testnet --mnemonic
```


```ts title="sendExternalMessage.ts"
import { NetworkProvider } from '@ton/blueprint';
import { beginCell, toNano } from '@ton/core';
import { sign, mnemonicToWalletKey } from '@ton/crypto';
import { WalletContractV3R2, WalletContractV4 } from '@ton/ton';


export async function run(provider: NetworkProvider): Promise<void> {
    // --- Get wallet data from environment variables ---

    const mnemonic = process.env.WALLET_MNEMONIC;
    const versionStr = process.env.WALLET_VERSION || 'v4r2';

    if (!mnemonic) {
        throw new Error('WALLET_MNEMONIC environment variable is not set');
    }

    // --- Initialize wallet from mnemonic ---
    const keyPair = await mnemonicToWalletKey(mnemonic.split(' '));
    const secretKey = keyPair.secretKey;

    let wallet;
    if (versionStr === 'v3r1' || versionStr === 'v3r2') {
        wallet = WalletContractV3R2.create({ workchain: 0, publicKey: keyPair.publicKey });
    } else if (versionStr === 'v4r1' || versionStr === 'v4r2') {
        wallet = WalletContractV4.create({ workchain: 0, publicKey: keyPair.publicKey });
    } else {
        throw new Error(
            'Unsupported wallet version: ' + versionStr + '. Supported versions are v3r1, v3r2, v4r1, v4r2.',
        );
    }
    const myAddress = wallet.address;

    console.log(`Using wallet ${versionStr} at address: ${myAddress.toString()}`);

    // --- Check if wallet is deployed ---
    if (!(await provider.isContractDeployed(myAddress))) {
        console.log('Wallet is not deployed. Please send some TON to this address and try again.');
        return;
    }

    // --- Get current seqno ---
    const walletProvider = provider.provider(myAddress);
    const seqno = await wallet.getSeqno(walletProvider);
    console.log(`   Current seqno: ${seqno}`);

    // --- Create internal message (a simple transfer to self) ---
    const internalMessage = beginCell()
        .storeUint(0x10, 6) // flags: ihrDisabled, bounce, bounced
        .storeAddress(myAddress)
        .storeCoins(toNano('0.01'))
        .storeUint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) // empty simple message body
        .endCell();

    // --- Create unsigned external message for signing ---
    const subwalletId = 698983191; // Standard subwallet ID
    const validUntil = Math.floor(Date.now() / 1000) + 60; // 60 seconds from now

    const toSign = beginCell().storeUint(subwalletId, 32).storeUint(validUntil, 32).storeUint(seqno, 32);
    // var (subwallet_id, valid_until, msg_seqno) from func

    // Add 'op' field for v4 wallets
    if (versionStr.startsWith('v4')) {
        toSign.storeUint(0, 8); // op = 0 for simple transfer
    }

    toSign
        .storeUint(3, 8) // var mode from func
        .storeRef(internalMessage); // cs~load_ref() from func

    const toSignCell = toSign.endCell();

    // --- Sign the message hash ---
    const signature = sign(toSignCell.hash(), secretKey);
    console.log(`      Message signed`);

    // --- Create final external message body with signature ---
    const body = beginCell()
        .storeBuffer(signature) // var signature
        .storeBuilder(toSign) // in_msg
        .endCell();

    console.log(`  Sending external message...`);

    // --- Send the external message to the network ---
    await provider.provider(myAddress).external(body);

    console.log('  Message sent successfully!');
}

```

### Internal messages serializer according disabled code

If the developer does not have access to TL-B schemas or the original contract source code, the only available option is to analyze the disassembled contract code.

This method is the least efficient and most error-prone but can be helpful when working with legacy or undocumented contracts.

Example: [Simple contract](https://verifier.ton.org/EQAyVZ2rDnEDliuaQJ3PJFKiqAS-9fOm9s7DG1y5Ta16zwU2)


## Hashes in TON Blockchain

Hashes play a vital role in TON Ecosystem, enabling data identification and verification at all layers of the blockchain.
Understanding how hashing works will help you effectively track transactions, validate messages, and integrate your applications with TON.

### What is a hash?

In TON, a **hash** is a unique cryptographic fingerprint of data computed using the **SHA-256** algorithm.
Each cell, message, or transaction has its unique hash, which acts as a digital signature.

### Data representation in TON

All data in TON is stored in **cells**. Conceptually, a cell is a structure that holds up to **1023 bits of data** and up to **4 references** to other cells.
Cell trees are serialized and packed using a unified standard cell format.

In TL-B, this structure is referred to as a **bag of cells (BoC)**:

```tlb


serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)
  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }
  size:(## 3) { size <= 4 }
  off_bytes:(## 8) { off_bytes <= 8 }
  cells:(##(size * 8))
  roots:(##(size * 8)) { roots >= 1 }
  absent:(##(size * 8)) { roots + absent <= cells }
  tot_cells_size:(##(off_bytes * 8))
  root_list:(roots * ##(size * 8))
  index:has_idx?(cells * ##(off_bytes * 8))
  cell_data:(tot_cells_size * [ uint8 ])
  crc32c:has_crc32c?uint32
  = BagOfCells;

```

A deep understanding of this structure isn’t required — TON development tools and SDKs already include helpers that handle it for you.

### Hash types in TON

:::info Important
Hashes in TON are irreversible — the original data cannot be reconstructed from the hash.
However, they are deterministic — the same input always produces the same hash.
:::

#### Message body hash

The **message body hash** is a unique identifier of a message’s content.
It is calculated from the cell containing the message data.

The body refers to the field `body: (Either X ^X)`:

```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

```

Let’s walk through an example using a message body with the comment "Hello, TON!" and compute its hash.

```typescript title="msg_body_hash.ts"
import { beginCell } from '@ton/core';

// Create the message body to increment the counter
const messageBody = beginCell()
    .storeUint(0, 32) // op code
    .storeStringTail('Hello TON!')
    .endCell();

console.log('Message body hash:', messageBody.hash().toString('hex'));
```

#### Expected output

```
Message body hash: d989794fa90c9817a63a22e00554574f3c4a347dcfd2e2886980a294de15f2af
```

**When to use a message body hash:**

* to verify data integrity
* for debugging and logging operations
* to deduplicate messages in your application

#### Full message hash

A full message includes not just the body but also headers with metadata such as the sender, recipient, amount, and fees.
Its hash uniquely identifies the entire message.

For internal messages, this corresponds to the `Message X` structure defined in the following TL-B schema:

```tlb
message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;


int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
```

#### Example:

```typescript title="full_msg_hash.ts"
import { storeMessage, beginCell, Address, Message } from '@ton/ton';
import { toNano } from '@ton/core';

// Create the message body to increment the counter
const messageBody = beginCell()
    .storeUint(0, 32) // op code
    .storeStringTail('Hello TON!')
    .endCell();

// Create a complete message object
const message: Message = {
    info: {
        type: 'internal',
        dest: Address.parse('UQAi....'), // Insert recipient address
        value: { coins: toNano('0.1') },
        bounce: true,
        src: Address.parse('UQA1....'), // Insert sender address
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n,
    },
    body: messageBody,
};

// Get the complete message hash
const messageCell = beginCell().store(storeMessage(message)).endCell();

const fullMessageHash = messageCell.hash();
console.log('Full message hash:', fullMessageHash.toString('hex'));

```

#### Expected output
```
Full message hash: 40b1477f90d702af223f15194724e0c12b51028bc622444959e155e77903b12c
```

**When to use the complete message hash:**

* to track specific messages on the blockchain
* when using the TON Center API to search for transactions
* to verify that no one modified the message

#### Transaction hash

A **transaction hash** is a unique identifier for an entire transaction.
It derives from all the data involved in the transaction, including incoming and outgoing messages, state changes, and fees.
This data becomes available only after the blockchain executes the transaction, so the hash is calculated once the transaction is recorded.

**Practical example of obtaining a transaction hash:**

```typescript title="trx_hash.ts"
import { TonClient, beginCell, storeMessage } from '@ton/ton';
import { Address } from '@ton/core';

async function main() {
    const client = new TonClient({
        // Testnet endpoint; if you're working on Mainnet, don't forget to update this
        endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
        apiKey: 'insert your api key', // Get your API key via the toncenter.com bot
    });

    const transactions = await client.getTransactions(
        Address.parse('0QD3o...'), // Insert your wallet address here
        { archival: true, limit: 10 },
    );

    for (const tx of transactions) {
        const txHash = tx.hash();
        console.log('Transaction hash:', txHash.toString('hex'));

        // You can also get the hash of the incoming message
        if (tx.inMessage) {
            const inMsgCell = beginCell().store(storeMessage(tx.inMessage)).endCell();
            const inMsgHash = inMsgCell.hash();
            console.log('Incoming message hash:', inMsgHash.toString('hex'));
        }
    }
}

main().catch(console.error);

```
#### Expected output

Displays the last 10 transactions for the specified address.
For each transaction, it prints the transaction hash.
If an incoming message exists, it also prints the hash of that message.

```
Transaction hash: 79a6406e5544e95bbe5db8c7e8189daaca240b2d6b4f21cc479c3082dd4c5cce
Incoming message hash: 4557aa15e21cf0501f3d82eaa26a23ab61c08a544490154bd12a1814d492db42
Transaction hash: 1a86894bbe2f5af090d97f761f0367a16b713e93247056003e6d8b6a68a5165e
Incoming message hash: dfa0916ceee9dd26c6966d55446b23f88950e118432f870d092cfcde83a3b864
:
:
```

#### Normalized message hash

Normalization is a standardization process that converts different representations into a consistent format. While messages across interfaces follow the TL-B scheme, structural differences in implementation sometimes lead to collisions.

To address this, the ecosystem defines a standard that ensures consistent hash calculation. The normalization rules are specified in detail in [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467).

**The problem normalization solves:**

Functionally identical messages may differ in how they represent the `src`, `import_fee`, and `init` fields. These variations result in different hashes for messages with equivalent content, which complicates transaction tracking and deduplication.

**How normalization works:**

The normalized hash is computed by applying the following standardization rules to an external-in message:

1. **Source Address (`src`)**: set to `addr_none$00`
2. **Import Fee (`import_fee`)**: set to `0`
3. **InitState (`init`)**: set to an empty value
4. **Body**: always stored as a reference

**Practical example of calculating a normalized hash:**

```typescript title="norm_hash.ts"
import { beginCell, Cell, Address } from '@ton/core';

function normalizeExternalMessage(destAddress: Address, bodyCell: Cell): Cell {
    try {
        const normalizedExtMessage = beginCell()
            .storeUint(0b10, 2) // Set external message prefix (10 in binary)
            .storeUint(0, 2) // Set src to addr_none (normalization)
            .storeAddress(destAddress) // Set destination address
            .storeCoins(0) // Set import_fee to 0 (normalization)
            .storeBit(false) // Set init to nothing$0 (normalization)
            .storeBit(true) //  Use right$1 to store body by reference (normalization)
            .storeRef(bodyCell) // Store body as a reference (normalization)
            .endCell();

        return normalizedExtMessage;
    } catch (error: any) {
        console.error('❌ Error in normalization:', error.message);
        throw error;
    }
}

// Example
const messageBody = beginCell()
    .storeUint(0, 32) // Set opcode for a simple transfer
    .storeStringTail('Normalized hash example')
    .endCell();

const destinationAddress = Address.parse('EQB...');
const normalizedExternalMessage = normalizeExternalMessage(destinationAddress, messageBody);
const normalizedHash = normalizedExternalMessage.hash().toString('hex');

console.log('Normalized message hash:', normalizedHash);

```

#### Expected output

```
Normalized message hash: ee53ccd1224c315597bdbafb2e722316d9471490b13dd9e1834903b094eb5964
```


**Practical example of calculating a non-normalized hash:**

Before April 2025, message hashes were not normalized across the ecosystem. If your code constructs messages without applying normalization, it may produce inconsistent hashes. In such cases, update the logic to follow the normalization rules described in [TEP-467](https://github.com/ton-blockchain/TEPs/pull/467).

Below is an example of non-normalized message construction — avoid using this approach:

<details>
  <summary> Avoid this approach </summary>
  ```typescript title="non_norm_hash.ts"

  import { mnemonicToWalletKey } from '@ton/crypto';
  import { WalletContractV4, TonClient, toNano, beginCell, Address, internal } from '@ton/ton';

  // Create a client instance for accessing Testnet via TonCenter
  const client = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'your api key', // Get your API key via the toncenter.com bot
});

  // Construct the message body — arbitrary opcode and payload string
  const messageBody = beginCell()
    .storeUint(0, 32) // op-code — arbitrary, e.g., 0
    .storeStringTail('Hello TON!') // Payload string in the message body
    .endCell();

  // Wrap the body into an internal message
  const internalMessage = internal({
    to: Address.parse('0QD3....'), // recipient
    value: toNano('0.1'), // 0.1 TON
    body: messageBody,
});

  async function main() {
  // Derive wallet keys from the mnemonic phrase
    const mnemonic = 'your seed phrase';
    const keyPair = await mnemonicToWalletKey(mnemonic.split(' ')); // Insert your seed phrase here

  // Create a WalletContractV4 instance from the public key
    const wallet = WalletContractV4.create({
      publicKey: keyPair.publicKey,
      workchain: 0,
});

    const contract = client.open(wallet);
    const seqno = await contract.getSeqno();

    // Create an external message using the wallet contract
    const externalMessage = await wallet.createTransfer({
      seqno,
      secretKey: keyPair.secretKey,
      messages: [internalMessage],
});

    console.log('Non-normalized external message hash:', externalMessage.hash().toString('hex'));
}

  main();


  ```

**Expected output**
```
Non-normalized external message hash: 8dd5c85be08e33341553cb1e5a2f08323e9ae9314d5ceac2e3a6c79f11151b5e
```

</details>

The algorithm may differ from the normalized version in any way.
If the absence of normalization causes issues in an existing project, the correct approach is to **migrate to normalized hashes across the entire codebase**.

### Sending a message and verifying delivery

One common scenario is sending a message and checking that the blockchain accepts and processes it.

**Step-by-step process:**

```typescript title="send_and_verify_msg.ts"
import { internal, TonClient, Address, beginCell, WalletContractV4, SendMode } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';

async function sendAndVerifyMessage() {
    const client = new TonClient({
        // Testnet endpoint; if you're working on Mainnet, don't forget to update this
        endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
        apiKey: 'insert your api key', // Get your API key via the toncenter.com bot
    });

    // Load wallet key pair from mnemonic
    const mnemonic = 'your mnemonic'.split(' '); // Insert your seed phrase here
    const keyPair = await mnemonicToPrivateKey(mnemonic);

    const wallet = client.open(
        WalletContractV4.create({
            publicKey: keyPair.publicKey,
            workchain: 0,
        }),
    );

    // Create message body with comment
    const messageBody = beginCell().storeUint(0, 32).storeStringTail('Hello TON!').endCell();

    // Get current seqno
    const seqno = await wallet.getSeqno();

    // Send transaction
    await wallet.sendTransfer({
        secretKey: keyPair.secretKey,
        seqno,
        messages: [
            internal({
                to: Address.parse('0QD3o...'), // Insert the address here
                value: '0.05',
                body: messageBody,
            }),
        ],
        sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
    });

    // Wait 10 seconds before checking seqno again
    await new Promise((resolve) => setTimeout(resolve, 10000));

    // Check if the transaction was processed
    const newSeqno = await wallet.getSeqno();

    if (newSeqno > seqno) {
        console.log('Transaction sent successfully!');

        // Fetch recent transactions for this wallet
        const transactions = await client.getTransactions(wallet.address, {
            archival: true,
            limit: 5,
        });
        // Find the relevant external-in transaction
        const ourTx = transactions.find(
            (tx) => tx.inMessage?.info.type === 'external-in' && tx.description.type === 'generic',
        );

        if (ourTx) {
            const txHash = ourTx.hash().toString('hex');
            console.log('Transaction Hash:', txHash);
            const viewerUrl = `https://testnet.tonviewer.com/transaction/${txHash}`;
            console.log('Transaction link:', viewerUrl);
        }
    } else {
        console.log('Transaction was not processed');
    }
}

sendAndVerifyMessage().catch(console.error);

```

#### Expected output

```
Transaction sent successfully!
Transaction hash: 285f8df8f968f63680f8efaff004369f4e7aeb8619293da035cb8ca3899232f3
Transaction link: https://testnet.tonviewer.com/transaction/82ee8ee68d8b764105139b7b783b3d91d8344c6e44ee67a38ca5ee967615d31a
```

### Transaction lookup via BoC

When a user confirms the sending of an external message via TON Connect, you receive a BoC or bag of cells.
You can use this BoC to look up the corresponding transaction on the blockchain.

**Usage example:**

Let’s walk through an example of sending an external message using TON Connect in a React app.
We use the [demo-dapp-with-react-ui](https://github.com/ton-connect/demo-dapp-with-react-ui) project as a reference to obtain the BoC and hash to find a transaction.

In this project, navigate to `src/components/TxForm` and replace the contents of the `TxForm.tsx` react file with the following code:

<details>
  <summary>Obtaining BoC and hash using react example</summary>
  ```tsx title="TxForm.tsx"
  import React, { useState } from 'react';
  import './style.scss';
  import { SendTransactionRequest, useTonConnectUI } from "@tonconnect/ui-react";
  import { Address, beginCell, Cell, loadMessage } from '@ton/ton';

  // This example uses a predefined smart contract `stateInit`.
  // to interact with an EchoContract — a contract that returns the sent value back to the sender.
  // This is useful for testing, as it prevents unintentional token loss.
  const defaultTx: SendTransactionRequest = {
      // The transaction is valid for 10 minutes from the current time (in Unix epoch seconds).
      validUntil: Math.floor(Date.now() / 1000) + 600,
      messages: [
          {
              // Insert the recipient address
              address: 'your address',
              // Amount to send in nanoTON. For example, 0.005 TON is 5000000 nanoTON.
              amount: '5000',
              // (Optional) State initialization in BOC (base64).
              stateInit: 'te6cckEBBAEAOgACATQCAQAAART/APSkE/S88sgLAwBI0wHQ0wMBcbCRW+D6QDBwgBDIywVYzxYh+gLLagHPFsmAQPsAlxCarA==',
          },

      ],
  };

  /**
  * Normalize an external message according to TEP-467:
  * https://github.com/ton-blockchain/TEPs/blob/master/text/0467-normalized-message-hash.md
  *
  * Normalization rules:
  * 1. Source Address (`src`): always set to `addr_none$00`
  * 2. Import Fee (`import_fee`): always set to `0`
  * 3. Init State (`init`): always set to empty
  * 4. Body: always stored as a reference
  */

  function normalizeExternalMessage(destAddress: Address, bodyCell: Cell): Cell {
      return beginCell()
          .storeUint(0b10, 2)
          .storeUint(0, 2)
          .storeAddress(destAddress)
          .storeCoins(0)
          .storeBit(false)
          .storeBit(true)
          .storeRef(bodyCell)
          .endCell();
  }

  export function TxForm() {
      const [boc, setBoc] = useState<string | null>(null);
      const [hash, setHash] = useState<string | null>(null);
      const [normalizedHash, setNormalizedHash] = useState<string | null>(null);
      const [error, setError] = useState<string | null>(null);
      const [isSending, setIsSending] = useState(false);
      const [tonConnectUi] = useTonConnectUI();

      const send = async () => {
          setIsSending(true);
          setError(null);
          setBoc(null);
          setHash(null);
          setNormalizedHash(null);
          try {
              const result = await tonConnectUi.sendTransaction(defaultTx);
              const receivedBoc = result.boc;
              setBoc(receivedBoc);
              const externalMessageCell = Cell.fromBoc(Buffer.from(receivedBoc, 'base64'))[0];
              const originalHash = externalMessageCell.hash().toString('hex');
              setHash(originalHash);

              const message = loadMessage(externalMessageCell.beginParse());
              if (message.info.type !== 'external-in')
                  throw new Error(`Expected an external-in message, got ${message.info.type}.`);

              const destAddress = message.info.dest;
              if (!destAddress || !(destAddress instanceof Address)) {
                  throw new Error('Destination address not found in the parsed message.');
          }

              const bodyCell = message.body;
              const normalizedExtMessage = normalizeExternalMessage(destAddress, bodyCell);
              setNormalizedHash(normalizedExtMessage.hash().toString('hex'));
          } catch (e) {
              setError((e as Error).message);
          } finally {
              setIsSending(false);
          }
      };

      return (
          <div className="send-tx-form">
              <button onClick={send} disabled={isSending}>
              {isSending ? 'Sending...' : 'Send transaction'}
              </button>

              {error && <p style={{ color: 'red' }}>Error: {error}</p>}

              {boc && (
                  <div className="boc-hash-block">
                      <span className="boc-label">BOC (base64):</span>
                      <pre className="boc-pre">{boc}</pre>

                      <span className="hash-label">Original hash to find a transaction:</span>
                      <pre>{hash}</pre>

                      <span className="hash-label">Normalized hash (TEP-467):</span>
                      <pre>{normalizedHash}</pre>

                      {hash && normalizedHash && (
                          <div
                              style={{
                                  marginTop: '10px',
                                  padding: '10px',
                                  backgroundColor: hash === normalizedHash ? '#d4edda' : '#f8d7da',
                                  borderRadius: '5px',
                              }}
                            >
                              <strong>Hashes {hash === normalizedHash ? 'MATCH' : 'DO NOT MATCH'}</strong>
                              {hash !== normalizedHash && (
                                  <div style={{ fontSize: '12px', marginTop: '5px' }}>
                                    The original message is not normalized according to TEP-467.
                                  </div>
                            )}
                        </div>
                    )}
                </div>
              )}
        </div>
    );
}
```

</details>

After you run the code, the demo DApp launches.
To proceed:
* Connect your Tonkeeper wallet.
* Click the **Send transaction** button.
* Approve the transaction in your wallet.

Once the transaction is sent, the UI displays the following fields:
* **BOC (base64)** – the raw external message in base64 format.
* **Original hash** – the hash of the message as sent. You can use it to look up the transaction on-chain.
* **Normalized hash (TEP-467)** – the hash computed after normalization, used for consistent message identification.

<details>
 <summary>Transaction lookup via BoC</summary>

  ```typescript title="trx_lookup_via_boc.ts"
  // Check transaction by its hash
  async function checkTransactionStatus(txHash: string, walletAddress: string) {
    try {
      const response = await fetch(
        `https://testnet.toncenter.com/api/v2/getTransactions?` + `address=${walletAddress}&hash=${txHash}`,
      );
      const data = await response.json();

      if (data.result.length > 0) {
        console.log('Transaction found on the blockchain');
        const viewerUrl = `https://testnet.tonviewer.com/transaction/${trxHash}`;
        console.log('Transaction link:', viewerUrl);
        return data.result[0];
    } else {
        console.log('Transaction not found');
        return null;
    }
    } catch (error) {
        console.error('Error while checking transaction:', error);
        return null;
    }
}

  const walletAddress = 'insert your wallet address';
  // Here you can insert the hash that you obtained from the react example
  const trxHash = 'insert the transaction hash';

  checkTransactionStatus(trxHash, walletAddress);

  ```

  **Expected output**

  ```
  Transaction found on the blockchain
  Transaction link: https://testnet.tonviewer.com/transaction/ad53eb8d1145b239d615dfd3bffb1b9cb7c8c5823530dc217d988fb89794f59a
  ```

</details>

### Best practices

#### Verify transaction status via API

```typescript title="status_api.ts"
// Check the transaction status by its hash
async function checkTransactionStatus(txHash: string, walletAddress: string) {
    try {
        const response = await fetch(
            `https://testnet.toncenter.com/api/v2/getTransactions?` + `address=${walletAddress}&hash=${txHash}`,
        );
        const data = await response.json();

        if (data.result.length > 0) {
            console.log('Transaction found on the blockchain');
            const viewerUrl = `https://testnet.tonviewer.com/transaction/${trxHash}`;
            console.log('Transaction link:', viewerUrl);
            return data.result[0];
        } else {
            console.log('Transaction not found');
            return null;
        }
    } catch (error) {
        console.error('Error while checking transaction status:', error);
        return null;
    }
}

const walletAddress = 'your address';
const trxHash = 'your trx hash';

checkTransactionStatus(trxHash, walletAddress);
```

#### Expected output

```
Transaction found on the blockchain
Transaction link: https://testnet.tonviewer.com/transaction/df51860233d75...
```

#### StateInit hash for address verification

In [TON Connect](v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#backend-example), you often need to verify that a wallet address corresponds to its `StateInit`.
The `StateInit` hash must match the hash portion of the address.

**Practical example of address verification:**

Retrieve the wallet’s `StateInit`:

```typescript title="get_stateinit.ts"
import { WalletContractV4, beginCell } from '@ton/ton';
import { mnemonicToPrivateKey } from '@ton/crypto';

async function getStateInit() {
    try {
        const mnemonic = 'your mnemonic'.split(' '); // Insert your seed phrase here
        const keyPair = await mnemonicToPrivateKey(mnemonic);

        // Create a wallet V4
        const wallet = WalletContractV4.create({
            publicKey: keyPair.publicKey,
            workchain: 0,
        });

        // Generate the StateInit cell
        const stateInitCell = beginCell().storeRef(wallet.init.code).storeRef(wallet.init.data).endCell();

        const stateInitBase64 = stateInitCell.toBoc().toString('base64');

        console.log('StateInit (base64):', stateInitBase64);
        console.log('Wallet address:', wallet.address.toString({ bounceable: true }));
        console.log('Public key (hex):', Buffer.from(keyPair.publicKey).toString('hex'));

        return stateInitBase64;
    } catch (error) {
        console.error('Error:', error);
    }
}

getStateInit().catch(console.error);

```
#### Expected output

```
StateInit (base64): te6cckECFgEAAwMAAgABFQEU/wD0pBP0vPL....
Wallet address: EQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpLoC7W--WbXwxW9m
Public key (hex): f102a5c140272019550b05e6a50b2072aa737dd3c5948622ddf1ca249b6e0f00
```

Next, compare the wallet address with the generated `StateInit`.

```typescript title="address_verification.ts"
import { Address, Cell, contractAddress } from '@ton/ton';

// Your data
const wantedAddress = Address.parse('your address');
const stateInitBase64 = 'your state init'; // Insert your StateInit (base64) here

const cell = Cell.fromBase64(stateInitBase64);
// Typically, code = cell.refs[0], data = cell.refs[1]
const stateInit = {
    code: cell.refs[0],
    data: cell.refs[1],
};

// Derive the address from WorkChain and StateInit
const calculatedAddress = contractAddress(wantedAddress.workChain, stateInit);

console.log('Expected address: ', wantedAddress.toString({ bounceable: false }));
console.log('Calculated address:', calculatedAddress.toString({ bounceable: false }));

if (calculatedAddress.equals(wantedAddress)) {
    console.log('StateInit matches the address!');
} else {
    console.log('StateInit does NOT match the address!');
}

```

#### Expected output

```
Expected address:    UQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpYoC7W--WbXxxTKj
Calculated address: UQD3oTH51Tp4UNhCLfX3axyG2X9H_9wZpYoC7W--WbXxxTKj
StateInit matches the address!
```

#### Real-time transactions monitoring

The example below shows how to set up a listener that receives transaction data as soon as it becomes available.

<details>
  <summary>Code</summary>
  ```typescript title="trxs_monitoring.ts"

  import { Address, TonClient, beginCell, storeMessage } from '@ton/ton';

  // Example function to monitor incoming transactions
  async function monitorIncomingTransactions(walletAddress: Address, client: TonClient) {
    let lastLt = 0n;

    setInterval(async () => {
      try {
        const transactions = await client.getTransactions(walletAddress, {
          limit: 10,
          lt: lastLt.toString(),
    });

        for (const tx of transactions) {
          if (tx.lt > lastLt) {
            const txHash = tx.hash();
            console.log('New transaction:', txHash.toString('hex'));
            const viewerUrl = `https://testnet.tonviewer.com/transaction/${txHash.toString('hex')}`;
            console.log('Transaction link:', viewerUrl);

            // Process incoming messages
            if (tx.inMessage) {
              const msgCell = beginCell().store(storeMessage(tx.inMessage)).endCell();
              const msgHash = msgCell.hash();
              console.log('Message hash:', msgHash.toString('hex'));
          }

            lastLt = tx.lt;
        }
      }
    } catch (error) {
        console.error('Monitoring error:', error);
      }
    }, 5000); // Check every 5 seconds
  }

  const walletAddress = Address.parse('Insert your address here');
  const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC' });

  monitorIncomingTransactions(walletAddress, client);


  ```

  **Expected output**

  ```
  New transaction: 2e995e47f47bb95f1802337f4a63841b93aa8972aabba545048ef286dcc14309
  Transaction link: https://testnet.tonviewer.com/transaction/2e995e47f47bb95f1802337f4a63841b93aa8972aabba545048ef286dcc14309
  Message hash: 8263a63380532154a3850aa1d2dca719bf768845738c8177d889af05826626c8
  ```

  </details>

### Recommendations

1. **Persist hashes**: store the hashes of critical transactions and messages for future reference and tracking.
2. **Use the correct hash type**: use the transaction hash to track execution and the message hash to verify payload integrity.
3. **Account for confirmation time**: in TON, transactions are usually finalized within 3–6 seconds, but this can take longer under a high network load.
4. **Implement retry logic**: if a transaction is not visible on-chain within one minute, consider resubmitting the message.


## Blockchain HTTP API

This section explains how developers can access transaction data from the blockchain.

### TON HTTP API services

An _HTTP API service_ is a software solution that retrieves raw data from a LiteServer node and encodes it into standard formats for other services.
A provider that offers such a solution is referred to as an HTTP API _provider_.

In this section, we review services that are part of the native infrastructure. Most third-party API providers rely on one of these standard solutions.
We recommend evaluating each provider independently based on its [historical performance](https://tonstat.us/) and suitability for your specific use case.


#### TON Center
The TON Center was developed by the TON Core team using the Go stack. It consists of two separate services:
* TON Center API V3: provides blockchain indexing functionality.
* TON Center API V2: optimized for fast read and write operations to the blockchain.

#### TON API
A solution focused on business needs. It often provides ready-made implementations for common tasks in TON.

#### Tonhub API
An alternative opensource HTTP API service with a unique structure different from TON API and TON Center. This interface may be helpful in some specific use cases.

---

### A transaction is part of a block

HTTP services retrieve data from LiteServer nodes and deserialize it according to the TL-B schema.
Data that undergoes minimal post-processing is often referred to as **raw data**. This format is typically used in solutions where architectural priorities favor security and precision over ease of integration or simplicity. These solutions offload the interpretation and analysis of raw data to the client side, allowing for greater control and reliability at the cost of additional local resource consumption.

In contrast, when working with event analytics that does **not** involve significant asset transfers, it is often more efficient to use **high-level interfaces** — such as APIs that apply post-processing before returning results. These interfaces provide simplified, structured data that is easier to work with in most application-level scenarios.

In TON, transactions are bundled into blocks. Finalized BaseChain blocks are committed into MasterChain blocks. To extract transaction data, services must, therefore, read both the MasterChain and the corresponding BaseChain blocks. Additionally, since TON uses **sharding**, each MasterChain block includes references to relevant shard blocks, which must also be parsed. Each shard block contains all transactions associated with that MasterChain block.

All WorkChain blocks follow a consistent structure. For transaction analysis, the relevant section is the `block_extra` field.

```tlb
block#11ef55aa global_id:int32
info:^BlockInfo value_flow:^ValueFlow
state_update:^(MERKLE_UPDATE ShardState)
extra:^BlockExtra = Block;
```
The `block_extra` section of a block contains the `account_blocks` structure,
which in turn includes the transactions processed by all accounts within the corresponding shard.

```tlb
block_extra in_msg_descr:^InMsgDescr
out_msg_descr:^OutMsgDescr
account_blocks:^ShardAccountBlocks
rand_seed:bits256
created_by:bits256
custom:(Maybe ^McBlockExtra) = BlockExtra;
```

Thus, when reading the blockchain, services iteratively process blocks, starting from the most recently read one and proceeding up to the latest finalizedz block. The extracted transactions are considered **raw data** and can be passed to downstream services for further use. Additionally, specialized services may analyze and enrich this data to strike a balance between the complexity and the trustless nature of the system.

#### Account status

Account status indicates the runtime state of an account as it relates to transaction execution, but it is not part of the account’s persistent storage. There are four possible `AccountStatus` values, each encoded as two bits in TL-B:

| Status      | TL-B code | Description                                                                                                                                 |
|-------------|------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| `nonexist`  | `11`       | The account does not exist — no state and no balance.                                                                                       |
| `uninit`    | `00`       | The account exists but is uninitialized — it contains no deployed code or data. It may hold a balance but has not yet been activated.       |
| `frozen`    | `01`       | The account is frozen; only its state hash is retained. It cannot be used.                                                                           |
| `active`    | `10`       | The account includes a `StateInit` with deployed code and data, making it an active smart contract.                                                                  |

An account becomes executable—and is considered a smart contract—when its `StateInit` includes `code`.

:::important
Account status appears only in transactions (`orig_status` and `end_status`) and is **not** part of the account’s persistent data. The actual account state is stored in the `AccountState` structure.
:::

### Approaches to retrieving transactions from Blockchain API

#### Key terms

* **Transaction**: a transaction represents a state change of an account in the blockchain. It is triggered by an incoming message and may optionally result in one or more outgoing messages. Analyzing the contents of a transaction is a fundamental method used across all services.

* **Trace**: a trace is a deterministic graph of all transactions triggered by a single external message. Trace interfaces enable the retrieval of the complete graph associated with a specific transaction, making it easier to analyze all related interactions.
This is especially useful for exchanges and analytical tools to verify asset flows or to reconstruct the logic of a business operation.
Trace can also be used to detect Jetton transfers even in the absence of Jetton notification messages. It is particularly relevant when a business operation spans multiple interdependent transactions.

* **Action**: an action is an aggregated abstraction that represents a complete business operation across one or more account state changes.
For example, transferring Jettons between two users would be represented as a single action.
Actions are used exclusively for visualization and have no role in the actual execution or validation of fund transfers.

---

#### High-Level data analysis

**How to fetch a list of transactions or a single transaction via API**

To fetch transaction data, you can use high-level interfaces such as:
* `get /actions`
* `get  /traces`
* `get /jetton/transfers` and `get /jetton/burns`
* `get /nft`

With this approach, the developer doesn’t need to parse the contents of individual transactions.
This method, which involves no additional data validation, is only suitable when fund transfers are not involved.
In addition to simple service-level checks, this approach can also be used in more advanced scenarios. For example, by using the **traces** method, you can identify all related transactions for further analysis.

---

#### Transaction lookup by message payload

Use `getTransaction` by external or internal message. Available in [API v3](https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_message) only.

This method is beneficial when tracking a small number of accounts (up to ~10).
It works well for wallet-v4 and wallet-v5 transfers and is primarily used to find transactions triggered by external messages.

:::note
There may be a delay of up to 10 seconds.
For better performance in real-time scenarios, consider also monitoring the pending pool.
:::

---

#### Transaction lookup by account address

To query transactions for an account you are monitoring, use [API v2](https://toncenter.com/api/v2/#/accounts/get_transactions_getTransactions_get).
This method is broadly supported, including in LiteClient, and is suitable for tracking up to ~100 accounts.

---

#### Scanning Blockchain for the full set of transactions

When monitoring a large number of accounts (1,000 or more), you need to iterate through all transactions starting from the latest masterchain block.

- **API v2**:
1. Fetch shard information for the MasterChain block
2. Compute shard diffs
3. For each resulting block, call `getBlockTransactionsExt`
See: TON Center cookbook: [How to scan blockchain](https://docs.toncenter.com/docs/ton-center-cookbook#how-to-scan-blockchain)

- **API v3**:
Do not reuse the API v2 logic.
Instead, use the dedicated method:
[GET /transactions/by-masterchain-block](https://toncenter.com/api/v3/index.html#/blockchain/api_v3_get_transactions_by_masterchain_block)

You have a choice: either a straightforward implementation that places a high level of trust in major providers or a more complex one that does not require trusting the provider.
However, for greater security, it is always recommended to process transactions block by block independently.

---

#### Transaction response from API

In the blockchain, a regular transaction consists of a whole body and a unique header.

```tlb
transaction$0111 account_addr:bits256 lt:uint64
    prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
    outmsg_cnt:uint15
    orig_status:AccountStatus end_status:AccountStatus
    ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
    total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
    description:^TransactionDescr = Transaction;
```

The header `TransactionDescr` defines the nature of the transaction in the blockchain. All user-initiated service operations are represented as regular transactions of type **Ordinary**.

```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```
Each transaction returned in the API response (`Transaction[]`) reflects the structure defined in TL-B but often includes additional computed fields for convenience.

* Native – present in the blockchain. The field names match those defined in the `block.tlb` TL-B schema.
* Postprocessing – computed additionally by the API provider.
* Native object with extended fields – the object exists on-chain, but the API provider extends its data. See the table below for details.


One of the **most important computed fields** is the **transaction hash**, which does not exist in the blockchain itself. It is generated by the API provider.

```json
"hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM="
```

### Transaction body TON Center API/v2

The https://toncenter.com/api/v2/getTransactions method returns raw transaction data based on the TL-B structure.

Example `curl` request:

```curl
curl -X 'GET' \
  'https://toncenter.com/api/v2/getTransactions?address=EQAFmjUoZUqKFEBGYFEMbv-m61sFStgAfUR8J6hJDwUU09iT&limit=10&to_lt=0&archival=true' \
  -H 'accept: application/json'
```

The response includes the transaction body, which consists of the following components:

* **@fields** - internal metadata used by the TON Center API/v2.
* **Header data** – transaction metadata such as `lt` (logical time) and `now` (Unix timestamp).
* **Incoming message data** – the message that initiated the transaction.
* **Compute phase data** – execution results.
* **Action phase data** – actions triggered after the compute phase.
* **Block ref** – identifies the blockchain block containing the data transaction.
* **Account state before** –the account state before the transaction.
* **Account state after** – the account state after the transaction.



| Field                  | Origin                        | Description                                                                                                                | Example                                                       |
|------------------------|-------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------|
| `@type`                | Postprocessing                | Object type identifier in API v2.                                                                                          | `"raw.transaction"`               |
| `address.@type`        | Postprocessing                | Postprocessed type of smart contract address.                                                                              | `accountAddress`               |
| `account_address`      | Native                        | Account address where the transaction occurred. Returned in user-friendly format.                                          | `"EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1"` |
| `utime`                | Native                        | UNIX timestamp of the transaction. Corresponds to the TL-B field `now`.                                                    | `1736738146`                                                 |
| `transaction_id.@type` | Postprocessing                | Parsed type of transaction.                                                                                                 | `"internal.transactionId"`                                     |
| `transaction_id.hash`  | Postprocessing                | Hash of the current transaction.                                                                                            | `mkma+u5TOi12BSu6m6YhZaatY2b2ozdabOdBnVuWmWM=`               |
| `transaction_id.lt`    | Native                        | Logical time of the transaction. Unique per account. TL-B field: `lt`.                                                | `52863169000074`                                             |
| `fee`                  | Native                        | Total transaction fee. TL-B field: `total_fees`.                                      | `1207600`                                                   |
| `storage_fee`          | Native                        | Storage fees. TL-B field: `Trans Descriptor` -> `Storage`.                                                                   | `1207600`                                                   |
| `other_fee`            | ?                             | ??                                                                                                                         | `1207600`                                                   |
| `mc_block_seqno`       | Postprocessing                | Sequence number of the MasterChain block containing this transaction. Not stored on-chain. Added by HTTP service.               | `13353447`                                                   |
| `trace_id`             | Postprocessing                | Hash of the root transaction in a trace chain. `trace` is an entity generated by TON Center API v3.                | `13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=`               |
| `prev_trans_hash`      | Native                        | Hash of the previous transaction for this account. TL-B field: `prev_trans_hash`.                                           | `6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=`               |
| `prev_trans_lt`        | Native                        | Logical time of the previous transaction for this account. TL-B field: `prev_trans_lt`.                                     | `15371704000004`                                             |
| `in_msg`               | Native object extended inside | Input message body object.                                                                                                  | `"in_msg": {...}`                                            |
| `"in_msg.message":`    | Postprocessing | Input message body object.                                                                                                  | `"in_msg": {...}`                                            |
| `out_msgs`             | Native object extended inside | Input message body object.                                                                                                  | `"in_msg": {...}`                                            |

```json
 "result": [
    {
      "@type": "raw.transaction",
      "address": {
        "@type": "accountAddress",
        "account_address": "EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1"
      },
      "utime": 1736738146,
      "data": "te6cckECCAEAAc0AA7V9w3z0KEwtB7gb6nlOqTmqEf8+lj2VuFGNc1qCYIayD/AAAwFCpo8orDf2vdoH1n96C0l9c0Xbxq/7Vyj+b1Bsw/jTohWiegygAAMBQqaPKIZ4SFYgADRhy3BoAQIDAgHgBAUAgnJhXUy/QLYxeNcfvOGwlIsucuES8LwAmAcs26m1y9/nJvAc82jOBRqD108rByoN3QmaIBq8NLslDBcjC0wpnrEuASUECTEsgEAQYYpWDgGBBGmYII1qBwCxaAEV97IJPAV1L6qto8QId19JS886Gi89o8RV8ChfpEGhdwA3DfPQoTC0HuBvqeU6pOaoR/z6WPZW4UY1zWoJghrIP9MSyAQABggjWgAAYChUdlcIzwkKtEABAd8GALlYAbhvnoUJhaD3A31PKdUnNUI/59LHsrcKMa5rUEwQ1kH/ACK+9kEngK6l9VW0eIEO6+kpeedDRee0eIq+BQv0iDQu0xJ+T0AGCCNaAABgKFTR5RbPCQrEf////8AAnkD8bD0JAAAAAAMoAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgpUle",
      "transaction_id": {
        "@type": "internal.transactionId",
        "lt": "52863169000074",
        "hash": "mkma+u5TOi12BSu6m6YhZaatY2b2ozdabOdBnVuWmWM="
      },
      "fee": "1207600",
      "storage_fee": "0",
      "other_fee": "1207600",
      "in_msg": {
        ...
      },
      "out_msgs": [ 
        {...}
      ]
    },

]
```

<details>

```json
 "result": [
    {
      "@type": "raw.transaction",
      "address": {
        "@type": "accountAddress",
        "account_address": "EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1"
      },
      "utime": 1736738146,
      "data": "te6cckECCAEAAc0AA7V9w3z0KEwtB7gb6nlOqTmqEf8+lj2VuFGNc1qCYIayD/AAAwFCpo8orDf2vdoH1n96C0l9c0Xbxq/7Vyj+b1Bsw/jTohWiegygAAMBQqaPKIZ4SFYgADRhy3BoAQIDAgHgBAUAgnJhXUy/QLYxeNcfvOGwlIsucuES8LwAmAcs26m1y9/nJvAc82jOBRqD108rByoN3QmaIBq8NLslDBcjC0wpnrEuASUECTEsgEAQYYpWDgGBBGmYII1qBwCxaAEV97IJPAV1L6qto8QId19JS886Gi89o8RV8ChfpEGhdwA3DfPQoTC0HuBvqeU6pOaoR/z6WPZW4UY1zWoJghrIP9MSyAQABggjWgAAYChUdlcIzwkKtEABAd8GALlYAbhvnoUJhaD3A31PKdUnNUI/59LHsrcKMa5rUEwQ1kH/ACK+9kEngK6l9VW0eIEO6+kpeedDRee0eIq+BQv0iDQu0xJ+T0AGCCNaAABgKFTR5RbPCQrEf////8AAnkD8bD0JAAAAAAMoAAAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgpUle",
      "transaction_id": {
        "@type": "internal.transactionId",
        "lt": "52863169000074",
        "hash": "mkma+u5TOi12BSu6m6YhZaatY2b2ozdabOdBnVuWmWM="
      },
      "fee": "1207600",
      "storage_fee": "0",
      "other_fee": "1207600",
      "in_msg": {
        "@type": "raw.message",
        "hash": "wY9HZG8iPissn4t3/nc8bxYqc5kxo+gd7MdkqdrUt0Y=",
        "source": "EQCK-9kEngK6l9VW0eIEO6-kpeedDRee0eIq-BQv0iDQu_Rb",
        "destination": "EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1",
        "value": "3300000000",
        "extra_currencies": [],
        "fwd_fee": "266669",
        "ihr_fee": "0",
        "created_lt": "52863166000004",
        "body_hash": "lqKW0iTyhcZ77pPDD4owkVfw2qNdxbh+QQt4YwoJz8c=",
        "msg_data": {
          "@type": "msg.dataRaw",
          "body": "te6cckEBAQEAAgAAAEysuc0=",
          "init_state": ""
        },
        "message": ""
      },
      "out_msgs": [
        {
          "@type": "raw.message",
          "hash": "n/CmWFQsCB0MZr4RYzpUyxe9khLCCNV1HhNYgh25RlA=",
          "source": "EQDcN89ChMLQe4G-p5Tqk5qhH_PpY9lbhRjXNagmCGsg_9l1",
          "destination": "EQCK-9kEngK6l9VW0eIEO6-kpeedDRee0eIq-BQv0iDQu_Rb",
          "value": "3298792400",
          "extra_currencies": [],
          "fwd_fee": "266669",
          "ihr_fee": "0",
          "created_lt": "52863169000075",
          "body_hash": "2kgTJil7CKGfT/jw1tLMcQJ5ngwOSgK6iXnDY6CA2IY=",
          "msg_data": {
            "@type": "msg.dataRaw",
            "body": "te6cckEBAQEABgAACP/////btDe4",
            "init_state": ""
          },
          "message": "/////w==\n"
        }
      ]
    },

]
```
</details>

### Transaction body TON Center API/v3

The API service deserializes the entire transaction structure with precise mapping to appropriate string and numeric types.
As a result, the transaction body is returned in JSON format.

The https://toncenter.com/api/v3/transactions method returns a large structure enriched with additional computed data.

Example request:



```curl
curl -X 'GET' \
  'https://toncenter.com/api/v3/transactions?limit=10&offset=0&sort=desc' \
  -H 'accept: application/json'
```

The transaction object includes the following key sections:

* **Header data** – transaction metadata such as `lt` (logical time) and `now` (Unix timestamp).
* **Incoming message data** – the message that initiated the transaction.
* **Compute phase data** – execution results.
* **Action phase data** – actions triggered after the compute phase.
* **Block ref** – identifies the blockchain block containing the data transaction.
* **Account state before** –the account state before the transaction.
* **Account state after** – the account state after the transaction.


```json
 {
  "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF",
  "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
  "lt": "15371766000003",
  "now": 1696238450,
  "mc_block_seqno": 13353447,
  "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=",
  "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=",
  "prev_trans_lt": "15371704000004",
  "orig_status": "active",
  "end_status": "active",
  "total_fees": "12446659",
  "description": {
  ...
  },
  "compute_ph": {
   ....
  },
  "action": {
    ...
  },
  "block_ref": {
    ...
  },
  "in_msg": {
  ...
  },
  "out_msgs": [
   ...
  ],

  "account_state_before": {
    ...
  },

  "account_state_after": {
  ...
  }
}

```

<details>
  ```json
  {
    "account": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account of transcation
    "hash": "/QesPZ+FW7Z0MdG/vVDuYR/sK1dWx2Nip6CCDbdqQeM=",
    "lt": "15371766000003", # logical time, may have same values for txs on different accounts but every transaction on a given account will have unique lt
    "now": 1696238450, # unix timestamp
    "mc_block_seqno": 13353447, # seqno of masterchain block
    "trace_id": "13bnlzO0u4ayE5qPXtdSTUikuLaoYJj5HL4GZdBjpfc=", # tx_hash of the root transaction of the trace
    "prev_trans_hash": "6+AzO3VYCnq9PO5ibdHXE5i9VASBo/DS9iYZksVdwuI=", # hash of previous transaction on this account
    "prev_trans_lt": "15371704000004", # lt of prev. transaction
    "orig_status": "active", # account status before transaction
    "end_status": "active", # ... after transaction
    "total_fees": "12446659", # ... sum of fees from description
    "description": {
    "type": "ord",
    "aborted": false,
    "destroyed": false,
    "credit_first": false,
    "storage_ph": {
    "storage_fees_collected": "48",
    "status_change": "unchanged"
  },
    "compute_ph": {
    "skipped": false,
    "success": true,
    "msg_state_used": false,
    "account_activated": false,
    "gas_fees": "8823000",
    "gas_used": "8823",
    "gas_limit": "400000",
    "mode": 0,
    "exit_code": 0,
    "vm_steps": 178,
    "vm_init_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    "vm_final_state_hash": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  },
    "action": {
    "success": true,
    "valid": true,
    "no_funds": false,
    "status_change": "unchanged",
    "total_fwd_fees": "10871000",
    "total_action_fees": "3623611",
    "result_code": 0,
    "tot_actions": 1,
    "spec_actions": 0,
    "skipped_actions": 0,
    "msgs_created": 1,
    "action_list_hash": "9XTNK6e1Fmmhd3cdzI0XcNDYRAoP5f5L4bWPUD3KNIE=",
    "tot_msg_size": {
    "cells": "23",
    "bits": "8377"
  }
  }
  },
    # reference for the block of the transaction
    "block_ref": {
    "workchain": 0,
    "shard": "8000000000000000",
    "seqno": 14627985
  },
    # in message
    "in_msg": {
    "hash": "O9XCuICyXBWOs4hHMOYA0k6o4GPBsWbAkjFi2qbttQE=", # hash of whole message
    "source": "0:F0C9C78F021AC65839B4006321A68BBB32DE5025F84C853CB9D75EB4894D0848", # account who has sended this message
    "destination": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # account who received this message (for in_msg should be same as account of transaction)
    "value": "400000000", # attached TONS
    "fwd_fee": "1494679", # fee for forwarding the message using Hypercube Routing
    "ihr_fee": "0", # fee for forwarding the message throught Instant Hypercube Routing (now IHR is not implemented so this should be added to value)
    "created_lt": "15371766000002", # logical time of creation (usually slightly differs from transaction lt, where this message appears as an out_msg)
    "created_at": "1696238450", # unix timestamp
    "opcode": "0x0f8a7ea5", # opcode
    "ihr_disabled": true,
    "bounce": true, # if bounce should be perfomed on failure
    "bounced": false, # if bounce has happened
    "import_fee": null,
    "message_content": { # message body
    "hash": "tWjTyEL/sabOLNt97uyCj5na740lW54GUcVa0UrSDao=", # hash of the message body
    # message body in base64 format
    "body": "te6cckEBAgEAiAABbQ+KfqUAAAAAdJizmkC/A/doAc9ztfOy5YIoBWjnofpWHchoFtAb/s4FvzXctxUu0Cf0ED8uUQMBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQIjm5Xw==",
    "decoded": null # text comment if it could be decoded
  },
    "init_state": null
  },
    "out_msgs": [
  {
    "hash": "FuV4JPR/uZZOCzZxWQ473bASToqChvKDLmnf5BiCspI=",
    "source": "0:C8F053E2CE6406D3D8FCFA30BA0D0EFC3FD9FE9217DCD50147EB73BFC4EA5BBF", # should coinside with transaction account for out_msg
    "destination": "0:794760D36E657A27CDB8D3D65F243D6B468CAD2C34AF413E7709390E4DBE9907",
    "value": "380306000",
    "fwd_fee": "7247389",
    "ihr_fee": "0",
    "created_lt": "15371766000004",
    "created_at": "1696238450",
    "opcode": "0x178d4519",
    "ihr_disabled": true,
    "bounce": true,
    "bounced": false,
    "import_fee": null,
    "message_content": {
    "hash": "o+VOluS6wdyl44k2AIFTcRBvdxZD/98275dunIWcVIA=",
    "body": "te6cckEBAgEAiAABbReNRRkAAAAAdJizmkC/A/doAeGTjx4ENYywc2gAxkNNF3ZlvKBL8JkKeXOuvWkSmhCQIH5cogYBAJclk4VhgB3j1vChEcRNFz9a4PfQWGcds91PdwGR6Jm4o4muESRZKAJfTMEAPDJx48CGsZYObQAYyGmi7sy3lAl+EyFPLnXXrSJTQhIQPzgXtA==",
    "decoded": null
  },
    # init state in same format as message body
    # needed to deploy a new contract
    "init_state": {
    "hash": "eUdg025leifNuNPWXyQ9a0aMrSw0r0E+dwk5Dk2+mQc=",
    "body": "te6cckECFAEAA4AAAgE0AgEBhwgBz3O187LlgigFaOeh+lYdyGgW0Bv+zgW/Ndy3FS7QJ/UAN1wXvOOOdJfwh7sHnzxnFjjhTeJ04Bmd10caY4RPyrggAgEU/wD0pBP0vPLICwMCAWIEBQICywYHABug9gXaiaH0AfSB9IGoYQIBIAgJAIPSAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVICAUgKCwIBWAwNAMNCDHAJJfBOAB0NMDAXGwlRNfA/AQ4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwDeCCEBeNRRlSILqWMUREA/AO4DWCEFlfB7y6k1nwD+BfBIQX8vCAART6RDBwuvLhTYAfFQPTP/oA+kAh8ALtRND6APpA+kDUMFE2oVIqxwXy4sEowv/y4sJUNEJwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAySD5AHB0yMsCygfL/8nQBPpA9AQx+gAg10nCAPLixHeAGMjLBVAIzxZw+gIXy2sTzIDgIBIA8QAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQD9ztRND6APpA+kDUMAjTP/oAUVGgBfpA+kBTW8cFVHNtcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMn5AHB0yMsCygfL/8nQUA3HBRyx8uLDCvoAUaihggiYloCCCJiWgBK2CKGCCOThwKAYoSfjDyXXCwHDACOAREhMA2ztRND6APpA+kDUMAfTP/oA+kAwUVGhUknHBfLiwSfC//LiwoII5OHAqgAWoBa88uLDghB73ZfeyMsfFcs/UAP6AiLPFgHPFslxgBjIywUkzxZw+gLLaszJgED7AEATyFAE+gJYzxYBzxbMye1UgAHBSeaAYoYIQc2LQnMjLH1Iwyz9Y+gJQB88WUAfPFslxgBDIywUkzxZQBvoCFctqFMzJcfsAECQQIwAOEEkQODdfBAB2wgCwjiGCENUydttwgBDIywVQCM8WUAT6AhbLahLLHxLLP8ly+wCTNWwh4gPIUAT6AljPFgHPFszJ7VTOKoYI",
    "decoded": null
  }
  }
    ],
    # account state before the transaction
    "account_state_before": {
    "hash": "ICpM+dm0PYhxtwS/EnIwMAvOQbtDhVWMnPtMAlw5Dog=", # hash of whole account state
    "balance": "37821399", # balance
    "account_status": "active", # status of account (active, nonexist = deleted, frozen, uninitialized)
    "frozen_hash": null, # hash of state when it became frozen
    "data_hash": "XeSmBiLWvwn00CWu5oq/q9Q6d4luPKxnOWC4NgEeugU=", # hash of data
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc=" # hash of code
  },
    # account state after the transaction
    "account_state_after": {
    "hash": "7vvsHBjy5KoM/rIs6U8nHZt0pYOW5I3oTbBirxVK+Go=",
    "balance": "37821351",
    "account_status": "active",
    "frozen_hash": null,
    "data_hash": "aD0LD2LpPQYYR81n5b/EBHCPYmhBo4soNdvPoTL+xIk=",
    "code_hash": "ITmGtOPGMSaMQ8fGUTxczC5zEmkqfhV7VEQchrqjpGc="
  }
  }
  ```
</details>

Once a developer fetches a dataset of transactions filtered by a specific account or set of accounts, they can process the raw data to extract meaningful events.
For a detailed explanation of how transactions work and how to parse them in different TON contexts, see the [Transactions section](/v3/guidelines/dapps/interact-with-transactions/transaction).

## Transaction {#transaction}

In the TON blockchain, any change to an account's state is recorded via a **transaction**. Unlike messages, transactions do not *move*, *send*, or *receive* anything. These terms are often confused, but it's important to understand that a transaction is simply a **record** of all changes that occurred to a specific account.

### Transaction structure: TL-B

Before diving into how transactions work in TON, we first need to understand their structure using **TL-B**(Type Language – Binary). It's worth noting that there are several types of transactions in TON; however, for this guide, we will focus solely on **ordinary transaction**. These are the transactions relevant for payment processing and the development of most applications built on TON.

```tlb
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;
```

According to the TL-B schema, a transaction consists of the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `credit_first` | `Bool` | Indicates whether the credit phase should be executed first. This depends on whether the [bounce flag](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.cpp#L3530) is set. This will be explained in more detail in a later section.  |
| `storage_ph` | `Maybe TrStoragePhase` | The storage phase, responsible for handling fees related to the account's persistent storage.|
| `credit_ph` | `Maybe TrCreditPhase` | The credit phase, responsible for processing the transfer of value delivered with the incoming message, if it's an internal message (types [#1](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2926) or [#2](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/validator/impl/collator.cpp#L2935)). |
| `compute_ph` | `TrComputePhase` | The compute phase, responsible for executing the smart contract code stored in the account's `code` cell. |
| `action` | `Maybe ^TrActionPhase` | The action phase, responsible for handling any actions generated during the compute phase. |
| `aborted` | `Bool` | Indicates whether the transaction was aborted during one of the phases. If `true`, the transaction was not executed, and changes from the `compute_ph` and `action` phases were not applied.|
| `bounce` | `Maybe TrBouncePhase` | TrBouncePhase	The bounce phase, responsible for handling errors that occurred during the `compute_ph` or `action` phases. |
| `destroyed` | `Bool` | Indicates whether the account was destroyed during the execution of the transaction. |

:::info

Other types of transactions—such as [trans_storage](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L352-L353), [trans_tick_tock](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L355-L357), [trans_split_prepare](https://github.com/ton-blockchain/ton/blob/26761a1d139402ef343081810677d2582c3eff51/crypto/block/block.tlb#L362-L366),  and others—are used for internal events that are invisible to end users. These include shard splitting and merging, tick-tock transactions, etc.

Since they are not relevant to DApp development, we will not cover them in this tutorial.
:::

### Credit phase

This phase is relatively small and straightforward. If you look at the blockchain source code, you’ll see that the main logic of this phase is to **credit the contract’s balance** with the remaining value from the incoming message.

```cpp
  credit_phase->credit = msg_balance_remaining;
  if (!msg_balance_remaining.is_valid()) {
    LOG(ERROR) << "cannot compute the amount to be credited in the credit phase of transaction";
    return false;
  }
  // NB: msg_balance_remaining may be deducted from balance later during bounce phase
  balance += msg_balance_remaining;
  if (!balance.is_valid()) {
    LOG(ERROR) << "cannot credit currency collection to account";
    return false;
  }
```

The credit phase is serialized in TL-B as follows:

```tlb
tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;
```

HThis phase consists of the following two fields:

| Field | Type | Description |
| --- | --- | --- |
| `due_fees_collected` | `Maybe Grams` | The amount of storage fees collected. This field is present if the account has no balance and has accumulated storage. |
| `credit` | `CurrencyCollection` | The amount credited to the account as a result of receiving the incoming message.|


### Storage phase

In this phase, the blockchain processes fees related to the account's persistent storage. Let's start by looking at the TL-B schema:

```tlb
tr_phase_storage$_ storage_fees_collected:Grams
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;
```

This phase contains the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `storage_fees_collected` | `Grams` | The amount of storage fees collected from the account. |
| `storage_fees_due` | `Maybe Grams` | The amount of storage fees that were charged but could not be collected due to insufficient balance. This represents accumulated debt.|
| `status_change` | `AccStatusChange` | The change in the account's status after the transaction is executed. |


The `storage_fees_due` field is of type `Maybe` because it is only present when the account has **insufficient balance** to cover the storage fees. When the account has enough funds, this field is omitted.

The `AccStatusChange` field indicates whether the account's status changed during this phase. For example:
* If the debt exceeds **0.1 TON**, the account becomes [frozen](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L949C11-L953C12).
* If the debt exceeds **1 TON**, the account is [deleted](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L936C11-L946C12).


### Compute phase

The **compute phase** is one of the most complex stages of a transaction. This is where the smart contract code, stored in the account’s state, is executed.

Unlike previous phases, the TL-B definition for the compute phase includes multiple variants.

```tlb
tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;
```

To start, note that the compute phase can be **skipped** entirely. In that case, the reason for skipping is explicitly recorded and can be one of the following:

| Skip reason | Description |
| --- | --- |
| `cskip_no_state` | The smart contract has no state and, therefore, no code, so execution is not possible. |
| `cskip_bad_state` | Raised in two cases: when the `fixed_prefix_length` [field has an invalid value]((https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1721)) or when the `StateInit` provided in the incoming message [does not match the account’s address](https://github.com/ton-blockchain/ton/blob/72056a2261cbb11f7cf0f20b389bcbffe018b1a8/crypto/block/transaction.cpp#L1726).|
| `cskip_no_gas` |The incoming message did not provide enough TON to cover the gas required to execute the smart contract. |
| `cskip_suspended` | The account is frozen, so execution is disabled. This was used to freeze early miner accounts during the stabilization of TON’s tokenomics.|

:::tip
The `fixed_prefix_length` field can be used to specify a fixed prefix for the account address, ensuring that the account resides in a specific shard. This topic is outside the scope of this guide, but more information is available [here](https://github.com/ton-blockchain/ton/blob/master/doc/GlobalVersions.md#anycast-addresses-and-address-rewrite).
:::

Now that we've covered the reasons why the compute phase might be skipped, let's examine what happens when the smart contract code is **executed**. The following fields are used to describe the result:

| Field | Type | Description |
| --- | --- | --- |
| `success` | `Bool` | Indicates whether the compute phase was completed successfully. If `false`, any state changes made during this phase are discarded.|
| `msg_state_used`, `account_activated`, `mode`, `vm_init_state_hash`, `vm_final_state_hash` | - | These fields are currently unused in the blockchain. They are always recorded as zero values. |
| `gas_fees` | `Grams` | The amount of fees paid for executing the smart contract code. |
| `gas_used`, `gas_limit` | `VarUInteger` | The actual amount of gas used and the maximum gas limit set for execution. |
| `gas_credit` | `Maybe (VarUInteger 3)` | Used only in external messages. Since external messages cannot carry TON, a small gas credit is granted to allow the smart contract to start execution and decide whether it wants to continue using its balance. |
| `exit_code` | `int32` | The virtual machine exit code. A value of `0` or `1` (alternative success) indicates successful execution. Any other value means the contract code exited with an error—except in cases where the `commit` instruction was used. **Note:** for convenience, developers often refer to this as the *smart contract exit code*, though this isn’t technically accurate. |
| `exit_arg` | `Maybe int32` | The virtual machine threw an optional argument on failure. Useful for debugging smart contract errors. |
| `vm_steps` | `uint32` | The number of steps executed by the virtual machine during code execution. |

:::tip
The `commit` instruction is used to persist any changes made before it is called, even if an error occurs later in the same phase. These changes will only be rolled back if the **Action phase** fails.
:::

### Action phase

Once the smart contract code has finished executing, the **Action phase** begins. If any actions were created during the compute phase, they are processed at this stage.

There are precisely 4 types of actions in TON:


```tlb
action_send_msg#0ec3c86d mode:(## 8)
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;
```

| Type | Description |
| --- | --- |
| `action_send_msg` | Sends a message. |
| `action_set_code` | Updates the smart contract’s code. |
| `action_reserve_currency` | Reserves a portion of the account’s balance. This is especially useful for gas management. |
| `action_change_library` | Changes the library used by the smart contract.|

These actions are executed *in the order in which they were created* during code execution. A total of up to [255 actions](https://github.com/ton-blockchain/ton/blob/72056a1d139402ef343081810677d2582c3eff51/crypto/block/transaction.h#L165) can be made.

Next, let’s examine the TL-B schema, which defines the structure of the action phase.

```tlb
tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;
```

The action phase includes the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `success` | `Bool` | Indicates whether the action phase was successfully completed. If this value is `false`, all changes made during this phase are discarded. Changes made during the compute phase are also reverted. |
| `valid` | `Bool` | Indicates whether the action phase was valid. If this value is `false`, it means that invalid actions were created during smart contract execution. Each action type has its validity criteria. |
| `no_funds` | `Bool` | Indicates whether there were sufficient funds in the account to execute the actions. If `false`, the action phase was interrupted due to lack of funds. |
| `status_change` | `AccStatusChange` | The change in account status after the action phase. Since account deletion happens through actions (via mode 32), this field may indicate whether the account was deleted. |
| `total_fwd_fees` | `Maybe Grams` | The total amount of forwarding fees paid for messages created during the action phase. |
| `total_action_fees` | `Maybe Grams` | The total amount of fees paid for executing actions. |
| `result_code` | `int32` | The result code of the action execution. A value of `0` means all actions were successfully completed. |
| `result_arg` | `Maybe int32` | An error message is returned in case of an error. Useful for debugging smart contract code.|
| `tot_actions` | `uint16` | Total number of actions created during smart contract execution. |
| `spec_actions` | `uint16` | A number of special actions (all except `action_send_msg`). |
| `skipped_actions` | `uint16` | Number of actions skipped during smart contract execution. Refers to message sends that failed but had the `ignore_errors` flag (value 2) set. |
| `msgs_created` | `uint16` | Number of messages created during action execution.|
| `action_list_hash` | `bits256` | The hash of the action list. |
| `tot_msg_size` | `StorageUsed` | Total size of the messages. |

### Bounce phase

If the **Compute phase** or **Action phase** ends with an error, and the incoming message has the `bounce` flag set, the system triggers the **Bounce phase**.

:::note
For the bounce phase to trigger due to an error in the action phase, the failed action must have **flag 16** set, which enables bounce on error.
:::

```tlb
tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
```

The `tr_phase_bounce_negfunds` type is not used in the current version of the blockchain. The other two types function as follows:

| Type | Description |
| --- | --- |
| `tr_phase_bounce_nofunds` | Indicates that the account does not have enough funds to process the message that should be bounced back to the sender. |
| `tr_phase_bounce_ok` | Indicates that the system successfully processes the bounce and sends the message back to the sender. |

In this phase, `msg_fees` and `fwd_fees` are calculated based on the total forwarding fee `fwd_fees` for the message:
* **One-third** of the fee goes into `msg_fees` and is charged immediately.
* The remaining **two-thirds** go into `fwd_fees`.

### Full transaction body

Now that we've reviewed the transaction header and its description, we can look at what a complete transaction in TON looks like. First, examine the TL-B schema:

```tlb
transaction$0111 account_addr:bits256 lt:uint64
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;
```

This schema shows that a transaction includes the following fields:

| Field | Type | Description |
| --- | --- | --- |
| `account_addr` | `bits256` | The account's address to which the transaction belongs. |
| `lt` | `uint64` | Logical time of the transaction.|
| `prev_trans_hash` | `bits256` | The hash of the previous transaction executed on this account. |
| `prev_trans_lt` | `uint64` | Logical time of the previous transaction on this account. |
| `now` | `uint32` | Time the transaction is created, in Unix timestamp format.|
| `outmsg_cnt` | `uint15` | Number of outbound messages generated during transaction execution. |
| `orig_status` | `AccountStatus` | Account status before the transaction. |
| `end_status` | `AccountStatus` | Account status after the transaction. |
| `in_msg` | `Maybe ^(Message Any)` | Incoming message processed during the transaction. For ordinary transactions, this field is always present. |
| `out_msgs` | `HashmapE 15 ^(Message Any)` | Outgoing messages generated during the transaction. |
| `total_fees` | `CurrencyCollection` | Total fees paid for executing the transaction. |
| `state_update` | `^(HASH_UPDATE Account)` | Contains the hash of the previous account state and the hash of the new state.|
| `description` | `^TransactionDescr` | Transaction description containing execution phase details. We covered this earlier. |


The `orig_status` and `end_status` fields indicate how the account state changes as a result of the transaction. There are 4 possible statuses:

```tlb
acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;
```

### How to retrieve a transaction using api/v2

Among the supported open-source APIs, we can use TON Center [APIv2](https://toncenter.com/api/v2/) and [APIv3](https://toncenter.com/api/v3/index.html#/).
**APIv2** is a more raw version and provides only basic access to blockchain data. To retrieve a transaction, there are two options:

* Use the `/api/v2/getTransactions` endpoint:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="api-v2-get-transaction.ts"
    import axios from 'axios';

    async function main() {
        const client = axios.create({
            baseURL: 'https://toncenter.com/api/v2',
            timeout: 5000,
            headers: {
                'X-Api-Key': 'put your api key', // you can get an api key from @tonapibot bot in Telegram
            },
        });

        const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
        const response = await client.get('/getTransactions', {
            params: {
                address: address,
                limit: 1,
                to_lt: 0,
                archival: false,
            },
            headers: {
                'X-Api-Key': 'put your api key', // you can get an api key from @tonapibot bot in Telegram
            },
        });
        console.log(response.data);
    }

    main().finally(() => console.log('Exiting...'));

    ```

  </TabItem>
</Tabs>


* Use the `JSON-RPC` protocol:

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="json-rpc-protocol.ts"
    import { Address, TonClient } from '@ton/ton';

    async function main() {
        const client = new TonClient({
            endpoint: 'https://toncenter.com/api/v2/jsonRPC',
            apiKey: 'put your api key', // you can get an api key from @tonapibot bot in Telegram
        });

        const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
        const response = await client.getTransactions(address, {
            limit: 1,
        });
        console.log(response[0]);
    }

    main().finally(() => console.log('Exiting...'));

    ```

  </TabItem>
</Tabs>


The recommended approach is to use **JSON-RPC**, as it integrates with existing SDKs, where all fields are predefined and typed correctly. This removes the need to interpret each field manually.

:::note
When retrieving transactions, you might encounter the following error:
`LITE_SERVER_UNKNOWN: cannot compute block with specified transaction: cannot find block (0,ca6e321c7cce9ece) lt=57674065000003: lt not in db.`

This means the account’s transactions are old, and the blocks containing them are no longer stored on the LiteServer. In this case, you can use the option `archival: true` to fetch data from an archival node.
:::

### How to retrieve a transaction using api/v3

`APIv3` is more advanced and convenient for retrieving various events from the blockchain. For example, it allows you to fetch information about NFT transfers, token operations, and even transactions in `pending` status. In this tutorial, we'll focus only on the `transactions` endpoint, which returns finalized transactions:


**APIv3** is more advanced and convenient for accessing various types of blockchain events. For example, it allows you to retrieve data on NFT transfers, token movements, and even transactions that are still in the **pending** state.

In this guide, we focus only on the `transactions` endpoint, which returns *confirmed* transactions.

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="api-v3-get-transaction.ts"
    import axios from 'axios';

    async function main() {
        const client = axios.create({
            baseURL: 'https://toncenter.com/api/v3',
            timeout: 5000,
            headers: {
                'X-Api-Key': 'put your api key', // you can get an api key from @tonapibot bot in Telegram
            },
        });

        const address = 'UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA';
        const response = await client.get('/transactions', {
            params: {
                account: address,
                limit: 1,
                to_lt: 0,
                archival: false,
            },
        });
        console.log(response.data.transactions[0]);
  }

    main().finally(() => console.log('Exiting...'));

    ```

  </TabItem>
</Tabs>

If you examine the response, you’ll see that it differs significantly from the APIv2 output. The key difference is that APIv3 **indexes** transactions, while the previous version acts only as a wrapper around LiteServer. In API v3, all information comes directly from the server’s database.

This allows the API to return preprocessed data. For example, if you examine the `account_state_before` and `account_state_after` fields, they include not only the account state hash but also complete data, such as the code, data, TON balance, and even the ExtraCurrency balance.


```json
[
  account_state_before: {
    hash: 'Rljfqi3l3198Fok7x1lyf9OlT5jcVRae7muNhaOyqNQ=',
    balance: '235884286762',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: 'uUe+xBA4prK3EyIJ8iBk8unWktT4Grj+abz4LF2opX0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  },
  account_state_after: {
    hash: 'asmytWJakUpuVVYtuSMgwjmlZefj5tV5AgnWgGYP+Qo=',
    balance: '225825734714',
    extra_currencies: {},
    account_status: 'active',
    frozen_hash: null,
    data_hash: '6L0wUi1S55GRvdizozJj2GkCqjKSx8iK7dEHlTOe8d0=',
    code_hash: '/rX/aCDi/w2Ug+fg1iyBfYRniftK5YDIeIZtlZ2r1cA='
  }
]
```

Additionally, the response includes an `address_book` field, which contains an array of addresses the account interacted with during transaction execution.

### Transaction fields in the SDK

When inspecting the response returned via the JSON-RPC protocol in `@ton/ton@`, you may notice two additional fields — `hash` and `raw` — that are not part of the on-chain transaction data. The SDK adds these fields for convenience.

* The `hash` field provides a function that lets you compute the transaction hash.
* The `raw` field contains the transaction BOC, which you can parse yourself using either a built-in method from the SDK or manually.


<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="trx-fields-sdk.ts"
    import { Address, loadTransaction, TonClient } from '@ton/ton';

    async function main() {
        const client = new TonClient({
            endpoint: "https://toncenter.com/api/v2/jsonRPC",
            apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
        });

        const address = Address.parse('UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA');
        const response = await client.getTransactions(address, {
            limit: 1,
        });

        const transaction = response[0];
        console.log(loadTransaction(transaction.raw.beginParse()));
        console.log(`Transaction hash: ${transaction.hash().toString('hex')}`);
    }

    main().finally(() => console.log("Exiting..."));
    ```
  </TabItem>
</Tabs>


### Which API to use?

After reviewing both API v2 and API v3, a natural question is which one to choose, the answer depends entirely on your specific use case.
As a general recommendation, you can use the `JSON-RPC` protocol from APIv2 since it allows you to rely on an existing SDK that already provides all the necessary methods and types.

If this functionality does not cover all your requirements, you should consider a full or partial transition to API v3 or explore other APIs in the ecosystem that may offer more data.

### Action: User Context (a.k.a. Event)

Before moving on to user operations and their processing, let’s summarize what we’ve learned about transactions:

* A **transaction** is a record that captures all changes applied to a specific account.
* A transaction consists of multiple **phases** that handle incoming messages, execute smart contract code, and process generated actions.
* Each phase has its description that contains information about what occurred during execution.
* A transaction may complete successfully or fail, depending on whether all phases execute correctly and whether valid actions are created.
* Regular transactions always include an incoming message but may not include any outgoing messages.
* A transaction can be retrieved using **API v2** or **API v3**, both of which return transaction data in a convenient format.
* In API v3, transactions are **indexed**, which allows access to preprocessed data, whereas API v2 acts only as a **wrapper** for communicating with LiteServer.
* The SDK may include additional fields, such as `hash` and `raw`, for convenience. These fields allow you to obtain the transaction hash and BoC, respectively.


Earlier, we discussed **actions** from a technical perspective. However, many API services use this term to refer to user-level operations. It's essential to note that TON is an asynchronous blockchain, meaning that a single operation can span multiple transactions. In this context, the overall sequence matters more than individual transactions.

For example, transferring Jettons from one wallet to another typically involves at least three separate transactions. Different services refer to these sequences using terms like **action**, **event**, or **operation**. To avoid confusion with the previously defined technical term **action**, we use the term **Event** here.


:::tip
Note that not every Jetton transfer qualifies as a `Jetton Transfer Event`. For instance, sending Jettons to a DEX to receive other tokens is classified as a `Swap Event`.

The classification depends heavily on how Jettons are used. API services typically parse the `forward_payload` and check additional parameters to determine the exact type of operation, then present it in a user-friendly format.
This approach applies not only to Jettons but also to NFTs and other on-chain operations.
:::

### Event success in the ecosystem: ordinary TON transfer

As discussed earlier, everything in TON happens asynchronously. This means that the success of a single transaction does not guarantee that the entire chain of related transactions has completed—or will complete—successfully. As a result, we need to rely on more abstract criteria for determining success.

Let’s take a basic example: an ordinary TON transfer from one wallet to another. This operation involves two transactions:

1. The sender’s wallet receives an external message containing a signature for verification. After validating this message, the sender’s smart contract creates outbound messages as specified in the body of the external message.
2. The recipient’s wallet receives an inbound message containing the specified amount of TON.

To determine whether the transfer was successful, we should focus on the second transaction. If the recipient’s account has a transaction initiated by an inbound message from our wallet—and the funds weren’t subsequently returned (this scenario will be covered below)—we can consider the transfer successful.

Suppose we want to monitor deposits sent to our wallet:
`UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL`
For simplicity, we’ll use **APIv3** to fetch the latest 10 transactions for this account.


<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="ton-transfer.ts"
    import { fromNano } from '@ton/core';
    import axios from 'axios';

    async function main() {
        const client = axios.create({
            baseURL: 'https://toncenter.com/api/v3',
            timeout: 5000,
            headers: {
                'X-Api-Key': 'put your api key' // you can get an api key from @tonapibot bot in Telegram
            },
        });

        const address = 'UQDHkdee26bn3ezu3cpoXxPtWax_V6GtKU80Oc4fqa5brTkL';
        const response = await client.get('/transactions', {
            params: {
                account: address,
                limit: 10,
                to_lt: 0,
                archival: false
            },
        });

        for (const transaction of response.data.transactions) {
            const description = transaction.description;
            if (description.type !== 'ord') {
                continue;
            }

            const inMsg = transaction.in_msg;
            if (inMsg.created_lt === null) {
                continue; // Skip external messages
            }
            const bouncePhase = description.bounce;

            if (bouncePhase && bouncePhase.type === 'ok') {
                console.log(`Fake deposit detected: ${transaction.hash}`);
                continue;
            }

            console.log(`Deposit detected: ${transaction.hash}. Value: ${fromNano(inMsg.value)} TON.`);
      }
    }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>


After retrieving the transactions, we need to perform the following checks:

1. The transaction must be ordinary, meaning `description.type` should be equal to `ord`.
2. The inbound message must be **internal**. This means the `created_lt` field must be present.
3. If the transaction description includes a `bounce` field (specific to the `transactions` endpoint in APIv3), it indicates that the **bounce phase** was triggered. In that case, we must check whether the bounce was completed successfully, which means the funds were returned to the sender.

If all these conditions are met, we can consider the deposit successfully credited to the wallet.


:::danger
Please note that the provided code is a simplified example and does not constitute a complete deposit tracking solution.
In real applications, you should not limit the check to just the latest 10 transactions.
Instead, you must process all transactions that occurred since the last check.

Additionally, note that field values for fake deposits may vary depending on the API service used. This example only reflects the APIv3 response from the TON Center `transactions` endpoint.
:::

If we run this code, the expected output is:

```
Fake deposit detected: 4vXGhdvtfgFx8tkkaL17POhOwrUZq3sQDVSdNpW+Duk=
```

By inspecting this transaction in the [explorer](https://tonviewer.com/transaction/e2f5c685dbed7e0171f2d92468bd7b3ce84ec2b519ab7b100d549d3695be0ee9), we see that the funds return to the sender.

:::note
If we query this account’s transactions using APIv2, we don’t see any transactions. This happens because the transaction data exists only in the block, and only the APIv3 indexer captures it.

Since the account has no state at all—not even a single balance top-up—there are no transactions formally associated with it. If there is at least one deposit, the state changes from `nonexist` to `uninit`, and APIv2 then returns the transaction.
:::

### Event success in the ecosystem: Jetton transfer

Now, let’s look at a more complex example involving a Jetton transfer. First, consider the typical structure of a Jetton Transfer:

```
external_in → User_A → internal (op::jetton_transfer)
internal (op::jetton_transfer) → User_A_Jetton_Wallet → internal (op::internal_transfer)
internal (op::internal_transfer) → User_B_Jetton_Wallet
```

As shown, this operation involves **three transactions**, and the actual Jetton transfer is completed only after the **third transaction** is successfully finished. After the third transaction, the following additional messages may be sent:

* `internal (op::jetton_transfer_notification) → User_B` — if `forward_amount` is set
* `internal (op::excesses) → response_destination` — if `response_destination` is set

However, to verify the transfer, we only need to check the third transaction.
To simplify the example, assume we want to track incoming Jettons for a specific wallet:
`EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX` — for the USDT Jetton.


<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    <details>
      <summary>
        Source code
      </summary>

      ```js title="jetton-transfer.ts"
    import { Address, TonClient } from '@ton/ton';

    // Changed version of
    // https://github.com/ton-org/ton-core/blob/b2e781f67b41958e4fde0440752a27c168602717/src/utils/convert.ts#L69C1-L96C2
    export function fromMicro(src: bigint | number | string) {
        let v = BigInt(src);
        let neg = false;
        if (v < 0) {
            neg = true;
            v = -v;
        }

        // Convert fraction
        let frac = v % 1000000n;
        let facStr = frac.toString();
        while (facStr.length < 6) {
            facStr = '0' + facStr;
        }
        facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)![1];

        // Convert whole
        let whole = v / 1000000n;
        let wholeStr = whole.toString();

        // Value
        let value = `${wholeStr}${facStr === '0' ? '' : `.${facStr}`}`;
        if (neg) {
            value = '-' + value;
        }

        return value;
    }

    async function main() {
        const client = new TonClient({
            endpoint: 'https://toncenter.com/api/v2/jsonRPC',
            apiKey: 'put your api key', // you can get an api key from @tonapibot bot in Telegram
        });

        const address = Address.parse('EQBkR-F5h4F2sF-b4ZIE59unSvnqefxi2nWm7JBLGhV9FCPX');
        const response = await client.getTransactions(address, {
            limit: 10,
            archival: true,
        });

        for (const transaction of response) {
            if (transaction.description.type !== 'generic') {
                continue;
            }

            // Check if the compute phase is present and successful
            if (transaction.description.computePhase.type !== 'vm') {
                continue;
            }
            if (transaction.description.computePhase.exitCode !== 0) {
                continue;
            }

            // Check if the action phase is present and successful
            if (transaction.description.actionPhase && transaction.description.actionPhase.resultCode !== 0) {
                continue;
            }

            if (transaction.description.aborted === true) {
                continue;
            }

            if (!transaction.inMessage || transaction.inMessage.info.type !== 'internal') {
                continue;
            }

            const body = transaction.inMessage.body.beginParse();
            try {
                /*
                internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                         response_address:MsgAddress
                         forward_ton_amount:(VarUInteger 16)
                         forward_payload:(Either Cell ^Cell)
                         = InternalMsgBody;
                */

                const op = body.loadUint(32);
                if (op !== 0x178d4519) {
                    // op::internal_transfer
                    continue;
                }
                const queryId = body.loadUintBig(64);
                const amount = body.loadCoins();
                const from = body.loadAddress();
                const responseAddress = body.loadMaybeAddress();
                const forwardTonAmount = body.loadCoins();
                const eitherForwardPayload = body.loadBoolean();
                const forwardPayload = eitherForwardPayload ? body.loadRef() : body.asCell();

                console.log(`Deposit detected:
        Transaction hash: ${transaction.hash().toString('hex')}
        Query ID: ${queryId}
        Amount: ${fromMicro(amount)} USDT
        From: ${from.toString({ testOnly: true })}
        Response Address: ${responseAddress ? responseAddress.toString({ testOnly: true }) : 'None'}
        Forward TON Amount: ${forwardTonAmount.toString()} TON
        Forward Payload: ${forwardPayload.toBoc().toString('hex')}`);
            } catch (e) {
                  console.error(`Error processing transaction ${transaction.hash().toString('hex')}:`, e);
            }
        }
    }

    main().finally(() => console.log('Exiting...'));

      ```

    </details>

  </TabItem>
</Tabs>


First, we fetch the latest 10 transactions for the USDT Jetton Wallet smart contract. Then, we check the following conditions:
1. The transaction must be **ordinary**, meaning `description.type` is equal to `generic`.
2. The **compute phase** must be successful:
* `description.computePhase.type` is `vm`
* `description.computePhase.exitCode` is `0`
3. If an **action phase** is present, it must also be successful:
* `description.actionPhase.resultCode` is `0`
4. The **inbound message** must be internal:
* `inMessage.info.type` is `internal`
5. The **body** of the inbound message must contain an `internal_transfer` operation:
* `body.loadUint(32)` returns `0x178d4519`

If all checks pass, we consider the deposit successfully credited to the wallet.
To parse the body of the inbound message, we use the TL-B schema defined in [TEP-0074](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md):


```tlb
internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                     response_address:MsgAddress
                     forward_ton_amount:(VarUInteger 16)
                     forward_payload:(Either Cell ^Cell)
                     = InternalMsgBody;
```

:::note
Note that this is a highly simplified example.
Real applications may implement different logic for handling deposits.
For more details on how to process such events, refer to the [dedicated article](/v3/guidelines/dapps/asset-processing/jettons).
:::

### Event success in the ecosystem: NFT transfer

An NFT is a smart contract that stores content.
This can be either [the content itself or a link to it, such as a URL](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md).

The contract also stores the owner’s address. Transferring an NFT means updating this address field.
To initiate the transfer, the owner must send a special message formatted according to the [TL-B schema](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#tl-b-schema) defined in [TEP-0062](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md):

```tlb
transfer query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)  forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)  = InternalMsgBody;
```

This process is similar to Jetton transfers, with one key difference: the event is considered successful if the owner address field changes to the expected value.

If `response_destination` is provided, any remaining funds are returned to that address:

```tlb
excesses query_id:uint64 = InternalMsgBody;
```

If `forward_amount` is set, the specified amount of TON and `forward_payload` are sent to the new NFT owner:

```tlb
ownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody;
```

The `custom_payload` field is not needed in standard NFTs. It exists to support more complex NFT contracts
that may require passing additional data without breaking compatibility with the standard.

To retrieve the current owner of an NFT, we use the `get_nft_data` GET method:

```func
(int, int, slice, slice, cell) get_nft_data() method_id {
  (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
  return (init?, index, collection_address, owner_address, content);
}
```

This means we don’t need to parse transactions or perform complex validation.
We call the method and check the owner's address.

<Tabs groupId="code-examples">
  <TabItem value="js" label="JavaScript">

    ```js title="nft-transfer.ts"
    import { Address } from '@ton/core';
    import { TonClient } from '@ton/ton';

    async function main() {
        const client = new TonClient({
            endpoint: "https://toncenter.com/api/v2/jsonRPC",
            apiKey: "put your api key", // you can get an api key from @tonapibot bot in Telegram
        });

        const nftAddress = Address.parse('EQB9Jp075VrO2IXDPEqdxGb_3lBOkKXpvRYV1zFvYp-UVMUY');
        const result = await client.runMethod(nftAddress, 'get_nft_data', []);
        result.stack.skip(3); // init?, index, collection_address
        const nftOwner = result.stack.readAddress();
        console.log(`NFT owner: ${nftOwner.toString()}`);
    }

    main().finally(() => console.log("Exiting..."));
    ```

  </TabItem>
</Tabs>


:::note
As with the previous two examples, please note that this is a simplified scenario. In real-world applications, the system is more complex overall. For more detailed information, refer to the [dedicated article](/v3/guidelines/dapps/asset-processing/nft-processing/nfts).
:::

### How to analyze a contract and its TL-B schema to define success criteria

In this section, we utilize the [Jetton Wallet contract source code](https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-wallet.fc) and its [TL-B schema](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#tl-b-schema) to determine what needs to be verified to confirm that an operation has fully completed successfully.

To do this, we first analyze the available operations in the contract at a high level.

```func
  if (op == op::transfer()) { ;; outgoing transfer
    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
    return ();
  }

  if (op == op::internal_transfer()) { ;; incoming transfer
    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
    return ();
  }
```

In this code, we see two operations related to sending and receiving Jettons:
1. `op::transfer` — the operation used when sending Jettons. It calls the `send_tokens` function, which handles transferring Jettons to another wallet.
2. `op::internal_transfer` — the operation used when receiving Jettons. It calls the `receive_tokens` function, which handles accepting Jettons into the wallet.

Let’s start by examining the sending process. First, we look at the structure of the inbound message:

```tlb
transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
           response_destination:MsgAddress custom_payload:(Maybe ^Cell)
           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;
```

We can see that this message is quite similar to the `internal_transfer` operation we examined earlier. It specifies the recipient, the amount of Jettons to send, the address for returning any remaining funds, and an optional payload to forward to the Jetton recipient.

Now let’s look at the `send_tokens` function, which handles sending Jettons:

<details>
  <summary>

    `send_tokens` function

  </summary>

  ```func
  () send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  slice to_owner_address = in_msg_body~load_msg_addr();
  force_chain(to_owner_address);
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  balance -= jetton_amount;

  throw_unless(705, equal_slices(owner_address, sender_address));
  throw_unless(706, balance >= 0);

  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);
  slice to_wallet_address = calculate_jetton_wallet_address(state_init);
  slice response_address = in_msg_body~load_msg_addr();
  cell custom_payload = in_msg_body~load_dict();
  int forward_ton_amount = in_msg_body~load_coins();
  throw_unless(708, slice_bits(in_msg_body) >= 1);
  slice either_forward_payload = in_msg_body;
  var msg = begin_cell()
  .store_uint(0x18, 6)
  .store_slice(to_wallet_address)
  .store_coins(0)
  .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
  .store_ref(state_init);
  var msg_body = begin_cell()
  .store_uint(op::internal_transfer(), 32)
  .store_uint(query_id, 64)
  .store_coins(jetton_amount)
  .store_slice(owner_address)
  .store_slice(response_address)
  .store_coins(forward_ton_amount)
  .store_slice(either_forward_payload)
  .end_cell();

  msg = msg.store_ref(msg_body);
  int fwd_count = forward_ton_amount ? 2 : 1;
  throw_unless(709, msg_value >
  forward_ton_amount +
  ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response
  ;; but last one is optional (it is ok if it fails)
  fwd_count * fwd_fee +
  (2 * gas_consumption() + min_tons_for_storage()));
  ;; universal message send fee calculation may be activated here
  ;; by using this instead of fwd_fee
  ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)

  send_raw_message(msg.end_cell(), 64); ;; revert on errors
  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

  ```

</details>

Although the code may seem complex at first glance, its logic is straightforward:
1. The required fields are read from `in_msg_body`, which represents the body of the inbound message.
2. Based on these fields, the contract verifies that the sender is the token owner and that the balance is sufficient for the transfer.
3. Using the recipient’s address, it computes the address of the recipient’s Jetton wallet.
4. It ensures that the inbound message includes sufficient TON to cover the gas fees for the transfer (and for a possible refund in case of failure), as well as for delivering the `forward_payload`, if applicable.
5. The contract constructs a message to be sent to the recipient’s Jetton wallet. This message includes the `internal_transfer` operation we’ve already seen.
6. Finally, the contract updates its storage.

Now, let’s examine the receiving side:

<details>
  <summary>

    `receive_tokens` function

  </summary>

  ```func

  () receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
  ;; NOTE we can not allow fails in action phase since in that case there will be
  ;; no bounce. Thus check and throw in computation phase.
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  balance += jetton_amount;
  slice from_address = in_msg_body~load_msg_addr();
  slice response_address = in_msg_body~load_msg_addr();
  throw_unless(707,
  equal_slices(jetton_master_address, sender_address)
  |
  equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)
  );
  int forward_ton_amount = in_msg_body~load_coins();

  int ton_balance_before_msg = my_ton_balance - msg_value;
  int storage_fee = min_tons_for_storage() - min(ton_balance_before_msg, min_tons_for_storage());
  msg_value -= (storage_fee + gas_consumption());
  if(forward_ton_amount) {
  msg_value -= (forward_ton_amount + fwd_fee);
  slice either_forward_payload = in_msg_body;

  var msg_body = begin_cell()
  .store_uint(op::transfer_notification(), 32)
  .store_uint(query_id, 64)
  .store_coins(jetton_amount)
  .store_slice(from_address)
  .store_slice(either_forward_payload)
  .end_cell();

  var msg = begin_cell()
  .store_uint(0x10, 6) ;; we should not bounce here cause receiver can have uninitialized contract
  .store_slice(owner_address)
  .store_coins(forward_ton_amount)
  .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
  .store_ref(msg_body);

  send_raw_message(msg.end_cell(), 1);
}

  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
  var msg = begin_cell()
  .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000
  .store_slice(response_address)
  .store_coins(msg_value)
  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
  .store_uint(op::excesses(), 32)
  .store_uint(query_id, 64);
  send_raw_message(msg.end_cell(), 2);
}

  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}

  ```

</details>

In this function, we observe the following:

1. The contract reads the required fields from the body of the inbound message.
2. It increases the Jetton balance counter by the specified amount.
3. It verifies that the sender is either a valid Jetton wallet or the Jetton master.
4. It performs some calculations for gas management to account for storage fees.
5. If the message specifies a `forward_ton_amount`, the contract creates a message to forward the specified amount of TON and payload to the final Jetton recipient.
6. If a `response_address` is specified, the contract creates a message to send the remaining funds to that address.

From this, we know that the recipient’s balance increases only if the transaction initiated by the `internal_transfer` message completes successfully.
If an error occurs, the contract generates a bounce message that is sent to the recipient’s Jetton wallet.

Looking at the contract code, we can see that it explicitly handles such bounce messages:


```func
slice cs = in_msg_full.begin_parse();
int flags = cs~load_uint(4);
if (flags & 1) {
  on_bounce(in_msg_body);
  return ();
}
```

When the contract receives a bounce message, it calls the `on_bounce` function.

```func
() on_bounce (slice in_msg_body) impure {
  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF
  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  int op = in_msg_body~load_uint(32);
  throw_unless(709, (op == op::internal_transfer()) | (op == op::burn_notification()));
  int query_id = in_msg_body~load_uint(64);
  int jetton_amount = in_msg_body~load_coins();
  balance += jetton_amount;
  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}
```

In this case, the contract restores the Jettons back to the balance.
There is no need to verify the sender of the message since bounce messages cannot be forged.
If such a message is received, it means the contract previously sent a message with the specified content. Therefore, it safely reads the Jetton amount and adds it back to the balance.