import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Project structure

> **Summary:** In previous steps we installed and configured all tools required for TON smart-contract development and created our first project template. Before we proceed to research and modification of smart-contract code, let's take a brief look at project structure, purpose of them and default scenarios of its use.

## Overview

If you chose proposed names in previous steps your project structure should look like this:

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```
Example/
├── contracts/           # Folder containing smart contracts code
│   ├── imports/         # Library imports for contracts
│   │   └── stdlib.fc    # Standard library for FunC
│   └── hello_world.fc   # Main contract file
├── scripts/             # Deployment and on-chain interaction scripts
│   ├── deployHelloWorld.ts     # Script to deploy the contract
│   └── incrementHelloWorld.ts  # Script to interact with the contract
├── tests/               # Test folder for local contract testing
│   └── HelloWorld.spec.ts      # Test specifications for the contract
└── wrappers/            # TypeScript wrappers for contract interaction
    ├── HelloWorld.ts           # Wrapper class for smart contract
    └── HelloWorld.compile.ts   # Script for contract compilation
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```
Example/
├── contracts/           # Folder containing smart contracts code
│   └── hello_world.tolk # Main contract file
├── scripts/             # Deployment and on-chain interaction scripts
│   ├── deployHelloWorld.ts     # Script to deploy the contract
│   └── incrementHelloWorld.ts  # Script to interact with the contract
├── tests/               # Test folder for local contract testing
│   └── HelloWorld.spec.ts      # Test specifications for the contract
└── wrappers/            # TypeScript wrappers for contract interaction
    ├── HelloWorld.ts           # Wrapper class for smart contract
    └── HelloWorld.compile.ts   # Script for contract compilation
```
</TabItem>
</Tabs>

Before we proceed to actual smart-contract development let's briefly describe project structure and explain how to use **`Blueprint SDK`**.

### `/contracts`

This folder contains your smart contract source code written in one of the available programming languages used for TON blockchain smart contract development. And in case of `FunC` contains imports folder which is used for libraries usually containing `stdlib.fc` - standard library of `FunC` language.

:::info Advanced, Internals
When we discussed available for smart-contract development programming languages we allowed ourselves a little lie. There are actually two more languages - `Fift` and `TVM-assembly`(for jedi smart-contract programmers). First one is general-purpose language like the ones that we discussed before, that is just not widely used right now. Second one - is classical assembler representing TVM instructions that you can directly access through assembler insertions in high-level languages.

Common concept of TON smart-contract ecosystem is somewhat similar to **Java**. Smart-contracts written in one of the general-purpose languages are compiled in [TVM](/v3/documentation/tvm/tvm-overview)(TON virtual machine) `byte-code`, the one that we have seen in explorer section of getting started article and then are executed on virtual machine during transaction.
:::

### `/wrappers`

- `HelloWorld.ts` - wrapper for smart contract.
- `HelloWorld.compile.ts` - compile config for smart-contract.

While `@ton/ton SDK` provides us interfaces of serializing and sending messages for standard smart-contracts such as `wallets`, if we develop our own smart-contract that will deserialize received messages by its own custom protocol we need to provide some wrapper object that will serialize messages sent to smart-contract, deserialize responses from `get method`s and serialize `initial data` for contract deployment.

To run compile script excute this command in your CLI:

```bash
npx blueprint build
```

It's preferred development flow to edit smart contract code and then edit its wrapper correspondingly to updated protocol.

:::info Advanced, TL-B
Often, as a developer, you want to provide description of protocol by some formal language and TON ecosystem has standard instrument for that: [TL-B](/v3/documentation/data-formats/tlb/tl-b-language) language. `TL-B`(Type Language-Binary) schemes serve to describe binary protocol of smart-contracts somewhat similar to **Protobuf** technology. At the current moment, unfortunately, there are no instruments that provide generation of serialization/deserialization interfaces, but it's anyway a good practice to have one for smart-contracts with complex interfaces.
:::

### `/tests`

This directory contains test files for your smart contracts, written using the **`Jest` testing framework**. It's testing playground that uses `@ton/sandbox` tool allowing you to execute multiple smart-contracts and even send messages between them, creating your local 'network' of contracts if your project requires so, and test more complex scenarios than simple **unit-tests**. Tests are crucial for ensuring your smart contracts behave as expected before deployment to the `Mainnet`.

To run your test execute following command: 

```bash
npx blueprint build
```

Or use interface provided by `Jest` plugins in your **IDE** or **code-editor**.

### `/scripts`

The scripts directory contains `TypeScript` files that help you deploy and interact with your smart contracts on-chain using previously implemented wrappers.

You can execute those scripts using following command, but we recommend to read corresponding [deployment section](/ref/to/deployment/section) first.

```bash
npx blueprint run 
```

Also, you can always generate same structure for another smart-contract if you need so, by using following command:

```bash
npx blueprint create PascalCase //dont forget to name contract in PascalCase
```

