import Feedback from "@site/src/components/Feedback";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/components/button'

# Blueprint overview

> **Summary:** In the previous steps, we installed and configured all the tools required for TON smart contract development and created our first project template.

Before we proceed to actual smart contract development, let's briefly describe the project structure and explain how to use the **`Blueprint`**.

## Project structure

:::warning
If you didn't choose the proposed names in the previous steps, source code file names and some of the in-code entities may differ.
:::

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```ls title="Project structure"
Example/
├── contracts/           # Folder containing smart contracts code
│   ├── imports/         # Library imports for contracts
│   │   └── stdlib.fc    # Standard library for FunC
│   └── hello_world.fc   # Main contract file
├── scripts/             # Deployment and on-chain interaction scripts
│   ├── deployHelloWorld.ts     # Script to deploy the contract
│   └── incrementHelloWorld.ts  # Script to interact with the contract
├── tests/               # Test folder for local contract testing
│   └── HelloWorld.spec.ts      # Test specifications for the contract
└── wrappers/            # TypeScript wrappers for contract interaction
    ├── HelloWorld.ts           # Wrapper class for smart contract
    └── HelloWorld.compile.ts   # Script for contract compilation
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```ls title="Project structure"
Example/
├── contracts/           # Folder containing smart contracts code
│   └── hello_world.tolk # Main contract file
├── scripts/             # Deployment and on-chain interaction scripts
│   ├── deployHelloWorld.ts     # Script to deploy the contract
│   └── incrementHelloWorld.ts  # Script to interact with the contract
├── tests/               # Test folder for local contract testing
│   └── HelloWorld.spec.ts      # Test specifications for the contract
└── wrappers/            # TypeScript wrappers for contract interaction
    ├── HelloWorld.ts           # Wrapper class for smart contract
    └── HelloWorld.compile.ts   # Script for contract compilation
```
</TabItem>
</Tabs>

### `/contracts`

This folder contains your smart contract source code written in one of the available programming languages used for TON Blockchain smart contract development.

### `/scripts`

The `scripts` directory contains `TypeScript` files that help you deploy and interact with your smart contracts on-chain using previously implemented wrappers.

### `/tests`

This directory contains test files for your smart contracts. Testing contracts directly on the TON network is not the best option because deployment requires some amount of time and may lead to losing funds. This testing playground allows you to execute multiple smart contracts and even send messages between them in your **"local network"**. Tests are crucial for ensuring your smart contracts behave as expected before deployment to the network.

### `/wrappers`

To interact with your smart contract off-chain, you need to serialize and deserialize messages sent to it. `Wrapper` classes are developed to mirror your smart contract implementation, making its functionality simple to use.


## Development flow

Almost any smart contract project development consists of five simple steps:

1. Edit the smart contract code in the `/contracts` folder and build it by running the build script:

```bash
npx blueprint build
```

2. Update the smart contract wrapper in the `/wrappers` folder to correspond to changes in the contract.

3. Update tests in the `/tests` folder to ensure the correctness of the new functionality and run the test script:

```bash
npx blueprint test
```

4. Repeat steps 1-3 until you achieve the desired result.

5. Update the deployment script in the `/scripts` folder and run it using this command:

```bash
npx blueprint run
```

:::tip
All examples in this guide follow the sequence of these **1-3 steps** with corresponding code samples. **Step 5**, the deployment process, is covered in the last section of the guide: [Deploying to network](/v3/guidelines/quick-start/developing-smart-contracts/func-tolk-folder/deploying-to-network/).
:::

Also, you can always generate the same structure for another smart contract if, for example, you want to create multiple contracts interacting with each other by using the following command:

```bash
npx blueprint create PascalCase # Don't forget to name the contract in PascalCase
```

## Using blueprint.config.ts

`blueprint.config.ts` is an **optional yet convenient** file that lives in the project root and pre-defines all network (and other) CLI parameters.

**Why bother?**

* Run CLI commands non-interactively – perfect for CI pipelines.
* Keep a single source of truth every team member shares.
* Still freely override any option with a CLI flag when you need to.

### File skeleton

```ts
import { Config } from '@ton/blueprint';

export const config: Config = {
    // see the table below
};
```

After that you can simply call:

```bash
npx blueprint run          # or build / test / etc.
```

CLI flags always have higher priority and can temporarily override the settings from the config.

### Option reference

<div className="doc-table blueprint-options">
| Path | Type / Values | Default | Description |
|------|---------------|---------|-------------|
| `plugins` | `Plugin[]` | `[]` | Connect external Blueprint extensions. A plugin must implement the `Plugin` interface and return a set of CLI runners. |
| `network` | `'mainnet' \| 'testnet'` or `CustomNetwork` | `undefined` | Default network environment. If omitted, Blueprint will ask at runtime. |
| `network.endpoint` | `string` | — | RPC node URL. Required for `custom`; for the rest the built-in TON Center endpoint is used. |
| `network.version` | `'v2' \| 'v4' \| 'tonapi' \| 'liteclient'` | `'v2'` | API version of the target node. |
| `network.key` | `string` | — | API key if required (e.g., TON Center v2 / TonAPI). |
| `network.type` | `'mainnet' \| 'testnet' \| 'custom'` | `'custom'` | Logical network type that will be reflected in explorer links, etc. |
| `separateCompilables` | `boolean` | `false` | When `true`, `*.compile.ts` files are placed into `compilables` folder (otherwise into `wrappers`). |
| `requestTimeout` | `number` (ms) | `undefined` | Overrides the global HTTP timeout for API requests. |
| `recursiveWrappers` | `boolean` | `false` | Recursively walk through sub-folders of `wrappers` / `compilables` when searching for contracts. |
| `manifestUrl` | `string` | `'https://raw.githubusercontent.com/ton-org/blueprint/main/tonconnect/manifest.json'` | URL of the `manifest.json` file that a TON Connect wallet shows to the user. |
</div>

> **Priority:** CLI flags (e.g. `--custom …`) always override values from the config.

### Full example

```ts
import { Config } from '@ton/blueprint';
import { ScaffoldPlugin } from 'blueprint-scaffold';

export const config: Config = {
    plugins: [new ScaffoldPlugin()],

    network: {
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        version:  'v2',
        type:     'mainnet',
        key:      process.env.TONCENTER_KEY, // keep secrets in env vars
    },

    separateCompilables: true,
    recursiveWrappers:   true,
    requestTimeout:      15_000, // 15 seconds
    manifestUrl:         'https://example.com/my-dapp/manifest.json',
};
```

### When to use

1. **CI & automation** – run `blueprint build`, `blueprint test`, etc. without any interactive questions.  
2. **Team projects** – share the same network parameters and timeouts across all developers.  
3. **Third-party plugins** – register them via `plugins` and they become available in every CLI command.

## Next step

Now you're all set — it's time to start writing smart contracts. We'll begin with the basics: **storage** and **get methods**.

<Button href="/v3/guidelines/quick-start/developing-smart-contracts/func-tolk-folder/storage-and-get-methods/" colorType={'primary'} sizeType={'sm'}>

  Storage & get methods

</Button>

<Feedback />
