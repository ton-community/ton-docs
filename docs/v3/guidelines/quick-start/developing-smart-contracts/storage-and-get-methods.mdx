import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Storage and Get Methods

> **Summary:** In previous steps we learned how to use `Blueprint SDK` and it's project structure.

:::tip
If you are stuck on some of the examples you can find original template project with all modifications performed during this guide [here](https://github.com/ton-community/ton-onboarding-sandbox/tree/main/quick-start/smart-contracts/Example).
:::

While it's technically possible to create smart contract on TON not having any persistent storage, almost all smart-contracts need to store their `data` between transactions. This guide explains standard ways of managing `storage` of smart-contract and using `get methods` to obtain it from outside the blockchain.


## Smart Contract Storage Operations

First thing that we should say is that there is a small, but important difference between smart-contract `persistent data` and [TVM storage](/v3/documentation/tvm/tvm-initialization#initial-state) existing only during execution of smart-contract. Remember that smart-contracts follow **transaction** concept - if any system or user exception is raised during execution, i.e. transaction fails - `TVM storage` will not be committed to smart-contract `persistent data`. From the realization point this means that smart-contract `persistent data` is copied to `TVM storage` before starting the execution and committed back, optionally modified, in case of successful **transaction**. For simplification of this guide we will not use those strict terms, instead we will describe both as `storage` and rely on context, so, keep these facts in mind.

There are two main instructions that provide access to smart-contract storage: 
 - `get_data()` returning current storage cell.
 - `set_data()` setting storage cell.

Lets examine `Cell` entity structure to understand how we could manage contract storage.

## Cell structure

TON blockchain uses a data structure called **`Cell`** as the fundamental unit for storing data. Cells are the building blocks of the `TVM` (TON Virtual Machine) and have those characteristics:

- A `Cell` can store up to 1023 bits (approximately 128 bytes) of data
- A `Cell` can reference up to 4 other `Cells` (children's)
- `Cell` is immutable once created

You can think of Cell as the following structure:

```typescript
// Conceptual representation of a Cell
interface Cell {
  bits: BitString; // Up to 1023 bits
  refs: Cell[];    // Up to 4 child cells
}
```

## Implementation

Let's try to modify our smart-contract folowing standard steps decsribed in previous [Blueprint SDK overview](/v3/guidelines/quick-start/developing-smart-contracts/storage-and-get-methods) section.

### Step1: Edit smart-contract code

In case it's inconvenient to always serialize and deserialize storage cell, there is a pretty standard practice to define two wrapper methods that provide corresponding logic. If you didn't change smart-contract code it should contain following lines:

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```func hello_world.fc
global int ctx_id;
global int ctx_counter;

;; load_data populates storage variables using stored data
() load_data() impure {
    var ds = get_data().begin_parse();

    ctx_id = ds~load_uint(32);
    ctx_counter = ds~load_uint(32);

    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(ctx_id, 32)
            .store_uint(ctx_counter, 32)
            .end_cell()
    );
}
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```tolk
global ctxID: int;
global ctxCounter: int;

// loadData populates storage variables from persistent storage
fun loadData() {
    var ds = getContractData().beginParse();

    ctxID = ds.loadUint(32);
    ctxCounter = ds.loadUint(32);

    ds.assertEndOfSlice();
}

// saveData stores storage variables as a cell into persistent storage
fun saveData() {
    setContractData(
        beginCell()
        .storeUint(ctxID, 32)
        .storeUint(ctxCounter, 32)
        .endCell());
}
```
</TabItem>
</Tabs>

#### Managing storage

Let's try to modify our example a little bit. First, let's use a more common approach of passing storage members as parameters to `save_data(members...)` and retrieve them as `(members...) get_data()` moving global variables ctx_id and ctx_counter to method bodies. Also, let's add additional integer of 256-bit size into our storage:

Result of our modifications should look like this:

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```func
;; load_data retrieves variables from TVM storage cell
(int, int, int) load_data() {
    var ds = get_data().begin_parse();

    ;; id is required to be able to create different instances of counters
    ;; since addresses in TON depend on the initial state of the contract
    int ctx_id = ds~load_uint(32);
    int ctx_counter = ds~load_uint(32);
    int ctx_counterExt = ds~load_uint(256);

    ds.end_parse();

    return (ctx_id, seqno, public_key);
}

;; save_data stores variables as a cell into persistent storage
;; impure because of writing into TVM storage
() save_data(int ctx_id, int seqno, int ctxCounterExt) impure {
    set_data(
        begin_cell()
            .store_uint(ctx_id, 32)
            .store_uint(ctxCounter, 32)
            .store_uint(ctxCounterExt, 256)
        .end_cell()
    );
}
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```tolk
// load_data retrieves variables from TVM storage cell
// impure because of writting into global variables
fun loadData(): (int, int, int) {
    var ds = getContractData().beginParse();

    // id is required to be able to create different instances of counters
    // since addresses in TON depend on the initial state of the contract
    var ctxID = ds.loadUint(32);
    var ctxCounter = ds.loadUint(32);
    var ctxCounterExt = ds.loadUint(256);

    ds.assertEndOfSlice();

    return (ctxID, ctxCounter, ctxCounterExt);
}

// saveData stores storage variables as a cell into persistent storage
fun saveData(ctxID: int, seqno: int, public_key: int) {
    setContractData(
        beginCell()
        .storeUint(ctxID, 32)
        .storeUint(ctxCounter, 32)
        .storeUint(ctxcounterExt, 256)
        .endCell()
    );
}
```
</TabItem>
</Tabs>

Don't forget to delete global variables `ctx_id`, `ctx_counter` and modify usage of the function like this, copying storage members locally:

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```func
var (ctx_id, ctxCounter, ctxCounterExt) = load_data();
save_data(ctx_id, ctxCounter, ctxCounterExt);
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```tolk
var (ctx_id, ctxCounter, ctxCounterExt) = load_data();
save_data(ctx_id, ctxCounter, ctxCounterExt);
```
</TabItem>
</Tabs>

#### Get methods

The primary use of get methods is reading our storage data from outside the blockchain using a convenient interface, primarily to extract data that is required to prepare a transaction.

<Tabs groupId="language">
<TabItem value="FunC" label="FunC">
```func
(int, int) get_counters() method_id {
    var (_, ctxCounter, ctxCounterExt) = load_data();
    return (ctxCounter, ctxCounterExt);
}
```
</TabItem>
<TabItem value="Tolk" label="Tolk">
```tolk
get get_counters(): (int, int) {
    var (_, ctxCounter, ctxCounterExt) = load_data();
    return (ctxCounter, ctxCounterExt);
}
```
</TabItem>
</Tabs>

Don't forget to check the correctness of your changes by compiling the smart contract:

```bash
npm run build
```

And that's it! In practice all get methods follow this simple flow and don't require anything more. Note that you can omit values returned from functions using '_' syntax.

## Step2: Updating wrapper

Now lets update our wrapper class corresponding to new storage layout and new `get method`.

First, let's modify `helloWorldConfigToCell` function and `HelloWorldConfig` type to properly initialize our storage during deployment:

```typescript
export type HelloWorldConfig = {
    id: number;
    ctxCounter: number;
    ctxCounterExt: bigint;
};

export function helloWorldConfigToCell(config: HelloWorldConfig): Cell {
    return beginCell()
        .storeUint(config.id, 32)
        .storeUint(config.ctxCounter, 32)
        .storeUint(config.ctxcounterExt, 256)
    .endCell();
}
```
Second, add a method to perform a request for the newly created get method:

```typescript
async getSeqnoPKey(provider: ContractProvider) {
    const result = await provider.get('get_counters', []);
    const counter = result.stack.readNumber();
    const counterExt = result.stack.readBigNumber();

    return [counter, counterExt]
}
```

## Step3: Updating tests

And finally, let's write a simple test, checking that the deployment process initializes smart contract storage and correctly retrieves its data by get methods.

First, let's update the `before each` section and particularly the `openContract` logic with the following one:

```typescript
helloWorld = blockchain.openContract(
    HelloWorld.createFromConfig(
        {
            id: 0,
            ctxCounter: 0,
            ctxCounterExt: 0n
        },
        code
    )
);
```

And add new test case for get methods:

```typescript
it('should correctly initialize and return the initial data', async () => {
    // Define the expected initial values (same as in beforeEach)
    const expectedConfig = {
        id: 0,
        ctxCounter: 0,
        ctxCounterExt: 0n
    };

    // Verify counter value
    const counter = await helloWorld.getCounter();
    expect(counter).toBe(expectedConfig.ctxCounter);

    // Verify ID value
    const id = await helloWorld.getID();
    expect(id).toBe(expectedConfig.id);

    // Verify both counters 
    const [ctx, ctxExt] = await helloWorld.getSeqnoPKey();
    expect(ctx).toBe(expectedConfig.ctxCounter);
    expect(ctxExt).toBe(expectedConfig.ctxCounterExt);
});
```

And now run your new test script by executing the following command:

```bash
npm run test
```

