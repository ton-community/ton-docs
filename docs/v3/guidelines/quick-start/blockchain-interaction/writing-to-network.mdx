import ThemedImage from "@theme/ThemedImage";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Writing to the network

In the previous section, you learned how to **read data** from the TON Blockchain. Now, let's explore how to **write data** to it. Writing to the TON network involves sending messages. These messages trigger actions in smart contracts, such as transferring TON, Jettons, NFTs, updating contract state, or deploying new contracts.

## Setting Up the Project

First, let's initialize the project and install the necessary dependencies.

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="TypeScript">

Now, let's initialize the project and install the necessary dependencies.

```bash
npm init -y
npm install typescript ts-node @ton/ton @ton/core @ton/crypto
npx tsc --init
```

To run scripts, use the following command:

```bash
npx ts-node script.ts
```

</TabItem>
<TabItem value="tonutils" label="Python3">

Now, let's initialize the project and install the necessary dependencies.

```bash
python3 -m venv .venv
source .venv/bin/activate
python3 -m pip install tonutils pytoniq
```

To run scripts, use the following command:
```bash
python3 script.py
```

</TabItem>
</Tabs>


## Sending TON

The simplest interaction between two accounts in TON Blockchain is a TON transfer. The process involves preparing and signing a transaction, and then sending it to the blockchain. Interaction with the blockchain is mostly done via [**wallets**](/v3/guidelines/smart-contracts/howto/wallet#-ton-blockchain-wallets). All wallets that operate on TON Blockchain are actually smart contracts owned by individuals outside the blockchain. The wallet uses a public key to verify the legitimacy of the message signature when receiving an [external message](/v3/documentation/smart-contracts/message-management/external-messages/) that the owner signed with the private key. The private key is often derived from a *mnemonic* or *seed phrase*â€”a sequence of 24 random words. Wallets use `seqno` for [replay protection](/v3/guidelines/smart-contracts/howto/wallet/#replay-protection---seqno/), a mechanism to prevent the repetition of messages.

A common transfer would look like this:

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1.svg?raw=true',
      dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1_dark.svg?raw=true',
    }}
  />
</div>
<br></br>

:::caution
Unlike in the [Reading from the Network](/v3/guidelines/quick-start/blockchain-interaction/reading-from-network/) section, a Toncenter API key is mandatory in the following examples.
:::

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="@ton/ton">
```typescript
import { mnemonicToWalletKey } from "@ton/crypto";
import { comment, internal, toNano, TonClient, WalletContractV4, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";

async function main() {
  // Initializing tonClient for sending messages to blockchain
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });

  // Generating
  const mnemonic = "word1 word2 ...".split(' '); // Insert your mnemonic here
  const keyPair = await mnemonicToWalletKey(mnemonic);

 // Creating wallet depending on version (v5r1 or v4), uncomment which version do you have
  const walletContract = WalletContractV4.create({ workchain: 0, publicKey });
  // const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey }); // networkGlobalId: -3 for testnet, -239 for mainnet

  // Getting seqno from wallet. This mechanism serves for replay protection
  const seqno = await wallet.getSeqno();

  // Sending transfer
  await wallet.sendTransfer({
    seqno,
    secretKey: keyPair.secretKey,
    messages: [internal({
      to: wallet.address, // Transfer will be made to the same wallet address
      body: comment('Hello from wallet!'), // Transfer will contain comment
      value: toNano(0.05), // Amount of TON, attached to transfer
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}

main();
```
</TabItem>
<TabItem value="tonutils" label="tonutils">
```python
from tonutils.client import ToncenterClient
from tonutils.wallet import (
    WalletV5R1
)

IS_TESTNET = True

# Mnemonic phrase for creating the wallet
MNEMONIC = 'Insert your mnemonic phrase here'

async def main() -> None:
    client = ToncenterClient(is_testnet=IS_TESTNET)

    wallet, public_key, private_key, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)

    result = await wallet.transfer(destination=wallet.address, amount=0.01, body="Helo from wallet!")

    print(result)


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())
```

</TabItem>
</Tabs>


:::caution Advanced Level
In most scenarios, `SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS`(default for `tonuitls`) will work, but if you want a deeper understanding, continue reading in the [message modes cookbook](/v3/documentation/smart-contracts/message-management/message-modes-cookbook/).
:::

## Retrieving message hash

:::info
Be careful with the hash definition. It can be either a transaction hash or a message hash. These are different things.
:::

Sometimes it will be useful to get the message hash before sending it. By the message hash, the transaction may be found on the blockchain. To do so, instead of calling the `sendTransfer` method on the wallet, we should build the message ourselves.

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="@ton/ton">
```typescript
// Building the transfer to the wallet
const transfer = wallet.createTransfer({
  seqno,
  secretKey,
  messages: [internal({
    to: wallet.address,
    body: comment('Hello from wallet!'),
    value: toNano(0.05),
  })],
  sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
});

// Building the external message to be sent to the blockchain
const externalMessage = external({
  to: wallet.address,
  body: transfer,
});


// Obtaining the message hash
const messageHash = beginCell()
  .store(storeMessage(externalMessage))
  .endCell()
  .hash();

console.log(messageHash.toString('hex'));
console.log(`https://testnet.tonviewer.com/transaction/${messageHash.toString('hex')}`);

// Sending message to the blockchain
await tonClient.sendMessage(externalMessage);
```
</TabItem>
<TabItem value="tonutils" label="tonutils">
```python
from tonutils.client import ToncenterClient
from tonutils.wallet import WalletV5R1
from tonutils.utils import message_to_boc_hex
import asyncio
MNEMONIC = "Insert your mnemonic here"

async def main():
    # Initialize client and wallet
    client = ToncenterClient(is_testnet=True)

    # Create wallet from mnemonic
    wallet, _, _, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)

    # prepare internal message
    mesage = wallet.create_wallet_internal_message(
        destination=wallet.address,
        value=1,
        body="Hello from wallet!",
        state_init=None,
        send_mode=3
    ),

    # retrieving seqno
    seqno = await wallet.get_seqno(client, wallet.address)

    # create message body
    body = wallet.raw_create_transfer_msg(
        private_key=wallet.private_key,
        messages=mesage,
        seqno=seqno
    )

    # obtaining serialized message and message hash
    message = wallet.create_external_msg(dest=wallet.address, body=body, state_init=None)
    message_boc_hex, message_hash = message_to_boc_hex(message)

    # sending message to blockhain
    await wallet.client.send_message(message_boc_hex)

    print(message_hash)
    print(f"https://testnet.tonviewer.com/transaction/{message_hash}")

if __name__ == "__main__":
    asyncio.run(main())
```
</TabItem>
</Tabs>

## Retrieving transaction hash

It may also be useful to wait for the transaction to appear on the blockchain. This can be done by trying to get it by `messageHash` with delays. When the transaction is obtained, the hash of the transaction may be received.

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="@ton/ton">
```typescript
async function waitForTransaction(messageHash: Buffer, maxRetries = 12) {
  let retries = 0;
  while (retries < maxRetries) {
    console.log(`Waiting for transaction, retry ${retries}...`);
    retries += 1;
    await new Promise(resolve => setTimeout(resolve, 1000));

    const response = await fetch(`https://testnet.tonapi.io/v2/blockchain/transactions/${messageHash.toString('hex')}`);
    if (!response.ok) {
      continue;
    }

    const result = await response.json();
    if (!result.raw) {
      continue;
    }

    return loadTransaction(Cell.fromHex(result.raw).beginParse());
  }

  throw new Error('Retries exceeded, transaction not found')
}

const transaction = await waitForTransaction(messageHash);
const transactionHash = transaction.hash();
```
</TabItem>
<TabItem value="tonutils" label="tonutils">
```python
async def wait_for_transaction(message_hash: bytes, max_retries: int = 12):
    retries = 0

    async with aiohttp.ClientSession() as session:
        while retries < max_retries:
            print(f"Waiting for transaction, retry {retries}...")
            retries += 1

            try:
                async with session.get(
                    f"https://testnet.tonapi.io/v2/blockchain/transactions/{message_hash}"
                ) as response:
                    if response.status != 200:
                        await asyncio.sleep(1)
                        continue

                    print("SUCCESS!")
                    return

            except aiohttp.ClientError:
                await asyncio.sleep(1)
                continue

    raise Exception("Retries exceeded, transaction not found")
```
</TabItem>
</Tabs>

## Failed Transactions

Unfortunately, in some cases, a transaction may fail. There are two types of failures when making a transfer from a wallet:
- *External message was not accepted by the wallet*: This failure may occur due to an invalid `seqno`, message `deadline`, or invalid signature, etc. In this case, the message will not trigger a transaction and will not appear on the blockchain.
- *Failure after the message was accepted*: In this case, the transaction will appear on the blockchain, but the outcome of the transaction will not be successful. Refer to this [article](/documentation/smart-contracts/message-management/messages-and-transactions/#transaction-outcome) for further reading.

## Sending Jettons

[Jettons](/v3/guidelines/dapps/cookbook#tep-74-jettons-standard) are tokens on the TON Blockchain. You may get some Jettons on the testnet using the [USDt giver bot](https://t.me/testgiver_ton_usdt_bot).

To send them, we should send messages to our Jetton wallet to make a transfer.

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5.svg?raw=true',
      dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5_dark.svg?raw=true',
    }}
  />
</div>
<br></br>

To make the example more practical, let's obtain this address programmatically by using the [`JettonMaster` wrapper](/v3/guidelines/quick-start/blockchain-interaction/reading-from-network#using-wrappers-for-simplicity).

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="@ton/ton">
```typescript
import { mnemonicToWalletKey } from "@ton/crypto";
import { Address, beginCell, comment, internal, JettonMaster, toNano, TonClient, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";

async function main() {
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });

  const mnemonic = "word1 word2 ...".split(' ');
  const { publicKey, secretKey } = await mnemonicToWalletKey(mnemonic);
  const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey }); // networkGlobalId: -3 for testnet, -239 for mainnet
  const wallet = tonClient.open(walletContract);
  const seqno = await wallet.getSeqno();

  const jettonTransferBody = beginCell()
    .storeUint(0x0f8a7ea5, 32) // opcode for jetton transfer
    .storeUint(0, 64) // query id
    .storeCoins(1000000) // jetton amount in minimal values. Note, that USDt has 6 decimals, so 1000000 is 1 USDt on UI
    .storeAddress(wallet.address) // destination address to transfer
    .storeAddress(wallet.address) // response destination
    .storeBit(0) // no custom payload
    .storeCoins(1) // forward amount - if >0, will send notification message
    .storeMaybeRef(comment('Hello from jetton!'))
    .endCell();

  const jettonMasterAddress = Address.parse('kQD0GKBM8ZbryVk2aESmzfU6b9b_8era_IkvBSELujFZPsyy'); // If testnet USDt is used this is master address

  const jettonMaster = tonClient.open(JettonMaster.create(jettonMasterAddress));
  const myJettonWalletAddress = await jettonMaster.getWalletAddress(wallet.address);

  // Sending transfer to jetton wallet
  await wallet.sendTransfer({
    seqno,
    secretKey,
    messages: [internal({
      to: myJettonWalletAddress,
      body: jettonTransferBody,
      value: toNano(0.05),
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}

main();
```
</TabItem>
<TabItem value="tonutils" label="tonutils">
```python
from pytoniq_core import begin_cell

from tonutils.client import ToncenterClient
from tonutils.jetton import JettonMaster, JettonWallet
from tonutils.wallet import WalletV5R1

# Set to True for the test network, False for the main network
IS_TESTNET = True
MNEMONIC = "table dizzy all reopen repeat tag august bid lunch purse able logic shuffle shoe ritual jacket dilemma cage dragon plunge arrange sister catalog impact"
JETTON_MASTER_ADDRESS = "kQD0GKBM8ZbryVk2aESmzfU6b9b_8era_IkvBSELujFZPsyy"
JETTON_DECIMALS = 6
JETTON_AMOUNT = 0.01
COMMENT = "Hello from jetton!"

async def main() -> None:
    client = ToncenterClient(is_testnet=IS_TESTNET)
    wallet, _, _, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)

    jetton_wallet_address = await JettonMaster.get_wallet_address(
        client=client,
        owner_address=wallet.address.to_str(),
        jetton_master_address=JETTON_MASTER_ADDRESS,
    )

    body = JettonWallet.build_transfer_body(
        recipient_address=wallet.address,
        response_address=wallet.address,
        jetton_amount=int(JETTON_AMOUNT * (10 ** JETTON_DECIMALS)),
        forward_payload=(
            begin_cell()
            .store_uint(0, 32)  # Text comment opcode
            .store_snake_string(COMMENT)
            .end_cell()
        ),
        forward_amount=1,
    )

    tx_hash = await wallet.transfer(
        destination=jetton_wallet_address,
        amount=0.05,
        body=body,
    )

    print(f"Successfully transferred {JETTON_AMOUNT} jettons!")
    print(f"Transaction hash: {tx_hash}")


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())
```
</TabItem>
</Tabs>

## Sending NFTs

[Non-fungible tokens](/v3/guidelines/dapps/asset-processing/nft-processing/nfts) (NFTs) are assets like a piece of art, digital content, or video that have been tokenized via a blockchain. In TON, NFTs are represented via a collection of smart contracts:
- **NFT Collection**: stores information about the NFT collection.
- **NFT Item**: stores information about the NFT item that the user owns.

NFTs may be deployed via [TON Tools](https://ton-collection-edit.vercel.app/deploy-collection).

<Tabs groupId="SDK">
<TabItem value="@ton/ton" label="@ton/ton">
```typescript
import { mnemonicToWalletKey } from "@ton/crypto";
import { Address, beginCell, comment, internal, toNano, TonClient, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";


async function main() {
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });
  const mnemonic = "word1 word2 ...".split(' '); // Insert your mnemonic
  const { publicKey, secretKey } = await mnemonicToWalletKey(mnemonic);
  const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey });
  const wallet = tonClient.open(walletContract);
  const seqno = await wallet.getSeqno();

  const nftTransferBody = beginCell()
    .storeUint(0x5fcc3d14, 32) // opcode for nft transfer
    .storeUint(0, 64) // query id
    .storeAddress(wallet.address) // address to transfer ownership to
    .storeAddress(wallet.address) // response destination
    .storeBit(0) // no custom payload
    .storeCoins(1) // forward amount - if >0, will send notification message
    .storeMaybeRef(comment('Hello from NFT!'))
    .endCell();

  const nftAddress = Address.parse('YOUR_NFT_ADDRESS'); // NFT Address may be obtained after deploying NFT Item

  // Sending NFT transfer
  await wallet.sendTransfer({
    seqno,
    secretKey,
    messages: [internal({
      to: nftAddress,
      body: nftTransferBody,
      value: toNano(0.05),
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}
main();
```
</TabItem>
<TabItem value="tonutils" label="tonutils">
```python
from pytoniq_core import Address, begin_cell

from tonutils.client import ToncenterClient
from tonutils.nft import NFTStandard
from tonutils.wallet import WalletV5R1

# Set to True for test network, False for main network
IS_TESTNET = True

# Mnemonic phrase used to connect the wallet
MNEMONIC = "lonely kitchen armed visual midnight anchor pottery include force banana mosquito inflict fabric bike leaf differ text coil volcano seed dash amateur black welcome"

# Address of the NFT to be transferred and the new owner address
NFT_ADDRESS = "EQDW2lkFHPO_EWAsWI90MdvqU5fr8tiELbbcfaA8FmSkMen2"

# Optional comment to include in the forward payload
COMMENT = "Hello from NFT!"


async def main() -> None:
    client = ToncenterClient(is_testnet=IS_TESTNET)
    wallet, _, _, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)

    body = NFTStandard.build_transfer_body(
        new_owner_address=wallet.address,
        forward_payload=(
            begin_cell()
            .store_uint(0, 32)
            .store_snake_string(COMMENT)
            .end_cell()
        ),
        forward_amount=1,
    )

    message_hash = await wallet.transfer(
        destination=NFT_ADDRESS,
        amount=0.05,
        body=body,
    )

    print(f"Transaction hash: {message_hash}")


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())
```
</TabItem>
</Tabs>

