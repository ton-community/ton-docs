import ThemedImage from "@theme/ThemedImage";

# Writing to the network

In the previous section, you learned how to **read data** from the TON Blockchain. Now, let's explore how to **write data** to it. Writing to the TON network involves sending messages. These messages trigger actions in smart contracts, such as transferring TON, Jettons, NFTs, updating contract state, or deploying new contracts.

## Setting Up the Project

Now, let's initialize the project and install the necessary dependencies.

```bash
npm init -y
npm install typescript ts-node @ton/ton @ton/core @ton/crypto
npx tsc --init
```

To run scripts, use the following command:

```bash
npx ts-node script.ts
```

## Sending TON

The simplest interaction between two accounts in TON Blockchain is a TON transfer. The process involves preparing and signing a transaction, and then sending it to the blockchain.

A common transfer would look like this:

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1.svg?raw=true',
      dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1_dark.svg?raw=true',
    }}
  />
</div>
<br></br>

:::caution
Unlike in the [Reading from the Network](/v3/guidelines/quick-start/blockchain-interaction/reading-from-network/) section, a Toncenter API key is mandatory in the following examples.
:::

```typescript title="1-send-ton.ts"
import { mnemonicToWalletKey } from "@ton/crypto";
import { comment, internal, toNano, TonClient, WalletContractV4, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";

async function main() {
  // Initializing tonClient for sending messages to blockchain
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });

  // Using mnemonic to derive public and private keys
  const mnemonic = "word1 word2 ...".split(' ');
  const { publicKey, secretKey } = await mnemonicToWalletKey(mnemonic);

  // Creating wallet depending on version (v5r1 or v4), uncomment which version do you have
  const walletContract = WalletContractV4.create({ workchain: 0, publicKey });
  // const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey }); // networkGlobalId: -3 for testnet, -239 for mainnet

  // Opening wallet with tonClient, which allows to send messages to blockchain
  const wallet = tonClient.open(walletContract);

  // Retrieving seqno used for replay protection
  const seqno = await wallet.getSeqno();

  // Sending transfer
  await wallet.sendTransfer({
    seqno,
    secretKey,
    messages: [internal({
      to: wallet.address, // Transfer will be made to the same wallet address
      body: comment('Hello from wallet!'), // Transfer will contain comment
      value: toNano(0.05), // Amount of TON, attached to transfer
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}

main();
```

:::caution Advanced Level
In most scenarios, `SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS` will work, but if you want a deeper understanding, continue reading in the [message modes cookbook](/v3/documentation/smart-contracts/message-management/message-modes-cookbook/).
:::

## Sending jettons

[Jettons](/v3/guidelines/dapps/cookbook#tep-74-jettons-standard) are tokens on the TON Blockchain. You may get some Jettons on the testnet using the [USDt giver bot](https://t.me/testgiver_ton_usdt_bot).

To send them, we should send messages to our Jetton wallet to make a transfer.

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5.svg?raw=true',
      dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5_dark.svg?raw=true',
    }}
  />
</div>
<br></br>

To make the example more practical, let's obtain this address programmatically by using the [`JettonMaster` wrapper](/v3/guidelines/quick-start/blockchain-interaction/reading-from-network#using-wrappers-for-simplicity).

```typescript title="2-send-jetton.ts"
import { mnemonicToWalletKey } from "@ton/crypto";
import { Address, beginCell, comment, internal, JettonMaster, toNano, TonClient, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";

async function main() {
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });

  const mnemonic = "word1 word2 ...".split(' ');
  const { publicKey, secretKey } = await mnemonicToWalletKey(mnemonic);
  const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey }); // networkGlobalId: -3 for testnet, -239 for mainnet
  const wallet = tonClient.open(walletContract);
  const seqno = await wallet.getSeqno();

  const jettonTransferBody = beginCell()
    .storeUint(0x0f8a7ea5, 32) // opcode for jetton transfer
    .storeUint(0, 64) // query id
    .storeCoins(1000000) // jetton amount in minimal values. Note, that USDt has 6 decimals, so 1000000 is 1 USDt on UI
    .storeAddress(wallet.address) // destination address to transfer
    .storeAddress(wallet.address) // response destination
    .storeBit(0) // no custom payload
    .storeCoins(1) // forward amount - if >0, will send notification message
    .storeMaybeRef(comment('Hello from jetton!'))
    .endCell();

  const jettonMasterAddress = Address.parse('kQD0GKBM8ZbryVk2aESmzfU6b9b_8era_IkvBSELujFZPsyy'); // If testnet USDt is used this is master address

  const jettonMaster = tonClient.open(JettonMaster.create(jettonMasterAddress));
  const myJettonWalletAddress = await jettonMaster.getWalletAddress(wallet.address);

  // Sending transfer to jetton wallet
  await wallet.sendTransfer({
    seqno,
    secretKey,
    messages: [internal({
      to: myJettonWalletAddress,
      body: jettonTransferBody,
      value: toNano(0.05),
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}

main();
```

## Sending NFTs

[Non-fungible tokens](/v3/guidelines/dapps/asset-processing/nft-processing/nfts) (NFTs) are assets like a piece of art, digital content, or video that have been tokenized via a blockchain. In TON, NFTs are represented via a collection of smart contracts:
- **NFT Collection**: stores information about the NFT collection.
- **NFT Item**: stores information about the NFT item that the user owns.

NFTs may be deployed via [TON Tools](https://ton-collection-edit.vercel.app/deploy-nft-single).

```typescript title="3-send-nft.ts"
import { mnemonicToWalletKey } from "@ton/crypto";
import { Address, beginCell, comment, internal, toNano, TonClient, WalletContractV5R1 } from "@ton/ton";
import { SendMode } from "@ton/core";


async function main() {
  const tonClient = new TonClient({
    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',
    apiKey: 'YOUR_API_KEY',
  });
  const mnemonic = "word1 word2 ...".split(' '); // Insert your mnemonic
  const { publicKey, secretKey } = await mnemonicToWalletKey(mnemonic);
  const walletContract = WalletContractV5R1.create({ walletId: { networkGlobalId: -3 }, publicKey });
  const wallet = tonClient.open(walletContract);
  const seqno = await wallet.getSeqno();

  const nftTransferBody = beginCell()
    .storeUint(0x5fcc3d14, 32) // opcode for nft transfer
    .storeUint(0, 64) // query id
    .storeAddress(wallet.address) // address to transfer ownership to
    .storeAddress(wallet.address) // response destination
    .storeBit(0) // no custom payload
    .storeCoins(1) // forward amount - if >0, will send notification message
    .storeMaybeRef(comment('Hello from NFT!'))
    .endCell();

  const nftAddress = Address.parse('YOUR_NFT_ADDRESS'); // NFT Address may be obtained after deploying NFT Item

  // Sending NFT transfer
  await wallet.sendTransfer({
    seqno,
    secretKey,
    messages: [internal({
      to: nftAddress,
      body: nftTransferBody,
      value: toNano(0.05),
    })],
    sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS,
  });
}
main();
```
