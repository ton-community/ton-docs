import Feedback from "@site/src/components/Feedback";

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Preparing messages

While using TON Connect, you should construct the message body for the payload used in various operations. On this page, you can find the most relevant payload examples for use with the TON Connect SDKs.

## Cells and message serialization

Before diving into building messages, let's introduce the concept of cells, which message bodies are made from.

### What is a cell?

A cell is a basic data structure in the TON Blockchain. It can store up to `1023` bits and hold up to `4` references to other cells, which allows you to store more complex data structures.
Libraries like `@ton/core` and `@ton-community/assets-sdk` provide efficient cell handling.

You can read more about cells [here](/v3/documentation/data-formats/tlb/cell-boc).

### Creating a cell

To build a cell, you use the `beginCell()` function. While the cell is _open_, you can store various data types with `store...()` functions.
When you're done, you close the cell with the `endCell()` function.

```ts
import { Address, beginCell } from "@ton/ton";

const cell = beginCell()
  .storeUint(99, 64) // Stores uint 99 in 64 bits
  .storeAddress(Address.parse("[SOME_ADDR]")) // Stores an address
  .storeCoins(123) // Stores 123 as coins
  .endCell(); // Closes the cell
```

:::info
Examples were provided only for @ton/ton library. However, every version of [SDKs](/v3/guidelines/dapps/apis-sdks/sdk) implementation has similar functions.
:::

### Parsing a cell

The `beginParse()` function is called to read or parse data from a cell. You read data in the same order it was stored using similar `load...()` functions:

```ts
const slice = cell.beginParse();
const uint = slice.loadUint(64);
const address = slice.loadAddress();
const coins = slice.loadCoins();
```

### Larger amounts of data

Each cell has a 1023-bit limit. If you exceed this, an error occurs:

```ts
// This will fail due to overflow
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeUint(3, 256)
  .storeUint(4, 256) // Exceeds 1023-bit limit (256 + 256 + 256 + 256 = 1024)
  .endCell();
```

To store more data, cells can reference up to four other cells. You can use the `storeRef()` function to create nested cells:

```ts
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeRef(beginCell().storeUint(3, 256).storeUint(4, 256).endCell())
  .endCell();
```

To load a referenced (nested) cell, use `loadRef()`:

```ts
const slice = cell.beginParse();
const uint1 = slice.loadUint(256);
const uint2 = slice.loadUint(256);
const innerSlice = slice.loadRef().beginParse(); // Load and parse nested cell
const uint3 = innerSlice.loadUint(256);
const uint4 = innerSlice.loadUint(256);
```

### Optional references and values

Cells can store optional values, which may be null. These are stored using the `storeMaybe...()` functions:

```ts
const cell = beginCell()
  .storeMaybeInt(null, 64) // Optionally stores an int
  .storeMaybeInt(1, 64)
  .storeMaybeRef(null) // Optionally stores a reference
  .storeMaybeRef(beginCell().storeCoins(123).endCell());
```

You can parse optional values using the corresponding `loadMaybe...()` functions. Returned values are nullable so do not forget to check them for null!

```ts
const slice = cell.beginParse();
const maybeInt = slice.loadMaybeUint(64);
const maybeInt1 = slice.loadMaybeUint(64);
const maybeRef = slice.loadMaybeRef();
const maybeRef1 = slice.loadMaybeRef();
if (maybeRef1) {
  const coins = maybeRef1.beginParse().loadCoins();
}
```

### Using assets sdk for more straightforward serialization and deserialization

Manually handling cells can be tedious, so the `@ton-community/assets-sdk` provides convenient methods for serializing and deserializing messages.

Using `@ton-community/assets-sdk` is more readable and less error-prone.

<Tabs groupId="Serialization/Deserialization">
  <TabItem value="@ton-community/assets-sdk" label="@ton-community/assets-sdk">

    ```ts
    import {Address, beginCell} from "@ton/core";
    import {storeJettonTransferMessage, loadJettonTransferMessage} from "@ton-community/assets-sdk";

    // serialization
    const cell = beginCell()
      .store(storeJettonTransferMessage({
        queryId: 42n,
        amount: 100n,
        destination: Address.parse('[DESTINATION]'),
        responseDestination: Address.parse('[RESPONSE_DESTINATION]'),
        customPayload: null,
        forwardAmount: 1n,
        forwardPayload: null,
      }))
      .endCell()

    // deserialization
    const transferMessage = loadJettonTransferMessage(cell.beginParse());
    ```

  </TabItem>

  <TabItem value="@ton/ton" label="@ton/ton">

    ```ts
    import {Address, beginCell} from "@ton/core";

    // serialization
    const cell = beginCell()
      .storeUint(260734629, 32)
      .storeUint(42, 64)
      .storeCoins(100)
      .storeAddress(Address.parse('[DESTINATION]'))
      .storeAddress(Address.parse('[RESPONSE_DESTINATION]'))
      .storeMaybeRef(null)
      .storeCoins(1)
      .storeMaybeRef(null)
      .endCell();

    // deserialization
    const slice = cell.beginParse();
    const op = slice.loadUint(32);
    const queryId = slice.loadUint(64);
    const amount = slice.loadCoins();
    const destination = slice.loadAddress();
    const responseDestination = slice.loadAddress();
    const customPayload = slice.loadMaybeRef();
    const fwdAmount = slice.loadCoins();
    const fwdPayload = slice.loadMaybeRef();

    const transferMessage = { op, queryId, amount, destination, responseDestination, customPayload, fwdAmount, fwdPayload };
    ```

  </TabItem>
</Tabs>

## TON Connect JS SDK examples

### Transaction template

No matter what level of task a developer is solving, it is typically necessary to use the connector entity from `@tonconnect/ui-react` or `@tonconnect/ui`.

Examples created based on `@tonconnect/ui-react` and `@tonconnect/ui`:

<Tabs groupId="TON Connect template">
  <TabItem value="tonconnect-react" label="@tonconnect/ui-react">

    ```js
    import { useTonConnectUI } from '@tonconnect/ui-react';

    const transaction = {
        //transaction body
    }

    export const Settings = () => {
        const [tonConnectUI, setOptions] = useTonConnectUI();

        return (
            <div>
                <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                    Send transaction
                </button>
            </div>
        );
    };
    ```

  </TabItem>

  <TabItem value="tonconnect-ui" label="@tonconnect/ui">

    ```js
    import TonConnectUI from '@tonconnect/ui';

    const tonConnectUI = new TonConnectUI({ //connect application
        manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
        buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
    });

    const transaction = {
        //transaction body
    }

    const result = await tonConnectUI.sendTransaction(transaction)

    ```

  </TabItem>
</Tabs>

### Regular TON transfer

TON Connect SDKs include wrappers for sending messages, making it easy to prepare regular transfers of Toncoins between two wallets as default transaction without payload.

The `address` must be in a [user-friendly format](/v3/documentation/smart-contracts/addresses#user-friendly-address), not a raw. If the message is being sent to a smart contract, it must be bounceable; if the message is being sent to a wallet, it must be non-bounceable.

A regular TON transfer using the TON Connect JS SDKs can be executed as follows:

<Tabs groupId="Regular Transfer">
  <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

    ```js
    import { useTonConnectUI } from '@tonconnect/ui-react';
    const [tonConnectUI] = useTonConnectUI();

    const transaction = {
        messages: [
            {
                address: "EQBBJBB3HagsujBqVfqeDUPJ0kXjgTPLWPFFffuNXNiJL0aA", // destination address
                amount: "20000000" //Toncoin in nanotons
            }
        ]

    }

    export const Settings = () => {
        const [tonConnectUI, setOptions] = useTonConnectUI();

        return (
            <div>
                <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                    Send transaction
                </button>
            </div>
        );
    };
    ```

  </TabItem>

  <TabItem value="tonconnect-ui" label="@tonconnect/ui">

    ```js
    import TonConnectUI from '@tonconnect/ui';

    const tonConnectUI = new TonConnectUI({ //connect application
        manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
        buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
    });

    const transaction = {
        messages: [
            {
                address: "EQBBJBB3HagsujBqVfqeDUPJ0kXjgTPLWPFFffuNXNiJL0aA", // destination address
                amount: "20000000" //Toncoin in nanotons
            }
        ]
    }

    const result = await tonConnectUI.sendTransaction(transaction)
    ```

  </TabItem>
</Tabs>

:::tip
Learn more about [TON smart contract addresses](/v3/documentation/smart-contracts/addresses).
:::

For specific custom transactions, a particular payload must be defined.

### Transfer with a comment

The simplest example involves adding a payload with a comment. 

Before the transaction, it is necessary to prepare a body cell via the [@ton/ton](https://github.com/ton-org/ton).

```js
import { beginCell } from "@ton/ton";

const body = beginCell()
  .storeUint(0, 32) // write 32 zero bits to indicate that a text comment will follow
  .storeStringTail("Hello, TON!") // write our text comment
  .endCell();
```

See more details on [this page](/v3/documentation/smart-contracts/message-management/internal-messages#simple-message-with-a-comment).

The transaction is created as follows:

<Tabs groupId="Transfer With a Comment">
  <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

    ```js
    import { useTonConnectUI } from '@tonconnect/ui-react';
    import { toNano } from '@ton/ton'

    const myTransaction = {
        validUntil: Math.floor(Date.now() / 1000) + 360,
        messages: [
            {
                address: destination,
                amount: toNano("0.05").toString(),
                payload: body.toBoc().toString("base64") // payload with comment in body
            }
        ]
    }

    export const Settings = () => {
        const [tonConnectUI, setOptions] = useTonConnectUI();

        return (
            <div>
                <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                    Send transaction
                </button>
            </div>
        );
    };
    ```

  </TabItem>

  <TabItem value="tonconnect-ui" label="@tonconnect/ui">

    ```js
    import TonConnectUI from '@tonconnect/ui'
    import { toNano } from '@ton/ton'

    const transaction = {
        validUntil: Math.floor(Date.now() / 1000) + 360,
        messages: [
            {
                address: destination,
                amount: toNano("0.05").toString(),
                payload: body.toBoc().toString("base64") // payload with comment in body
            }
        ]
    }

    const result = await tonConnectUI.sendTransaction(transaction)
    ```

  </TabItem>
</Tabs>

### Jetton transfer

The `body` for jetton transfers is based on the ([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) standard. Please note that the number of decimals can vary between different tokens: for example, USDT uses 6 decimals (1 USDT = 1 × 10<sup>6</sup>), while typically jettons and Toncoin uses 9 decimals (1 TON = 1 × 10<sup>9</sup>).
  
:::info
The `assets-sdk` library works out of the box with `ton-connect`.
:::

<Tabs groupId="Jetton transfer">
  <TabItem value="@ton/ton" label="@ton/ton">
  
    ```js
    import { beginCell, toNano, Address } from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)                 // jetton transfer op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(toNano("0.001"))              // amount:(VarUInteger 16) -  Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(Address.parse(Wallet_DST))  // destination:MsgAddress
        .storeAddress(Address.parse(Wallet_SRC))  // response_destination:MsgAddress
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano("0.05"))               // forward_ton_amount:(VarUInteger 16) - if >0, will send notification message
        .storeUint(0,1)                           // forward_payload:(Either Cell ^Cell)
        .endCell();
    ```

    Next, sending the transaction with this body to sender's `jettonWalletContract` executed:

    <Tabs groupId="JettonTransferUI">
      <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

        ```js
        import { useTonConnectUI } from '@tonconnect/ui-react';
        import { toNano } from '@ton/ton'

        const myTransaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract, // sender jetton wallet
                    amount: toNano("0.05").toString(), // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with jetton transfer body
                }
            ]
        }

        export const Settings = () => {
            const [tonConnectUI, setOptions] = useTonConnectUI();

            return (
                <div>
                    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                        Send transaction
                    </button>
                </div>
            );
        };

        ```
      </TabItem>

      <TabItem value="tonconnect-ui" label="@tonconnect/ui">

        ```js
        import TonConnectUI from '@tonconnect/ui'
        import { toNano } from '@ton/ton'

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract,  // sender jetton wallet
                    amount: toNano("0.05").toString(),         // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with jetton transfer body
                }
            ]
        }

        const result = await tonConnectUI.sendTransaction(transaction)
        ```

      </TabItem>
    </Tabs>

    - `validUntil` - UNIX-time until message valid
    - `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
    - `balance` - Integer, the amount of Toncoin used for gas payments in nanotons.
    - `body` - payload for the `jettonContract`

    <details>
      <summary>Jetton wallet state init and address preparation example</summary>

      ```js
      import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

      async function main() {
          const client = new TonClient({
              endpoint: 'https://toncenter.com/api/v2/jsonRPC',
              apiKey: 'put your api key'
          })

          const jettonWalletAddress = Address.parse('Sender_Jetton_Wallet');
          let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
          jettonWalletDataResult.stack.readNumber();
          const ownerAddress = jettonWalletDataResult.stack.readAddress();
          const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
          const jettonCode = jettonWalletDataResult.stack.readCell();
          const jettonData = beginCell()
              .storeCoins(0)
              .storeAddress(ownerAddress)
              .storeAddress(jettonMasterAddress)
              .storeRef(jettonCode)
              .endCell();

          const stateInit: StateInit = {
              code: jettonCode,
              data: jettonData
          }

          const stateInitCell = beginCell()
              .store(storeStateInit(stateInit))
              .endCell();

          console.log(new Address(0, stateInitCell.hash()));
      }
      ```
    </details>

  </TabItem>

  <TabItem value="assets/sdk" label="assets/sdk">

    :::tip
    Note: For the browser, you must set a polyfill for `Buffer`.
    :::

    For more examples, check [documentation](https://github.com/ton-community/assets-sdk)

    ```js
    const NETWORK = "testnet";
    const api = await createApi(NETWORK);
    const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const storage: PinataStorageParams = {
      pinataApiKey: process.env.PINATA_API_KEY!,
      pinataSecretKey: process.env.PINATA_SECRET!,
    };

    const sdk = AssetsSDK.create({
      api,
      storage,
      sender,
    });

    const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));
    const RECEIVER_ADDRESS = Address.parse("RECIEVER_ADDRESS");

    jetton.send(sender, RECEIVER_ADDRESS, toNano(10));
    ```

    OR you can use Jetton Contract with built-in methods:

    ```ts
    const provider = tonConnectUi;

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const client = new TonClient({
      endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
    });

    const jettonMaster = client.open(
      JettonMinter.createFromAddress(
        Address.parse("[JETTON_WALLET]"),
        new DefaultContentResolver()
      )
    );

    const jettonWalletAddress = await jettonMaster.getWalletAddress(
      sender.address!
    );
    const jettonContent = await jettonMaster.getContent();
    const jettonDecimals = jettonContent.decimals ?? 9;

    const jetton = client.open(JettonWallet.createFromAddress(jettonWalletAddress));

    await jetton.send(
      sender,
      Address.parse("[SENDER_WALLET]"),
      BigInt(1 * 10 ** jettonDecimals)
    );

    ```

  </TabItem>
</Tabs>

### Jetton transfer with comment

<Tabs groupId="JettonTransferComment">
  <TabItem value="@ton/ton" label="@ton/ton">
    The `messageBody` for jetton transfer([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) with comment we should additionally to the regular transfer `body` serialize comment and pack this in the `forwardPayload`.  Please note that the number of decimals can vary between different tokens:

    - 9 decimals: 1 TON = 1 × 10<sup>9</sup> typically for various jettons and always for Toncoin
    - 6 decimals: 1 USDT = 1 × 10<sup>6</sup> specific jettons, like USDT

    ```js
    import { beginCell, toNano, Address } from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const destinationAddress = Address.parse('put destination wallet address');

    const forwardPayload = beginCell()
        .storeUint(0, 32)                   // 0 opcode means we have a comment
        .storeStringTail('Hello, TON!')
        .endCell();

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)           // opcode for jetton transfer
        .storeUint(0, 64)                   // query id
        .storeCoins(toNano("5"))            // Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(destinationAddress)   // TON wallet destination address
        .storeAddress(destinationAddress)   // response excess destination
        .storeBit(0)                        // no custom payload
        .storeCoins(toNano("0.02"))         // forward amount (if >0, will send notification message)
        .storeBit(1)                        // we store forwardPayload as a reference
        .storeRef(forwardPayload)
        .endCell();
    ```

    Next, send the transaction with this body to the sender's `jettonWalletContract` executed:

    <Tabs groupId="JettonTransferCommentUI">
    <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

        ```js
        import { useTonConnectUI } from '@tonconnect/ui-react';
        import { toNano } from '@ton/ton'


        const jettonWalletContract = Address.parse('put your jetton wallet address');

        const myTransaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract,      // sender jetton wallet
                    amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with jetton transfer and comment body
                }
            ]
        }

        export const Settings = () => {
            const [tonConnectUI, setOptions] = useTonConnectUI();

            return (
                <div>
                    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                        Send transaction
                    </button>
                </div>
            );
        };
        ```

        </TabItem>

        <TabItem value="tonconnect-ui" label="@tonconnect/ui">

        ```js
        import TonConnectUI from '@tonconnect/ui'
        import { toNano } from '@ton/ton'

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract,            // sender jetton wallet
                    amount: toNano("0.05").toString(),        // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64")  // payload with jetton transfer and comment body
                }
            ]
        }

        const result = await tonConnectUI.sendTransaction(transaction)
        ```

        </TabItem>
    </Tabs>

    - `validUntil` - UNIX-time until message valid
    - `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
    - `balance` - Integer, the amount of Toncoin used for gas payments in nanotons.
    - `body` - payload for the `jettonContract`

    <details>
        <summary>Jetton wallet state init and address preparation example</summary>

        ```js
        import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

        async function main() {
        const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'put your api key'
        })

        const jettonWalletAddress = Address.parse('Sender_Jetton_Wallet');
        let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
        jettonWalletDataResult.stack.readNumber();
        const ownerAddress = jettonWalletDataResult.stack.readAddress();
        const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
        const jettonCode = jettonWalletDataResult.stack.readCell();
        const jettonData = beginCell()
        .storeCoins(0)
        .storeAddress(ownerAddress)
        .storeAddress(jettonMasterAddress)
        .storeRef(jettonCode)
        .endCell();

        const stateInit: StateInit = {
        code: jettonCode,
        data: jettonData
        }

        const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

        console.log(new Address(0, stateInitCell.hash()));
        }
        ```
    </details>

  </TabItem>

  <TabItem value="assets/sdk" label="assets/sdk">

    :::tip
    Note: For the browser, you must set a polyfill for `Buffer`.
    :::

    For more examples, check [documentation](https://github.com/ton-community/assets-sdk)

    ```js
    const NETWORK = "testnet";
    const api = await createApi(NETWORK);
    const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const storage: PinataStorageParams = {
      pinataApiKey: process.env.PINATA_API_KEY!,
      pinataSecretKey: process.env.PINATA_SECRET!,
    };

    const sdk = AssetsSDK.create({
      api,
      storage,
      sender,
    });

    const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));

    const forwardPayload = beginCell()
            .storeUint(0, 32) // 0 opcode means we have a comment
            .storeStringTail('Hello, TON!')
            .endCell();

    jetton.send(sender, RECEIVER_ADDRESS, toNano(10), { notify: { payload: forwardPayload } });
    ```

  </TabItem>
</Tabs>

### Jetton burn

<Tabs groupId="JettonBurn">
  <TabItem value="@ton/ton" label="@ton/ton">
    The `body` for jetton burn is based on the ([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) standard. Please note that the number of decimals can vary between different tokens:

    - 9 decimals: 1 TON = 1 × 10<sup>9</sup> typically for various jettons and always for Toncoin
    - 6 decimals: 1 USDT = 1 × 10<sup>6</sup> specific jettons, like USDT

    ```js
    import { beginCell, Address } from '@ton/ton'
    // burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x595f07bc, 32)                // jetton burn op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(toNano("0.001"))              // amount:(VarUInteger 16) - Jetton amount in decimal (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(Address.parse(Wallet_SRC))  // response_destination:MsgAddress - owner's wallet
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell) - w/o payload typically
        .endCell();
    ```

    Message places into the following request:

    <Tabs groupId="JettonBurnUI">
      <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

        ```js
        import { useTonConnectUI } from '@tonconnect/ui-react';
        import { toNano } from '@ton/ton'

        const myTransaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract, // owner's jetton wallet
                    amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with a jetton burn body
                }
            ]
        }

        export const Settings = () => {
            const [tonConnectUI, setOptions] = useTonConnectUI();

            return (
                <div>
                    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                        Send transaction
                    </button>
                </div>
            );
        };
        ```

      </TabItem>

      <TabItem value="tonconnect-ui" label="@tonconnect/ui">

        ```js
        import TonConnectUI from '@tonconnect/ui'
        import { toNano } from '@ton/ton'

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract,  // owner's jetton wallet
                    amount: toNano("0.05").toString(),         // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with a jetton burn body
                }
            ]
        }

        const result = await tonConnectUI.sendTransaction(transaction)
        ```

      </TabItem>
    </Tabs>

    - `jettonWalletAddress` - Jetton Wallet contract address, that defined based on JettonMaser and Wallet contracts
    - `amount` - Integer, amount of Toncoin for gas payments in nanotons.
    - `body` - payload for the jetton wallet with the `burn#595f07bc` op code

  </TabItem>

  <TabItem value="assets/sdk" label="assets/sdk">

    :::tip
    Note: For the browser, you must set a polyfill for `Buffer`.
    :::

    For more examples, check [documentation](https://github.com/ton-community/assets-sdk)

    ```js
    const NETWORK = "testnet";
    const api = await createApi(NETWORK);
    const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const storage: PinataStorageParams = {
      pinataApiKey: process.env.PINATA_API_KEY!,
      pinataSecretKey: process.env.PINATA_SECRET!,
    };

    const sdk = AssetsSDK.create({
      api,
      storage,
      sender,
    });

    const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));

    jetton.sendBurn(sender, toNano(10));
    ```

    OR you can use Jetton Contract with built-in methods:

    ```ts
    const provider = tonConnectUi;

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const client = new TonClient({
      endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
    });

    const jettonMaster = client.open(
      JettonMinter.createFromAddress(
        Address.parse("[JETTON_WALLET]"),
        new DefaultContentResolver()
      )
    );

    const jettonWalletAddress = await jettonMaster.getWalletAddress(
      sender.address!
    );
    const jettonContent = await jettonMaster.getContent();
    const jettonDecimals = jettonContent.decimals ?? 9;

    const jetton = client.open(JettonWallet.createFromAddress(jettonWalletAddress));

    await jetton.sendBurn(
      sender,
      BigInt(1 * 10 ** jettonDecimals)
    );

    ```

  </TabItem>
</Tabs>

### NFT transfer

<Tabs groupId="NftTransfer">
  <TabItem value="@ton/ton" label="@ton/ton">
    The `body` message typically should be done according the following way:

    ```js
    import { beginCell, toNano } from '@ton/ton'

    //  transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    //   forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

        const body = beginCell()
            .storeUint(0x5fcc3d14, 32)               // NFT transfer op code 0x5fcc3d14
            .storeUint(0, 64)                        // query_id:uint64
            .storeAddress(Address.parse(NEW_OWNER_WALLET)) // new_owner:MsgAddress
            .storeAddress(Address.parse(Wallet_DST))       // response_destination:MsgAddress
            .storeUint(0, 1)                         // custom_payload:(Maybe ^Cell)
            .storeCoins(1)                           // forward_amount:(VarUInteger 16) (1 nanoTon = toNano("0.000000001"))
            .storeUint(0,1)                          // forward_payload:(Either Cell ^Cell)
            .endCell();
    ```

    `WALLET_DST` - Address - The address of the initial NFT owner for the receiving excess
    Transfer the `NFTitem` to a new owner `NEW_OWNER_WALLET`.

    <Tabs groupId="NftTransferUI">
      <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

        ```js
        import { useTonConnectUI } from '@tonconnect/ui-react';
        import { toNano } from '@ton/ton'

        const myTransaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: jettonWalletContract, // NFT Item address, which will be transferred
                    amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with a NFT transfer body
                }
            ]
        }

        export const Settings = () => {
            const [tonConnectUI, setOptions] = useTonConnectUI();

            return (
                <div>
                    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                        Send transaction
                    </button>
                </div>
            );
        };
        ```

      </TabItem>

      <TabItem value="tonconnect-ui" label="@tonconnect/ui">

        ```js
        import TonConnectUI from '@tonconnect/ui'
        import { toNano } from '@ton/ton'

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: NFTitem,  // NFT Item address, which will be transferred
                    amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
                    payload: body.toBoc().toString("base64") // payload with a NFT transfer body
                }
            ]
        }

        const result = await tonConnectUI.sendTransaction(transaction)
        ```

      </TabItem>
    </Tabs>

    - `NFTitem` - Address - The address of the NFT item smart contract which we want to transfer to a new owner `NEW_OWNER_WALLET`.
    - `balance` - Integer, the amount of Toncoin used for gas payments in nanotons.
    - `body` - payload for the NFT contract

  </TabItem>

  <TabItem value="assets/sdk" label="assets/sdk">

    :::tip
    Note: For the browser, you must set a polyfill for `Buffer`.
    :::

    For more examples, check [documentation](https://github.com/ton-community/assets-sdk)

    ```js
    const NETWORK = "testnet";
    const api = await createApi(NETWORK);
    const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);

    const storage: PinataStorageParams = {
      pinataApiKey: process.env.PINATA_API_KEY!,
      pinataSecretKey: process.env.PINATA_SECRET!,
    };

    const sdk = AssetsSDK.create({
      api,
      storage,
      sender,
    });

    const nft = sdk.openNftItem(Address.parse("NFT_ADDRESS"));
    const RECEIVER_ADDRESS = Address.parse("RECIEVER_ADDRESS");

    nft.send(sender, RECEIVER_ADDRESS);
    ```

    OR you can use an NFT Contract with built-in methods:

    ```ts
    const client = new TonClient({
      endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
    });
    const provider = tonConnectUi;
    const nftItem = client.open(
      NftItem.createFromAddress(Address.parse("[NFT_WALLET]"))
    );

    // https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
    const sender = new TonConnectSender(provider);
    await nftItem.send(sender, Address.parse("[SENDER_WALLET]"));

    // TIP: NFTs can include royalties, allowing creators to earn a percentage from each sale.
    // Here is an example of how to get it.
    const royalty = await nftItem.getRoyaltyParams();
    const royaltyPercent =
      Number(royalty.numerator) / Number(royalty.denominator);
    ```

  </TabItem>
</Tabs>

### NFT sale (GetGems)

Here is an example of preparing message and transaction for sale on GetGems marketplace, according to contract [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc).

To place NFT on the GetGems Sale Contract, we should prepare a special message body, `transferNftBody`, to transfer NFT to the special NFT Sale contract.

```js
const transferNftBody = beginCell()
  .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
  .storeUint(0, 64) // query_id
  .storeAddress(Address.parse(destinationAddress)) // new_owner - GetGems sale contracts deployer, should never change for this operation
  .storeAddress(Address.parse(walletAddress)) // response_destination for excesses
  .storeBit(0) // we do not have custom_payload
  .storeCoins(toNano("0.2")) // forward_amount
  .storeBit(0) // we store forward_payload is this cell
  .storeUint(0x0fe0ede, 31) // not 32, because previous 0 will be read as do_sale opcode in deployer
  .storeRef(stateInitCell)
  .storeRef(saleBody)
  .endCell();
```

Because the message requires a lot of steps, the entire algorithm is huge and can be found here:

<details>
  <summary>Show entire algorithm for the creating NFT Sale message body</summary>

```js
import {
  Address,
  beginCell,
  StateInit,
  storeStateInit,
  toNano,
  Cell,
} from "@ton/ton";

async function main() {
  // func:0.4.4 src:op-codes.fc, imports/stdlib.fc, nft-fixprice-sale-v3r3.fc
  // If GetGems updates its sale smart contract, you will need to obtain the new smart contract from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/nft-fixprice-sale-v3/NftFixpriceSaleV3.source.ts.
  const NftFixPriceSaleV3R3CodeBoc =
    "te6ccgECDwEAA5MAART/APSkE/S88sgLAQIBYgIDAgLNBAUCASANDgL30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppj+mfmBg4KYVjgGAASpiFaY+F7xDhgEoYBWmfxwjFsxsLcxsrZBZjgsk5mW8oBfEV4ADJL4dwEuuk4QEWQIEV3RXgAJFZ2Ngp5OOC2HGBFWAA+WjKFkEINjYQQF1AYHAdFmCEAX14QBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkCH6RFtwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhtQRSH6RFtwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWoMAGQwMWyy1DDQ0wchgCCw8tGVIsMAjhSBAlj4I1NBobwE+CMCoLkTsPLRlpEy4gHUMAH7AATwU8fHBbCOXRNfAzI3Nzc3BPoA+gD6ADBTIaEhocEB8tGYBdD6QPoA+kD6ADAwyDICzxZY+gIBzxZQBPoCyXAgEEgQNxBFEDQIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVOCz4wIwMTcowAPjAijAAOMCCMACCAkKCwCGNTs7U3THBZJfC+BRc8cF8uH0ghAFE42RGLry4fX6QDAQSBA3VTIIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVADiODmCEAX14QAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFwVBcAXjMQNBAjCMjLABfLH1AFzxZQA88WAc8WAfoCzMsfyz/J7VQAGDY3EDhHZRRDMHDwBQAgmFVEECQQI/AF4F8KhA/y8ADsIfpEW3CAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FMjLH1Iwyz8kzxZQBM8WE8oAggnJw4D6AhLKAMlxgBjIywUnzxZw+gLLaswl+kRbyYMG+wBxVWD4IwEIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVACHvOFnaiaGmAaY/9IH0gfSB9AGppj+mfmC3ofSB9AH0gfQAYKaFQkNDggPlozJP9Ii2TfSItkf0iLcEIIySsKAVgAKrAQAgb7l72omhpgGmP/SB9IH0gfQBqaY/pn5gBaH0gfQB9IH0AGCmxUJDQ4ID5aM0U/SItlH0iLZH9Ii2F4ACFiBqqiU";
  const NftFixPriceSaleV3R3CodeCell = Cell.fromBoc(
    Buffer.from(NftFixPriceSaleV3R3CodeBoc, "base64")
  )[0];

  const marketplaceAddress = Address.parse(
    "EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS"
  ); // GetGems Address
  const marketplaceFeeAddress = Address.parse(
    "EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS"
  ); // GetGems Address for Fees
  const destinationAddress = Address.parse(
    "EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR"
  ); // GetGems sale contracts deployer

  const walletAddress = Address.parse(
    "EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162"
  );
  const royaltyAddress = Address.parse(
    "EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162"
  );
  const nftAddress = Address.parse(
    "EQCUWoe7hLlklVxH8gduCf45vPNocsjRP4wbX42UJ0Ja0S2f"
  );
  const price = toNano("5"); // 5 TON

  const feesData = beginCell()
    .storeAddress(marketplaceFeeAddress)
    // 5% - GetGems fee
    .storeCoins((price / BigInt(100)) * BigInt(5))
    .storeAddress(royaltyAddress)
    // 5% - Royalty, can be changed
    .storeCoins((price / BigInt(100)) * BigInt(5))
    .endCell();

  const saleData = beginCell()
    .storeBit(0) // is_complete
    .storeUint(Math.round(Date.now() / 1000), 32) // created_at
    .storeAddress(marketplaceAddress) // marketplace_address
    .storeAddress(nftAddress) // nft_address
    .storeAddress(walletAddress) // previous_owner_address
    .storeCoins(price) // full price in nanotons
    .storeRef(feesData) // fees_cell
    .storeUint(0, 32) // sold_at
    .storeUint(0, 64) // query_id
    .endCell();

  const stateInit: StateInit = {
    code: NftFixPriceSaleV3R3CodeCell,
    data: saleData,
  };
  const stateInitCell = beginCell().store(storeStateInit(stateInit)).endCell();

  // not needed, just for example
  const saleContractAddress = new Address(0, stateInitCell.hash());

  const saleBody = beginCell()
    .storeUint(1, 32) // just accept coins on deploy
    .storeUint(0, 64)
    .endCell();

  const transferNftBody = beginCell()
    .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
    .storeUint(0, 64) // query_id
    .storeAddress(destinationAddress) // new_owner
    .storeAddress(walletAddress) // response_destination for excesses
    .storeBit(0) // we do not have custom_payload
    .storeCoins(toNano("0.2")) // forward_amount
    .storeBit(0) // we store forward_payload is this cell
    .storeUint(0x0fe0ede, 31) // not 32, because we stored 0 bit before | do_sale opcode for deployer
    .storeRef(stateInitCell)
    .storeRef(saleBody)
    .endCell();
}
```

</details>

The prepared `transferNftBody` should be sent to the NFT Item contract with at least `1.08` TON, which is expected for successful processing. Excess will be returned to a sender's wallet.

<Tabs groupId="NftSaleFixPrice">
  <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

    ```js
    import { useTonConnectUI } from '@tonconnect/ui-react';
    import { toNano } from '@ton/ton'

    const myTransaction = {
        validUntil: Math.floor(Date.now() / 1000) + 360,
        messages: [
            {
                address: NFTitem, //address of the NFT Item contract, that should be placed on market
                amount: toNano("0.3").toString(), // amount that will require on gas fees, excess will be return
                payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
            }
        ]
    }

    export const Settings = () => {
        const [tonConnectUI, setOptions] = useTonConnectUI();

        return (
            <div>
                <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                    Send transaction
                </button>
            </div>
        );
    };
    ```

  </TabItem>

  <TabItem value="tonconnect-ui" label="@tonconnect/ui">

    ```js
    import TonConnectUI from '@tonconnect/ui'
    import { toNano } from '@ton/ton'

    const transaction = {
        validUntil: Math.floor(Date.now() / 1000) + 360,
        messages: [
            {
                address: NFTitem, //address of NFT Item contract, that should be placed on market
                amount: toNano("0.3").toString(), // amount that will require on gas fees, excess will be return
                payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
            }
        ]
    }

    const result = await tonConnectUI.sendTransaction(transaction)
    ```

  </TabItem>
</Tabs>

### NFT buy (GetGems)

<Tabs groupId="NftBuyTabs">
  <TabItem value="@ton/ton" label="@ton/ton">
    The process of buying NFT for [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc) sale contract could be carried out with a regular transfer without payload. The only important thing is the accurate TON amount, which is calculated as follows:
    `buyAmount = Nftprice TON + 1.0 TON`.

    <Tabs groupId="NftBuy">
      <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

        ```js
        import { useTonConnectUI } from '@tonconnect/ui-react';
        import { toNano } from '@ton/ton'

        const myTransaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
                    amount: toNano(buyAmount).toString(), // NFT Price + exactly 1 TON, excess will be returned
                }
            ]
        }

        export const Settings = () => {
            const [tonConnectUI, setOptions] = useTonConnectUI();

            return (
                <div>
                    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                        Send transaction
                    </button>
                </div>
            );
        };
        ```

      </TabItem>

      <TabItem value="tonconnect-ui" label="@tonconnect/ui">

        ```js
        import TonConnectUI from '@tonconnect/ui'
        import { toNano } from '@ton/ton'

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 360,
            messages: [
                {
                    address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
                    amount: toNano(buyAmount).toString(), // NFT Price + exactly 1 TON, excess will be returned
                }
            ]
        }

        const result = await tonConnectUI.sendTransaction(transaction)
        ```

      </TabItem>
    </Tabs>

  </TabItem>

  <TabItem value="assets/sdk" label="assets/sdk">

    :::tip
    Note: For the browser, you must set a polyfill for `Buffer`.
    :::

    For more examples, check [documentation](https://github.com/ton-community/assets-sdk)

    ```js
    const nft = sdk.openNftSale(Address.parse("NFT_ADDRESS"));
    nft.sendBuy(sdk.sender!, { queryId: BigInt(1) })
    ```

  </TabItem>
</Tabs>

## See also

- [TON Connect SDKs](/v3/guidelines/ton-connect/guidelines/developers)
- [TON Connect - sending messages](/v3/guidelines/ton-connect/guidelines/sending-messages)
- [Smart contract development - sending messages](/v3/documentation/smart-contracts/message-management/sending-messages)
- [TON jetton processing](/v3/guidelines/dapps/asset-processing/jettons)
- [NFT processing on TON](/v3/guidelines/dapps/asset-processing/nft-processing/nfts)

<Feedback />
