import Feedback from '@site/src/components/Feedback';

# Random number generation

Generating random numbers is a common task in many projects. While you may have seen the [`random()`](/v3/documentation/smart-contracts/func/docs/stdlib#random) function in FunC documentation, note that its result can be easily predicted unless you use additional techniques.

## How can someone predict a random number?

Computers struggle to generate truly random information because they strictly follow user instructions. To address this, developers have created methods for generating pseudorandom numbers.

These algorithms typically require a _seed_ value to produce a sequence of _pseudorandom_ numbers. You will always get the same result if you run the same program with the same _seed_ multiple times. In TON, the _seed_ varies for each block.

- [Generation of block random seed](/v3/guidelines/smart-contracts/security/random)

To predict the result of the `random()` function in a smart contract, one would need to know the current _seed_ of the block, which is impossible for non-validators before block production.

There are multiple approaches to generate random values, each offering different trade-offs between speed, security, and decentralization guarantees.

Below, we outline three fundamental approaches:

---

## Approach 1: [randomize_lt()](/v3/documentation/smart-contracts/func/docs/stdlib#randomize_lt) \{#randomize_lt}

**Mechanism**: generates [randomness using transaction logical time](/v3/guidelines/smart-contracts/security/ton-hack-challenge-1/#4-lottery) (`lt`) and blockchain entropy.

**Security model**:

- ✅ Safe against user manipulation
- ❌ Vulnerable to colluding validators (could predict/influence values)

**Speed**: fast (single-block operation)

**Use cases**:

- Non-critical applications, for example, gaming and NFTs
- Scenarios where validator trust is assumed

---

## Approach 2: block skipping \{#block-skip}

**Mechanism**: uses [entropy from skipped blocks](https://github.com/puppycats/ton-random#ton-random) in blockchain history (see also [guidance](/v3/guidelines/smart-contracts/security/random#conclusion)).

**Security model**:

- ✅ Resistant to user manipulation
- ⚠️ Not fully secure against determined validators (may influence block inclusion timing)

**Speed**: slow (requires multiple blocks to finalize)

**Use cases**:

- Medium-stakes applications, for example, lottery systems
- Scenarios with partial trust in a validator set

---

## Approach 3: commit‑reveal scheme \{#commit-reveal}

**Mechanism**:

1. **Commit phase**: participants submit hashed secrets
2. **Reveal phase**: secrets are disclosed and combined to generate final randomness

**Security model**:

- ✅ Cryptographically secure when properly implemented
- ✅ More resilient to user manipulation; validators may still influence via timing or censorship—no method is perfectly unpredictable on TON.
- ⚠️ Requires smart-contract (on-chain) verification of commitments and incentives/penalties for non-reveals.

**Speed**: very slow (multi-phase, multi-block process)

**Use cases**:

- High-value applications, for example, decentralized auctions
- Systems requiring Byzantine fault tolerance

---

## Key considerations

| Factor                                 | `randomize_lt` | Block skipping | Commit-reveal |
| -------------------------------------- | -------------- | -------------- | ------------- |
| Speed                                  | Fast           | Slow           | Very slow     |
| Resistance to user manipulation        | High           | High           | Highest       |
| Resistance to validator manipulation   | Low            | Medium         | High          |
| Implementation complexity              | Low            | Medium         | High          |

---

:::caution
Single-block randomness (for example, [`randomize_lt()`](/v3/guidelines/smart-contracts/security/random-number-generation#randomize_lt)) is not secure against validators who can influence or predict values.
For stronger guarantees, consider multi-phase schemes such as [commit–reveal](/v3/guidelines/smart-contracts/security/random-number-generation#commit-reveal).


When choosing an approach, weigh:

- Value-at-risk in your application
- Required time-to-finality
- Trust assumptions about validators
:::


Always audit implementations through formal verification where possible.

<Feedback />
