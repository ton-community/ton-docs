# TL-B Language

:::caution advanced level
This information is **very low-level** and could be hard to understand for newcomers.
So feel free to read about it later.
:::

TL-B (Type Language - Binary) serves to describe the type system, constructors and existing functions. For example, we
can use TL-B schemes to build binary structures associated with TON Blockchain. Special TL-B parsers can read schemes to
deserialize binary data into different objects.

## Overview

<img alt="tlb structure" src="/img/docs/tlb.drawio.svg" width={'100%'}/>

We refer to any set of TL-B constructs as TL-B documents. A TL-B document usually consists of declarations of types (
i.e. their constructors) and functional combinators. The declaration of each combinator ends with a semicolon (`;`).

## Constructors

Constructors are used to specify the type of combinator, including the state at serialization. For example, constructors
can also be used when you want to specify an `op` in query to a smart contract in TON.

```tlb
// ....
message#3f5476ca value:# = CoolMessage;

bool_true$0 = Bool;
bool_false$1 = Bool;

// ....
```

The left-hand side of each equation describes the way to define, or serialize, a value of the type indicated on the
right-hand side. Such a description begins with the name of a constructor, such as `message` or `bool_true`, immediately
followed by an optional constructor tag, such as `#3f5476ca` or `$0`, which describes the bitstring used to encode (serialize)
the constructor in question.

| constructor                | serialization                             |
|----------------------------|-------------------------------------------|
| `some#3f5476ca`            | 32-bit uint serialize from hex value      |
| `some$0101`                | serialize `0101` raw bits                 |
| `some` or `some#`          | serialize `crc32(equation) \| 0x80000000` |
| `some#_` or `some$_` or `_` | serialize nothing                         |

Constructor names (`some` in this example) are used as variables in codegen. For example:

```tlb
bool_true$1 = Bool;
bool_false$0 = Bool;
```

Type `Bool` has two tags `0` and `1`. Codegen pseudocode might look like:

```python3

class Bool:
    tags = [0, 1]
    tags_names = ['bool_true', 'bool_false']
```

If you don't want to define any name for current constructor, just pass `_`, e.g. `_ a:(## 32) = 32Int;`

Constructor tags may be given in either binary (after a dollar sign) or hexadecimal notation (after a hash sign). If a tag is not
explicitly provided, the TL-B parser must compute a default 32-bit constructor tag by hashing with CRC32 algorithm
the text of the “equation” with `| 0x80000000` defining this constructor in a certain fashion. Therefore, empty tags
must be explicitly provided by `#_` or `$_`.

All constructor names must be distinct and constructor tags for the same type must constitute a prefix code (otherwise
the deserialization would not be unique); i.e. no tag can be a prefix of any other in same type.


## Field definitions

The constructor and its optional tag are followed by field definitions. Each field definition is of the
form `ident:type-expr`, where ident is an identifier with the name of the field (replaced by an underscore for
anonymous fields), and type-expr is the field’s type. The type provided here is a type expression, which may include
simple types, parametrized types with suitable parameters or complex expressions.

<b>Simple types:</b>

- `_ a:# = Type;` - `Type.a` here is 32 bit integer
- `_ a:(## 64) = Type;` - `Type.a` here is 64 bit integer
- `_ a:Owner = NFT;` - `Type.a` here is `Owner` type

<b>Parametrized types:</b>

Suppose we have IntWithObj type: 

```tlb
_ {X:Type} a:# b:X = IntWithObj X;
```

Now we can use it in other types:

```tlb
_ a:(IntWithObj uint32) = IntWithUint32;
```

<b>Complex expressions:</b>

- Conditional fields (only for `Nat`) (`E?T` means if expression `E` is True than field has type `T`)
   ```tlb
   _ a:(## 1) b:a?(## 32) = Example;
   ``` 
   In `Example` type variable `b` serialized only if `a` is `1`

- Multiply expression (`x * Type` means copy object X times):
    ```tlb
    a$_ a:(## 32) = A;
    b$_ b:(2 * A) = B;
    ```
  
   ```tlb
   _ (## 1) = Bit;
   _ 2bits:(2 * Bit) = 2Bits;
   ```

- Bit selection (only for `Nat`) (`E . B` means take bit `B` of `Nat` `E`)
   ```tlb
   _ a:(## 2) b:(a . 1)?(## 32) = Example;
   ``` 
  In `Example` type variable `b` serialized only if second bit `a` is `1`

- Other `Nat` operators also allowed (look `Allowed contraints`)
  
## Built-in types

- `#` - `Nat` 32 bits
- `## x` - `Nat` with `x` bits
- `#< x` - `Nat` less than `x` bit integer stored as `x` bits
- `#<= x` - `Nat` less than `x` bit integer stored as `x` bits
- `Any`
- `Cell` - rest of cell
- `Int` - 257 bits
- `UInt` - 256 bits
- `Bits` - 1023 bits
- `uint1` - `uint256` - 1 - 256 bits
- `int1` - `int257` - 1 - 257 bits
- `bits1` - `int1023` - 1 - 1023 bits

## Constraints

```tlb
_ flags:(## 10) { flags <= 100 } = Flag;
```

`Nat` fields allowed in constraints. In this example `{ flags <= 100 }` constraint means that `flag` variable is less or
equal `100`.

Allowed contraints: `E` | `E = E` | `E <= E` | `E < E` | `E >= E` | `E > E` | `E + E` | `E * E` | `E ? E`


//todo
```tlb
_ a:(## 32) { b:# } { ~b = a + 100 } = B_Calc_Example;
```

## TODO

Variables — i.e. the (identifiers of the) previously
defined fields of types `#` (natural numbers) or `Type` (type of types) — may be used as parameters for the parametrized
types. The serialization process recursively serializes each field according to its type and the serialization of a
value ultimately consists of the concatenation of bitstrings representing the constructor (i.e. the constructor tag) and
the field values.

Some fields may be implicit. Their definitions are surrounded by curly
brackets(`{`, `}`), which indicate that the field is not actually present in the serialization, but that its value must
be deduced from other data (usually the parameters of the type being serialized). Example:

```tlb
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
```

Finally, some equalities/inequalities may be included in curly brackets as well. These are certain “equations” which
must be satisfied by the “variables” included in them. If one of the variables is prefixed by a tilde (~), its value
will be uniquely determined by the values of all other variables participating in the equation (which must be known at
this point) when the definition is processed from the left to the right. For example:

```tlb
addr_std$10 anycast:(## 1) {anycast = 0}
      workchain_id:int8 address:bits256 = MsgAddrSmpl;
```

Some occurrences of “variables” (i.e. already-defined fields) are prefixed by a tilde(`~`). This indicates that the
variable’s occurrence is used in the opposite way to the default behavior: on the left-hand side of the equation, it
means that the variable will be deduced (computed) based on this occurrence, instead of substituting its previously
computed value; in the right-hand side, conversely, it means that the variable will not be deduced from the type being
serialized, but rather that it will be computed during the deserialization process. In other words, a tilde transforms
an “input argument” into an “output argument” or vice versa.

For example, we can use this to write a TL-B scheme for a simple transaction in TON with comment (which must be
serialized as a sequence of cells):

```tlb
empty#_ b:bits = Snake ~0;
cons#_ {n:#} b:bits next:^(Snake ~n) = Snake ~(n + 1);

op:#0 comment:Snake = Request;
```

A caret (`ˆ`) preceding a type `X` means that instead of serializing a value of type `X` inside the current cell, we
place this value into a separate cell and add a reference to it into the current cell. Therefore `ˆX` means “the type of
next reference of cell containing values of type `X`”.

Parametrized type `#<= p` with `p : #` (this notation means `“p of type #”`, i.e. a natural number) denotes the subtype
of the natural numbers type `#`, consisting of integers `0 ... p;` it is serialized into `[log2(p + 1)]` bits as an
unsigned big-endian integer. Type `#` by itself is serialized as an unsigned 32-bit integer. Parametrized type `## b`
with `b : #<=31` is equivalent to `#<= 2^b − 1`  (i.e. it is an unsigned b-bit integer). For example:

```tlb
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
```

In this scheme `mode:(## 8)` will be serialized as an 8-bit unsigned integer.



```tlb

```

## Comments

Comments are the same as in C++

```tlb
/* 
This is
a comment 
*/

// This is one line comment
```

## IDE Support

The [intellij-ton](https://github.com/andreypfau/intellij-ton) plugin supports Fift, FunC and also TL-B.  
The TL-B grammar is described in
the [TlbParser.bnf](https://github.com/andreypfau/intellij-ton/blob/main/src/main/grammars/TlbParser.bnf) file.

## Useful sources

- [Telegram Open Network Virtual Machine](https://ton.org/tvm.pdf)
- [A description of an older version of TL](https://core.telegram.org/mtproto/TL)
- [block.tlb](https://github.com/newton-blockchain/ton/blob/master/crypto/block/block.tlb)

_Thanks to the [Vudi](https://github.com/Vudi) and [cryshado](https://github.com/cryshado) for contributing to the
community!_
