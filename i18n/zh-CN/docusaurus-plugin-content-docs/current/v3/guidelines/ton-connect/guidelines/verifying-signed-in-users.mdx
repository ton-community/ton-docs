import Feedback from '@site/src/components/Feedback';

import ThemedImage from '@theme/ThemedImage';

# Verifying signed-in users on the backend

This page describes a method for the backend to ensure that the user truly owns the declared address.

Note that user verification is not required for all dApps.

It is helpful if you want to verify a user by providing them with their personal information from the backend.

## 它是如何工作的？

- User initiates the sign-in process.
- Backend generates a `ton_proof` entity and sends it to frontend.
- Frontend signs in to wallet using `ton_proof` and receives a signed `ton_proof`.
- Frontend sends signed `ton_proof` to backend for verification.

<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/docs/ton-connect/ton_proof_scheme.svg?raw=true',
        dark: '/img/docs/ton-connect/ton_proof_scheme-dark.svg?raw=true',
    }}
/>
<br></br>

## Structure of the ton_proof

We will use the  `ton_proof`, implemented inside the connector.

```js
type TonProofItemReply = TonProofItemReplySuccess | TonProofItemReplyError;

type TonProofItemReplySuccess = {
  name: "ton_proof";
  proof: {
    timestamp: string; // 64-bit unix epoch time of the signing operation (seconds)
    domain: {
      lengthBytes: number; // AppDomain Length
      value: string;  // app domain name (as url part, without encoding)
    };
    signature: string; // base64-encoded signature
    payload: string; // payload from the request
  }
}

```

## Checking ton_proof on server side

1. 从用户处检索 `TonProofItemReply`。
2. Verify that the received domain corresponds to your application's domain.
3. Check if `TonProofItemReply.payload` is permitted by the original server and is still active.
4. 检查 `timestamp` 是否为当前实际值。
5. 根据 [信息方案](/v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#concept-explanation) 组装信息。
6. 从应用程序接口 (a) 或通过后端逻辑 (b) 获取 `public_key`

- 6a:
  - 使用 [TON API](https://docs.tonconsole.com/tonapi#:~:text=/v2/-,tonconnect,-/stateinit) 方法 `POST /v2/tonconnect/stateinit` 从 `walletStateInit` 获取 `{public_key, address}`。
  - Verify that the address extracted from `walletStateInit` to the wallet `address` declared by the user.
- 6b:
  - 通过钱包合约 [get method](https://github.com/ton-blockchain/wallet-contract/blob/main/func/wallet-v4-code.fc#L174) 获取钱包的 `public_key`。
  - If the contract is inactive or lacks the get_method found in older wallet versions (v1-v3), then obtaining the key in this manner will be impossible. Instead, you must parse the walletStateInit provided by the front end. Ensure that TonAddressItemReply.walletStateInit.hash() equals TonAddressItemReply.address.hash(), indicating a BoC hash.

7. Verify that the `signature` from the front end correctly signs the assembled message and matches the `public_key` of the address.

## React example

1. Add a token provider to the root of your app:

```tsx
function App() {
    const [token, setToken] = useState<string | null>(null);

  return (
      <BackendTokenContext.Provider value={{token, setToken}}>
            { /* Your app */ }
      </BackendTokenContext.Provider>
  )
}
```

2. Implement authentication on the front end with backend integration:

<details>
<summary>示例</summary>

```tsx
import {useContext, useEffect, useRef} from "react";
import {BackendTokenContext} from "./BackendTokenContext";
import {useIsConnectionRestored, useTonConnectUI, useTonWallet} from "@tonconnect/ui-react";
import {backendAuth} from "./backend-auth";

const localStorageKey = 'my-dapp-auth-token';
const payloadTTLMS = 1000 * 60 * 20;

export function useBackendAuth() {
    const { setToken } = useContext(BackendTokenContext);
    const isConnectionRestored = useIsConnectionRestored();
    const wallet = useTonWallet();
    const [tonConnectUI] = useTonConnectUI();
    const interval = useRef<ReturnType<typeof setInterval> | undefined>();

    useEffect(() => {
        if (!isConnectionRestored || !setToken) {
            return;
        }

        clearInterval(interval.current);

        if (!wallet) {
            localStorage.removeItem(localStorageKey);
            setToken(null);

            const refreshPayload = async () => {
                tonConnectUI.setConnectRequestParameters({ state: 'loading' });

                const value = await backendAuth.generatePayload();
                if (!value) {
                    tonConnectUI.setConnectRequestParameters(null);
                } else {
                    tonConnectUI.setConnectRequestParameters({state: 'ready', value});
                }
            }

            refreshPayload();
            setInterval(refreshPayload, payloadTTLMS);
            return;
        }

        const token = localStorage.getItem(localStorageKey);
        if (token) {
            setToken(token);
            return;
        }

        if (wallet.connectItems?.tonProof && !('error' in wallet.connectItems.tonProof)) {
            backendAuth.checkProof(wallet.connectItems.tonProof.proof, wallet.account).then(result => {
                if (result) {
                    setToken(result);
                    localStorage.setItem(localStorageKey, result);
                } else {
                    alert('Please try another wallet');
                    tonConnectUI.disconnect();
                }
            })
        } else {
            alert('Please try another wallet');
            tonConnectUI.disconnect();
        }

    }, [wallet, isConnectionRestored, setToken])
}
```

</details>

## Backend example

<details>
<summary>Check if proof valid with [ton-proof-service](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/services/ton-proof-service.ts)</summary>

```tsx
public async checkProof(payload: CheckProofRequestDto, getWalletPublicKey: (address: string) => Promise<Buffer | null>): Promise<boolean> {
  try {
    const stateInit = loadStateInit(Cell.fromBase64(payload.proof.state_init).beginParse());
  
    // 1. First, try to obtain the public key via the get_public_key get-method on the smart contract deployed at Address.
    // 2. If the smart contract is not deployed yet, or the get-method is missing, you need:
    //  2.1. Parse TonAddressItemReply.walletStateInit and get public key from stateInit. You can compare the walletStateInit.code
    //  with the code of standard wallet contracts and parse the data according to the found wallet version.
    let publicKey = tryParsePublicKey(stateInit) ?? await getWalletPublicKey(payload.address);
    if (!publicKey) {
      return false;
    }
  
    // 2.2. Check that TonAddressItemReply.publicKey equals to obtained public key
    const wantedPublicKey = Buffer.from(payload.public_key, 'hex');
    if (!publicKey.equals(wantedPublicKey)) {
      return false;
    }
  
    // 2.3. Check that TonAddressItemReply.walletStateInit.hash() equals to TonAddressItemReply.address. .hash() means BoC hash.
    const wantedAddress = Address.parse(payload.address);
    const address = contractAddress(wantedAddress.workChain, stateInit);
    if (!address.equals(wantedAddress)) {
      return false;
    }
  
    if (!allowedDomains.includes(payload.proof.domain.value)) {
      return false;
    }
  
    const now = Math.floor(Date.now() / 1000);
    if (now - validAuthTime > payload.proof.timestamp) {
      return false;
    }
  
    const message = {
      workchain: address.workChain,
      address: address.hash,
      domain: {
        lengthBytes: payload.proof.domain.lengthBytes,
        value: payload.proof.domain.value,
      },
      signature: Buffer.from(payload.proof.signature, 'base64'),
      payload: payload.proof.payload,
      stateInit: payload.proof.state_init,
      timestamp: payload.proof.timestamp
    };
  
    const wc = Buffer.alloc(4);
    wc.writeUInt32BE(message.workchain, 0);
  
    const ts = Buffer.alloc(8);
    ts.writeBigUInt64LE(BigInt(message.timestamp), 0);
  
    const dl = Buffer.alloc(4);
    dl.writeUInt32LE(message.domain.lengthBytes, 0);
  
    // message = utf8_encode("ton-proof-item-v2/") ++
    //           Address ++
    //           AppDomain ++
    //           Timestamp ++
    //           Payload
    const msg = Buffer.concat([
      Buffer.from(tonProofPrefix),
      wc,
      message.address,
      dl,
      Buffer.from(message.domain.value),
      ts,
      Buffer.from(message.payload),
    ]);
  
    const msgHash = Buffer.from(await sha256(msg));
  
    // signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
    const fullMsg = Buffer.concat([
      Buffer.from([0xff, 0xff]),
      Buffer.from(tonConnectPrefix),
      msgHash,
    ]);
  
    const result = Buffer.from(await sha256(fullMsg));
  
    return sign.detached.verify(result, message.signature, publicKey);
  } catch (e) {
    return false;
  }
}

```

</details>

您可以查看我们展示主要方法的 [示例](https://github.com/ton-connect/demo-dapp-with-react-ui/tree/master/src/server)：

- [generatePayload](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/generate-payload.ts): Generates a payload for `ton_proof`.
- [checkProof](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/check-proof.ts)：检查证明并返回访问令牌。

## Concept explanation

If `TonProofItem` is requested, the wallet proves ownership of the selected account’s key. The signed message is bound to:

- Unique prefix to separate messages from on-chain messages. (`ton-connect`)
- Wallet address
- 应用域名
- 签署时间戳
- 应用程序的自定义有效载荷（服务器可在其中放置非密钥、cookie id 和过期时间）

```
message = utf8_encode("ton-proof-item-v2/") ++
          Address ++
          AppDomain ++
          Timestamp ++
          Payload

signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
```

where:

- `Address` is the wallet address encoded as a sequence:
- `workchain`: 32-bit signed integer big endian;
- `hash`：256 位无符号整数，大端位；
- `AppDomain` 是 Length ++ EncodedDomainName

<!---->

- `Length` 是 utf-8 编码的应用域名长度，以字节为单位的 32 位值。
- `EncodedDomainName` 是一个 `Length` 字节的 utf-8 编码应用域名。

<!---->

- `Timestamp` 是签名操作的64位unix时代时间
- `Payload` 是一个可变长度的二进制字符串。

注意：有效载荷是长度可变的非信任数据。我们将其放在最后，以避免使用不必要的长度前缀。 We put it last to avoid using unnecessary length prefixes.

The signature must be verified using the public key:

1. First, try to obtain the public key via the `get_public_key` get-method on the smart contract deployed at `Address`.

2. 如果智能合约尚未部署，或缺少get-method，您需要：

   1. Parse `TonAddressItemReply.walletStateInit` and get public key from stateInit. You can compare the `walletStateInit.code` with the code of standard wallet contracts and parse the data according to the found wallet version.

   2. 检查 `TonAddressItemReply.publicKey` 是否等于获取的公钥

   3. Check that `TonAddressItemReply.walletStateInit.hash()` equals `TonAddressItemReply.address`. `.hash()` means BoC hash.

### Verification examples

- [GO 演示应用](https://github.com/ton-connect/demo-dapp-backend/blob/master/proof.go)
- [Rust demo app](https://github.com/liketurbo/demo-dapp-backend-rs)
- [JS demo app](https://github.com/liketurbo/demo-dapp-backend-js)
- [Python示例](https://github.com/XaBbl4/pytonconnect/blob/main/examples/check_proof.py)
- [PHP示例](https://github.com/vladimirfokingithub/Ton-Connect-Proof-Php-Check)
- [C# 演示应用程序](https://github.com/WinoGarcia/TonProof.NET)

## See also

- [Preparing messages](/v3/guidelines/ton-connect/guidelines/preparing-messages)
- [Sending messages](/v3/guidelines/ton-connect/guidelines/sending-messages)
- [[YouTube]为 @tonconnect/react-ui 检查 ton_proof [RU]](https://youtu.be/wIMbkJHv0Fs?list=PLyDBPwv9EPsCJ226xS5_dKmXXxWx1CKz_&t=2971)

<Feedback />
