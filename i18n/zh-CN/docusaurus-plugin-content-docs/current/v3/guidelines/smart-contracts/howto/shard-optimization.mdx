import Feedback from '@site/src/components/Feedback';

# TON 分片优化

## 架构基础知识

TON processes countless transactions in parallel. This capability relies on the infinite sharding paradigm. When the load on a group of validators approaches its throughput limit, the system splits (shards) the group. Two groups of validators then independently and in parallel process this load. The system deterministically performs these splits, and the contract address associated with the transaction determines which group processes it. The system processes addresses close to each other (sharing the same prefix) in the same shard.TON processes countless transactions in parallel. This capability relies on the [infinite sharding paradigm](/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm). When the load on a group of validators approaches its throughput limit, the system splits (shards) the group. Two groups of validators then independently and in parallel process this load. The system deterministically performs these splits, and the contract address associated with the transaction determines which group processes it. The system processes addresses close to each other (sharing the same prefix) in the same shard.

When one contract sends a message to another, two scenarios can occur: either both contracts reside in the same shard or in different shards. In the first scenario, the current group already holds all the necessary data and can process the message immediately. In the second scenario, the system must route the message from one group to another. To prevent message loss or double-processing, the system requires proper accounting. It achieves this by registering a queue of outgoing messages from the sender's shard in a MasterChain block. The receiver's shard must explicitly confirm that it has processed this queue. This overhead slows down cross-shard message delivery, as the system requires at least one MasterChain block between the block where the message was sent and the block where it was consumed. Typically, this delay lasts about 12-13 seconds.

由于一个账户的交易总是在一个分片中处理，因此单个账户的每秒交易速度（TPS）是有限的。这意味着，在为新的大规模协议开发架构时，应尽量避免中心点。此外，如果一连串的交易遵循相同的路径，也不会因为分片而得到更快的处理速度：链中每个合约的 TPS 限制相同，但由于交付延迟，整个链的处理时间会更长。 This limitation means that when designing an architecture for a new mass-scale protocol, you should aim to avoid central points. Furthermore, if a chain of transactions follows the same route, sharding will not speed up its processing. Each contract in the chain will face the same TPS limit, and delivery latency will increase the overall chain processing time.

在大规模系统中，延迟和吞吐量之间的权衡是区分优秀协议和卓越协议的关键。

## To shard or not to shard

为了改善用户体验和处理时间，协议需要了解其系统中哪些部分可以并行处理，因此应该分片以提高吞吐量，哪些部分是严格按顺序处理的，因此如果放在一个分片中，会降低延迟。 They must also determine which parts are strictly sequential and will achieve lower latency if placed in the same shard.

A prime example of throughput optimization involves Jettons. Since transfers from A to B and C to D operate independently, the system can process them in parallel. jetton 就是吞吐量优化的一个很好的例子。由于从 A 到 B 和从 C 到 D 的转账互不依赖，因此可以并行处理。通过将所有 Jetton-wallet 随机、均匀地分布在地址空间中，我们可以在区块链上实现负载的完美分布，并在适当延迟的情况下实现每秒数百次（未来可达数千次）的吞吐量。

On the other hand, consider a smart contract, contract A, that interacts with jettons. Suppose contract A performs an action when it receives jetton X, and its associated jetton wallet is contract B. Placing contract A and contract B in different shards will not increase throughput. Instead, each incoming transfer will follow the same chain of addresses, creating bottlenecks at each step. Placing contracts A and B in the same shard improves latency, reducing the overall chain processing time.

## 智能合约开发人员的实用结论

If you rely on a single smart contract to execute business logic, consider deploying multiple instances of that contract to leverage TON’s parallelism. If this approach isn’t feasible and your smart contract interacts with a predefined set of other contracts (such as jetton wallets), aim to place them in the same shard. You can often achieve this off-chain by brute-forcing specific contract addresses to ensure all desired jetton wallets have neighboring addresses. In some cases, onchain brute-forcing is also acceptable.

Upcoming node and network performance improvements will likely boost the throughput of individual shards and reduce delivery latency. However, these advancements will coincide with a growing number of users. As more users join the network, shard optimization will become increasingly critical. Eventually, it will determine the success of mass-scale applications: users will naturally prefer the most convenient option, meaning the application with lower latency. Therefore, don’t delay shard-optimizing your application in anticipation of overall network improvements. Act now! In many cases, shard optimization may even outweigh gas optimization in importance.

## 服务的实际结论

### 存款

If you expect deposits at a rate exceeding, for example, 30 transfers per second, you should use multiple addresses to accept them in parallel and achieve high throughput. If you know the user’s deposit address — for instance, through a transaction initiated via TON Connect - select the deposit address closest to the user’s wallet address. Below is the ready-to-use TypeScript code for choosing the closest address:

```typescript

import { Address } from '@ton/ton';

function findMatchingBits (a: number, b: number, start_from: number) {
    let bitPos    = start_from;
    let keepGoing = true;
    do {
        const bitCount = bitPos + 1;
        const mask     = (1 << (bitCount)) - 1;
        const shift    = 8 - bitCount;
        if(((a >> shift) & mask) == ((b >> shift) & mask)) {
            bitPos++;
        }
        else {
            keepGoing = false;
        }
    } while(keepGoing && bitPos < 7);

    return bitPos;
}

function chooseAddress(user: Address, contracts: Address[]) {
    const maxBytes = 32;
    let byteIdx = 0;
    let bitIdx  = 0;
    let bestMatch: Address | undefined;

    if(user.workChain !== 0) {
        throw new TypeError(`Only basechain user address allowed:${user}`);
    }
    for(let testContract of contracts) {
        if(testContract.workChain !== 0) {
            throw new TypeError(`Only basechain deposit address allowed:${testContract}`);
        }
        if(byteIdx >= maxBytes) {
            break;
        }
        if(byteIdx == 0 || testContract.hash.subarray(0, byteIdx).equals(user.hash.subarray(0, byteIdx))) {
            let keepGoing  = true;
            do {
                if(keepGoing && testContract.hash[byteIdx] == user.hash[byteIdx]) {
                    bestMatch = testContract;
                    byteIdx++;
                    bitIdx = 0;
                    if(byteIdx == maxBytes) {
                        break;
                    }
                }
                else {
                    keepGoing = false;
                    if(bitIdx < 7) {
                        const resIdx = findMatchingBits(user.hash[byteIdx], testContract.hash[byteIdx], bitIdx);
                        if(resIdx > bitIdx) {
                            bitIdx = resIdx;
                            bestMatch = testContract;
                        }
                    }
                }
            } while(keepGoing);
        }
    }
    return {
        match: bestMatch,
        prefixLength: byteIdx * 8 + bitIdx
    }
}
```

If you expect jetton deposits, you should not only create multiple deposit addresses but also shard-optimize them. Ensure each deposit address resides in the same shard as its corresponding jetton wallet. You can use a generator for such addresses, available [here](https://github.com/Trinketer22/turbo-wallet). Additionally, selecting the deposit address closest to the user’s wallet address will further improve efficiency.

### 提款

取款也是如此；如果您需要每秒发送大量转账，建议您拥有多个发送地址，必要时使用 jetton-wallets 对它们进行 shard 优化。

## 分片优化 101

### Explain shards like I'm from web 2

TON 区块链与其他任何区块链一样是一个网络，因此尝试用 web 2（ipv4）网络术语来解释它是有意义的。

#### Endpoints

在一般网络中，终端是一个物理设备，而在区块链中，终端是一个智能合约。

#### Shards

In this analogy, a shard functions like a subnet. The key difference lies in the addressing scheme: IPv4 uses a 32-bit system, while TON employs a 256-bit one.\
The shard prefix of a contract address identifies the group of validators responsible for computing the results of its incoming messages. From a networking perspective, a request within the same network segment processes faster than one routed elsewhere. This principle resembles using a CDN to host content closer to end users; in TON, we deploy contracts closer to the users.

When the load on a shard surpasses a [certain threshold](/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm#algorithm-for-deciding-whether-to-split-or-merge), the system splits the shard. This split allocates dedicated computational resources to the overloaded contract and isolates its impact on the broader network. Currently, the maximum shard prefix length is 4 bits, allowing the blockchain to split into a maximum of 16 shards, ranging from prefix 0 to 15.

### 分片优化过程中的问题

让我们更加务实

#### 检查两个地址是否属于同一分片

由于我们知道分片前缀最多为 4 位，因此其代码片段可以如下所示：

```typescript
import { Address } from '@ton/core';
const addressA = Address.parse(...);
const addressB = Address.parse(...);

if((addressA.hash[0] >> 4) == (addressb.hash[0] >> 4)) {
  console.log("Same shard");
} else {
  console.log("Nope");
}
```

From the human perspective, the easiest way to check the address shard is to look at the address [raw form](/v3/concepts/dive-into-ton/ton-blockchain/smart-contract-addresses#raw-address).
One could use the [address page](https://ton.org/address/) for it.
Let's test it on the USDT address, for example: `EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs`.
You will see `0:b113a994b5024a16719f69139328eb759596c38a25f59028b146fecdc3621dfe` as a raw representation, and the first 4 bits are essentially the first hexadecimal symbol - `b`.
Now we know that the USDT minter is located in shard `b` (hex) or `11` (decimal).

### 如何将合约部署到某个分片

To understand how this works, you must first grasp how a contract address [depends](/v3/documentation/smart-contracts/addresses#account-id) on its code and data. Essentially, the system generates the address by computing a SHA256 hash of the contract’s code and data at deployment time.  

Given this, the only way to deploy a contract with the same code in a different shard is to manipulate its initial data. The data field influencing the resulting contract address is called a _nonce_. You can use any field that is either safe to update after deployment or does not directly affect contract execution for this purpose.  

One of the earliest examples of this principle in action is the [vanity contract](https://github.com/ton-community/vanity-contract). It includes a `salt` data field specifically designed to _brute-force_ a value that produces the desired address pattern.  

Placing a contract into a specific shard follows the same approach, except the prefix you need to match is much shorter. A simple starting point for this is the wallet contract.  

- [为不同分片创建钱包](/v3/guidelines/dapps/asset-processing/payments-processing/#wallet-creation-for-different-shards) 这篇文章说明了使用公钥作为非密钥将钱包放入特定分片的情况。
- 另一个例子是[turbo-wallet](https://github.com/Trinketer22/turbo-wallet/blob/d239c1a1ac31c7f5545c2ef3ddc909d6cbdafe24/src/lib/contracts/HighloadWalletV3.ts#L44)使用 subwalletId 实现[相同](https://github.com/Trinketer22/turbo-wallet/blob/d239c1a1ac31c7f5545c2ef3ddc909d6cbdafe24/src/lib/turboWallet.ts#L80)的目的。
  你也可以使用合约构造函数快速扩展[ShardedContract](https://github.com/Trinketer22/turbo-wallet/blob/main/src/lib/ShardedContract.ts)接口，使其成为_sharded_。
  You can pretty quickly extend the [ShardedContract](https://github.com/Trinketer22/turbo-wallet/blob/main/src/lib/ShardedContract.ts) interface using your contract constructor to make it _sharded_ too.

## 大规模 jetton 配送解决方案

If you need to distribute jettons to tens or hundreds of thousands - or even millions - of users, refer to this [page](/v3/guidelines/dapps/asset-processing/mintless-jettons). We recommend leveraging existing, battle-tested services. Several of these solutions are deeply optimized, offering shard-optimized performance and lower costs compared to custom-built alternatives:

- **免铸造 Jettons：** 当你需要在代币生成活动（TGE）期间分发代币时，你可以允许用户直接从代币钱包合约中领取预定义的空投。这种方法很便宜，不需要额外的交易，而且按需提供（只有现在需要花费代币的用户才能领取）。 This approach is cost-effective, eliminates the need for additional transactions, and operates on-demand (only users ready to spend jettons will claim them).
- **用于 jetton  群发的Tonapi解决方案：** 允许通过直接发送到用户钱包的方式分发现有 jetton  。经过 Notcoin 和 DOGS 的实战测试（各有几百万次传输），经过优化以减少延迟、吞吐量和成本。[大量发送 jetton](https://docs.tonconsole.com/tonconsole/jettons/mass-sending) Proven by Notcoin and DOGS (handling millions of transfers each), it optimizes latency, throughput, and costs. [Mass jetton sending](https://docs.tonconsole.com/tonconsole/jettons/mass-sending).
- **[TokenTable solution](https://docs.tokentable.xyz/) for decentralized claim:** This approach lets users claim jettons from specific claim transactions (users cover the fees). Tested by Avacoin and DOGS (millions of transfers), it maximizes throughput while managing costs.

<Feedback />
