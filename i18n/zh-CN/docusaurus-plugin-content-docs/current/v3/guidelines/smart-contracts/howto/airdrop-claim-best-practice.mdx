import Feedback from '@site/src/components/Feedback';

# 空投领取指南

In this article, we'll explore an imaginary claim solution, identify its performance issues, and propose solutions. The focus will be on contract interactions and their impact on overall performance. Code, security aspects, and other nuances are beyond the scope of this discussion.

## Claim machine

:::info
How does a typical claim solution work? Let's break it down.
:::

The user submits some form of proof to demonstrate eligibility for the claim. The solution verifies the proof and sends jettons to the user. In this case, `proof` refers to a [merkle proof](/v3/documentation/data-formats/tlb/exotic-cells#merkle-proof), but it could also be signed data or any other authorization method. To send jettons, we'll need a jetton wallet and minter. Additionally, we must prevent users from claiming twice—this requires a double-spend protection contract. And, of course, we'd like to monetize this, right? So, we'll need at least one claim wallet. Let's summarize:

### Distributor

Takes the proof from the user, checks it, and releases the jettons.
State init: `(merkle_root, admin, fee_wallet_address)`.

### Double spend

接收信息，如果已使用则跳转，否则继续传递信息

### Jetton

Jetton wallet, where the tokens will be sent from by the _distributor_.
Jetton minter is out of the scope of this article.

### 收费钱包

任何类型的钱包合约

## 架构

### V1

我首先想到的设计是这样的：

1. 用户向 distributor 发送证明
2. distributor 检查证明并部署 `双花` 合约
3. distributor 将信息传递给双花。
4. 如果之前没有部署，双倍花费会向分发者发送 `claim_ok` 文件
5. distributor 将费用发送至费用钱包
   **MORE NAIVE ART**
6. distributor 向用户发放 jetton。

**NAIVE ART AHEAD!**

What's wrong with that?
Looks like a loop is redundant here.

### V2

线性设计要好得多：

1. 用户部署 "双重花费"，并将证明代理给 distributor
2. distributor 通过状态 init `(distributor_address, user_address?)` 检查发送 "双倍花费 "的地址
3. distributor 检查校样，在这种情况下，用户索引应是校样的一部分，然后放行。
4. distributor 将领取费用发送到费用钱包。

**More naive art**

## 分片优化

好了，我们有了一些进展，但分片优化呢？

### 这些是什么？

To build a fundamental understanding, refer to [wallet creation for different shards](/v3/guidelines/dapps/asset-processing/payments-processing/#wallet-creation-for-different-shards). In short, a shard is a 4-bit address prefix, similar to networking. When contracts are in the same network segment, messages are processed without routing, making them significantly faster.

### 确定我们可以控制的地址

#### distributor 地址

We have full control over the distributor's data and can place it in any shard. How? Remember, the contract address is [defined by its state](/v3/documentation/smart-contracts/addresses#account-id). We can use one of the contract's data fields as a nonce and keep trying until we achieve the desired result. A good example of a nonce in actual contracts is the `subwalletId` or `publicKey` for a wallet contract. Any field that can be modified after deployment or doesn't impact the contract logic (like `subwalletId`) will work. You could even create an unused field explicitly for this purpose, as demonstrated by [vanity-contract](https://github.com/ton-community/vanity-contract).

#### distributor jetton 钱包

We can't directly control the resulting jetton wallet address. However, if we control the distributor address, we can choose it so that the resulting jetton wallet ends up in the same shard. How? There's a [library](https://github.com/Trinketer22/turbo-wallet) for that! While it currently supports only wallets, extending it to arbitrary contracts is relatively easy. Please take a look at how it's implemented for [HighloadV3](https://github.com/Trinketer22/turbo-wallet/blob/44fe7ee4300e37e052871275be8dd41035d45c3a/src/lib/contracts/HighloadWalletV3.ts#L20).

### 双花合约

The double-spend contract should be unique per proof, so can we shard-tune it? Let's think about it. If you consider the proof structure, it depends on how the data is organized. The first idea that comes to mind is a structure similar to [mintless jettons](https://github.com/tonkeeper/TEPs2/blob/mintles/text/0177-mintless-jetton-standard.md#handlers):

```
_ amount:Coins start_from:uint48 expired_at:uint48 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;

```

在这种情况下，当然是无法调整的，因为地址分布是随机的，而且所有数据字段都是有意义的。
但没有什么能阻止我们这样做： However, nothing stops us from modifying it like this:

```
_ amount:Coins start_from:uint48 expired_at:uint48 nonce:uint64 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;
```

甚至

```
_ amount:Coins start_from:uint48 expired_at:uint48 addr_hash: uint256 = AirdropItem;

_ _(HashMap 64 AirdropItem) = Airdrop;

```

其中，64 位索引可用作 nonce，而地址则成为数据有效载荷的一部分，用于验证。
因此，如果由 `(distributor_address, index)` 构建双花数据，其中索引是数据的一部分，我们仍然可以获得初始可靠性，但现在地址分片可以通过索引参数进行调整。 If the double-spend data is constructed from `(distributor_address, index)`, where the index is part of the data, we maintain reliability while making the address shard tunable via the index parameter.

#### 用户地址

We don't control user addresses, right? Yes, **BUT** we can group them so that the user address shard matches the distributor shard. In this case, each distributor processes a `merkle root` consisting entirely of users from its shard.

Here's the improved and more polished version of your text:

#### 总结

We can place the `double_spend -> dist -> dist_jetton` chain in the same shard. What remains for other shards is the `dist_jetton -> user_jetton -> user_wallet` path.

### 我们如何实际部署这种设置

Let's break it down step by step. One key requirement is that the _distributor_ contract must have an updatable _merkle root_.

1. 使用初始 `merkle_root` 作为 nonce，在每个分片（0-15）内部署分发器，与其 jetton 钱包位于同一分片内
2. Group users by their distributor shard.
3. 为每个用户找到这样的索引，这样就可以 _双花_ 合约 `(distributor, index)` 最终与用户地址在同一分片中。
4. 用上面步骤中的索引生成 _默克尔根_
5. 让我们一步步来看看。
   其中一个要求是 _distributor_ 合约必须有可更新的 _merkle root_ 文件。

Now, everything should be ready to go!

### V3

1. 用户使用索引调整功能在同一分片部署 _双花_ 合约
2. 用户分片中的分发器通过状态 init `(distributor_address, index)` 检查发送 "双花 "的地址
3. distributor 将费用发送至费用钱包
4. Distributor 检查证明，在这种情况下，用户索引应是证明的一部分，并通过同一分片中的 jetton 钱包释放 jetton 。

**Bit more art**

Is there anything wrong with this approach? Let's take a closer look.\
...\
Yes, there is! There's only one fee wallet, and fees queue up to a single shard. This could have been a disaster! (Has this ever happened in real life?).

### V4

1. 与 V3 相同，但现在有 16 个钱包，每个钱包与其 _distributor_ 在同一个分片。
2. Make the _fee wallet_ address updatable.

**A bit more art**

How about now? LGTM.

## 下一步是什么？

We can always push further. 我们总能更进一步。
来看看内置分片优化功能的自定义 [jetton 钱包](https://github.com/ton-community/mintless-jetton/blob/main/contracts/jetton-utils.fc#L142)。
因此，用户的 jetton 钱包最终会以 87% 的概率与用户在同一个分片中。
但这还只是一个未知领域，所以你只能靠自己了。
祝你在 TGE 中好运！ This ensures the user's jetton wallet ends up in the same shard as the user with an 87% probability. However, this is relatively uncharted territory, so you'll need to explore it on your own. Good luck with your TGE!

<Feedback />
