import Feedback from '@site/src/components/Feedback';

# 区块随机 seed 的生成

:::caution\
This information is accurate at the time of writing. It may change during any network upgrade.\
:::

Lottery contracts occasionally appear on TON. These contracts often use unsafe methods to handle randomness, making the generated values predictable and allowing the lottery to be exploited.

Exploiting weaknesses in random number generation typically involves using a proxy contract that forwards a message if the random value meets specific conditions. While proposals exist for wallet contracts that can execute arbitrary on-chain code (specified and signed by the user), most popular wallet versions do not support this functionality. 但是，利用随机数生成中的弱点通常涉及使用代理合约，如果随机值正确，代理合约会转发消息。存在有关钱包合约的提案，这些合约将能够执行链上任意代码（当然由用户指定和签名），但大多数流行的钱包版本不支持这样做。那么，如果彩票检查赌徒是否通过钱包合约参与，它是否安全？

或者，这个问题可以这样表述。外部消息能否被包含在随机值正好符合发送者需求的区块中？

The sender cannot influence randomness directly. However, validators generating blocks and including proposed external messages can.

## 验证者如何影响seed

Limited information about this topic, even in whitepapers, confuses developers. 即使在白皮书中，关于这一点的信息也不多，所以大多数开发者都感到困惑。这是关于区块随机的唯一提及，在 [TON白皮书](https://docs.ton.org/ton.pdf) 中：

> The algorithm used to select validator task groups for each shard (w, s) is deterministic pseudorandom. 为每个分片(w, s)选择验证者任务组的算法是确定性伪随机的。**它使用验证者嵌入到每个主链区块中的伪随机数（通过使用阈值签名达成共识）来创建随机seed**，然后为每个验证者计算例如Hash(code(w). code(s).validator_id.rand_seed)。

However, the most reliable and up-to-date source is the code itself. 然而，唯一被保证真实且最新的是代码。所以让我们看看 [collator.cpp](https://github.com/ton-blockchain/ton/blob/f59c363ab942a5ddcacd670c97c6fbd023007799/validator/impl/collator.cpp#L1590)：

```cpp
  {
    // generate rand seed
    prng::rand_gen().strong_rand_bytes(rand_seed->data(), 32);
    LOG(DEBUG) << "block random seed set to " << rand_seed->to_hex();
  }
```

This code generates the random seed for a block. 这是生成区块随机seed的代码。它位于协作者代码中，因为它由生成区块的一方需要（并且对轻量级验证者不是必需的）。

A single validator or collator generates the seed when creating a block. This raises the following question:

## 在知道seed后是否可以决定包含外部消息？

Yes, it can. Here’s why: if the system imports an external message, its execution must succeed. Since execution can depend on random values, the block seed must be known beforehand.

因此，如果发送者可以与验证者合作，那么确实**存在**一种方法来攻击"不安全"（让我们称之为单区块，因为它不使用发送消息后的任何区块信息）随机。即使使用了`randomize_lt()`。验证者可以生成适合发送者的seed，或者将提议的外部消息包含在将满足所有条件的区块中。这样做的验证者仍然被认为是公平的。这就是去中心化的本质。 Even if the contract uses `randomize_lt()`, the validator can generate a suitable seed or include the proposed external message in a block that meets all conditions. A validator acting in this way would still be considered fair. This is the essence of decentralization.

为了让这篇文章完全覆盖随机性，这里还有一个问题。

## 区块seed如何影响合约中的随机数？

The seed generated by the validator is not used directly in all contracts. 验证者生成的seed并不直接用于所有合约。相反，它是[与账户地址一起哈希](https://github.com/ton-blockchain/ton/blob/f59c363ab942a5ddcacd670c97c6fbd023007799/crypto/block/transaction.cpp#L876)的。

```cpp
bool Transaction::prepare_rand_seed(td::BitArray<256>& rand_seed, const ComputePhaseConfig& cfg) const {
  // we might use SHA256(block_rand_seed . addr . trans_lt)
  // instead, we use SHA256(block_rand_seed . addr)
  // if the smart contract wants to randomize further, it can use RANDOMIZE instruction
  td::BitArray<256 + 256> data;
  data.bits().copy_from(cfg.block_rand_seed.cbits(), 256);
  (data.bits() + 256).copy_from(account.addr_rewrite.cbits(), 256);
  rand_seed.clear();
  data.compute_sha256(rand_seed);
  return true;
}
```

然后，伪随机数是使用 [TVM指令](/learn/tvm-instructions/instructions#112-pseudo-random-number-generator-primitives) 页面上描述的过程生成的：

> **x\{F810} RANDU256**\
> Generates a new pseudorandom unsigned 256-bit Integer x. **x\{F810} RANDU256**\
> 生成一个新的伪随机无符号256位整数x。算法如下：如果r是随机seed的旧值，被视为一个32字节的数组（通过构造无符号256位整数的大端表示），那么计算它的sha512(r)；这个哈希的前32字节被存储为随机seed的新值r'，剩余的32字节作为下一个随机值x返回。

我们可以通过查看 [准备c7合约](https://github.com/ton-blockchain/ton/blob/master/crypto/block/transaction.cpp#L903) 的代码（c7是存储临时数据的元组，存储合约地址、起始余额、随机seed等）和 [随机值本身的生成](https://github.com/ton-blockchain/ton/blob/master/crypto/vm/tonops.cpp#L217-L268) 来确认这一点。 and [generating random values](https://github.com/ton-blockchain/ton/blob/master/crypto/vm/tonops.cpp#L217-L268).

## 结论

TON中没有随机是完全安全的，就不可预测性而言。这意味着**这里不可能存在完美的彩票**，也不可能相信任何彩票是公平的。 This means **no perfect lottery can exist on TON**, nor can any lottery be fully trusted to be fair.

Typical usage of pseudorandom number generators (PRNGs) may include `randomize_lt()`, but such contracts can still be tricked by selecting the correct blocks to send messages. Proposed solutions, such as sending messages to another workchain and receiving a response to skip blocks, only delay the threat. In reality, any validator (representing 1/250 of the TON Blockchain) can choose the optimal time to send a request to a lottery contract so that the response arrives in a block they generate. They can then select any block seed they desire. This risk will increase once collators are introduced to the mainnet, as standard complaints cannot fine them since they do not stake anything in the Elector contract.

<!-- TODO: Find an example contract using random without any additions and demonstrate how to determine the result of RANDU256 knowing the block random seed (include a link to dton.io to show the generated value). -->  

<!-- TODO: Next article. "Let's proceed to writing a tool that exploits this. It will attach to a validator and include proposed external messages in blocks satisfying specific conditions—provided a fee is paid." -->  

<Feedback />

