import Feedback from '@site/src/components/Feedback';

import ThemedImage from "@theme/ThemedImage";

# 安全智能合约编程

在本节中，我们将介绍 TON 区块链最有趣的几个功能，然后介绍开发人员在 FunC 上编写智能合约的最佳实践清单。

## 合约分片

在为 EVM 开发合约时，为了方便起见，通常会将项目拆分为多个合约。在某些情况下，可以在一份合约中实现所有功能，即使在有必要拆分合约的情况下（例如，自动做市商中的流动性对），也不会造成任何特殊困难。交易全部执行：要么全部成功，要么全部失败。 In some cases, it’s possible to implement all functionality in a single contract, and even when splitting is necessary, such as with Liquidity Pairs in an Automated Market Maker, it doesn’t introduce significant complexity. Transactions are executed entirely: either everything succeeds, or everything reverts.

在 TON 中，强烈建议避免 "无界数据结构 (unbounded data structures)" 和[将单个逻辑合约分割成小块](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons)，每个小块管理少量数据。基本的例子是 TON Jettons 的实现。这是 TON 版本的以太坊 ERC-20 代币标准。简而言之，我们有 A basic example is the implementation of TON Jettons, TON’s version of Ethereum’s ERC-20 token standard. In short:

1. 一个 `jetton-minter`，用于存储 `total_supply`、`minter_address` 和几个引用：令牌描述（元数据）和 `jetton_wallet_code`。
2. 还有大量的 jetton 钱包，每个 jetton 的所有者都有一个。每个钱包只存储所有者的地址、余额、jetton-minter 地址和 jetton_wallet_code 的链接。

这样做是必要的，因为这样可以在钱包之间直接传输 Jettons，而不会影响任何高负载地址，这对并行处理交易至关重要。 As a result, your contract will likely become a “group of contracts” that actively interact with each other.

## 可以部分执行交易

![smart1.png](/img/docs/security-measures/secure-programming/smart1.png)

A unique property of TON smart contracts is the possibility of partial transaction execution. 例如，一个典型的流程启动（见 TON Jetton 报文流程）：

1. 发送者会向其钱包 (`sender_wallet`)发送一条`op::transfer`信息；
2. `sender_wallet` 减少令牌余额；
3. 发送方钱包向接收方钱包（目的地钱包）发送 `op::internal_transfer` 消息；
4. `destination_wallet` 增加其令牌余额；
5. `destination_wallet` 向其所有者 (`destination`)发送 `op::transfer_notification` ；
6. `destination_wallet` 在 `response_destination` （通常是 `sender`）上返回带有 `op::excesses` 信息的多余 gas 。

请注意，如果 `destination_wallet` 无法处理 `op::internal_transfer` 消息（出现异常或 gas 耗尽），则不会执行此部分和后续步骤。但第一步（减少 `sender_wallet` 中的余额）将会完成。结果是部分执行了交易，`Jetton`的状态不一致，在这种情况下，钱会丢失。 However, the first step, reducing the balance in `sender_wallet`, will still complete. This results in partial transaction execution, an inconsistent state of the `Jetton`, and potential loss of funds.

In the worst-case scenario, all tokens could be stolen this way. For example, if you first credit bonuses to a user and then send an `op::burn` message to their Jetton wallet, you cannot guarantee that the `op::burn` will succeed.

## TON 智能合约开发者必须控制 gas

In Solidity, gas management is less of a concern for contract developers. If a user provides insufficient gas, the transaction reverts, though the gas is not refunded. If they provide enough gas, the actual costs are automatically calculated and deducted from their balance.

在 TON，情况有所不同：

1. 如果没有足够的 gas ，交易将被部分执行；
2. 如果 gas 过多，多余部分必须退还。这是开发商的责任；
3. 如果 "一组合约" 交换信息，则必须在每条信息中进行控制和计算。

TON 无法自动计算 gas 。交易的完整执行及其所有后果可能需要很长时间，到最后，用户钱包里可能没有足够的 TON 币。这里再次使用了携带价值原则。 Since transaction execution can take a long time, the user might run out of TON coins by the end. This is where the carry-value principle comes into play.

## TON 智能合约开发人员必须管理存储空间

TON 中典型的消息处理程序就是采用这种方法：

```func
() handle_something(...) impure {
    (int total_supply, <a lot of vars>) = load_data();
    ... ;; do something, change data
    save_data(total_supply, <a lot of vars>);
}
```

不幸的是，我们注意到一种趋势：`<a lot of vars>` 是对所有合约数据字段的真正枚举。例如 For example:

```func
(
    int total_supply, int swap_fee, int min_amount, int is_stopped, int user_count, int max_user_count,
    slice admin_address, slice router_address, slice jettonA_address, slice jettonA_wallet_address,
    int jettonA_balance, int jettonA_pending_balance, slice jettonB_address, slice jettonB_wallet_address,
    int jettonB_balance, int jettonB_pending_balance, int mining_amount, int datetime_amount, int minable_time,
    int half_life, int last_index, int last_mined, cell mining_rate_cell, cell user_info_dict, cell operation_gas,
    cell content, cell lp_wallet_code
) = load_data();
```

这种方法有许多缺点。

1. 首先，如果您决定添加另一个字段，例如 `is_paused`，那么您就需要更新整个合约中的 `load_data()/save_data()` 语句。这不仅耗费大量人力，还会导致难以捕捉的错误。
2. Namespace pollution can lead to bugs, such as shadowing a storage field with a local variable, which can overwrite the contract state.
3. 最后，每次调用每个函数时都要解析整个存储空间并打包回去，这也增加了 gas 成本。

> 在最近的一次 CertiK 审核中，我们注意到开发人员在某些地方混淆了两个参数，并写道：  
>
> ```func
> save_data(total_supply, min_amount, swap_fee, ...)
> ```
>
> Without an external audit by a team of experts, detecting such a bug is challenging. The function was rarely used, and the confused parameters often had a value of zero. Identifying this type of error requires knowing exactly what to look for.\
> Secondly, "namespace pollution" is a common issue. For example, in another audit, we found the following code in the middle of a function:  
>
> ```func
> int min_amount = in_msg_body~load_coins();
> ```
>
> Here, a local variable shadowed a storage field, and at the end of the function, the overwritten value was stored in the contract state. This allowed an attacker to manipulate the contract’s state. The problem is exacerbated by FunC’s allowance of [variable redeclaration](/v3/documentation/smart-contracts/func/docs/statements#variable-declaration): “This is not a declaration, but just a compile-time insurance that `min_amount` has type `int`.”

## 小贴士

### 1. 1.始终绘制信息流程图

即使是在像 TON Jetton 这样的简单合约中，也已经有相当多的消息、发送方、接收方以及消息中包含的数据块。现在想象一下，当你在开发一些更复杂的东西时，比如去中心化交易所（DEX），一个工作流中的消息数量可能会超过十条，你会怎么想？ For more complex contracts like decentralized exchanges (DEXs), the number of messages in a single workflow can exceed ten.

![smart2.png](/img/docs/security-measures/secure-programming/smart2.png)

在 CertiK，我们使用 [DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language))语言在审计过程中描述和更新此类图表。我们的审计人员发现，这有助于他们直观地理解合约内部和合约之间复杂的互动关系。 This helps auditors visualize and understand complex interactions within and between contracts.

### 2. 2.避免失败并捕捉被退回的信息

Define the entry point in your message flow—the message that initiates the cascade of messages in your contract group. Perform all necessary checks (payload, gas supply, etc.) here to minimize the chance of failure in subsequent stages.

If you’re unsure whether all conditions will be met, such as whether the user has enough tokens, the message flow is likely designed incorrectly.

在随后的信息（后果）中，所有 `throw_if()/throw_unless()` 都将扮演断言的角色，而不是实际检查什么。 许多合约还会处理退回的邮件，以防万一。

例如，在 TON Jetton 中，如果收件人的钱包无法接受任何代币（这取决于接收逻辑），那么发件人的钱包将处理退回的消息，并将代币返还到自己的余额中。

```func
() on_bounce (slice in_msg_body) impure {
    in_msg_body~skip_bits(32);  ;;0xFFFFFFFF

    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();

    int op = in_msg_body~load_op();

    throw_unless(error::unknown_op, (op == op::internal_transfer) | (op == op::burn_notification));

    int query_id = in_msg_body~load_query_id();
    int jetton_amount = in_msg_body~load_coins();

    balance += jetton_amount;
    save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
}
```

While handling bounced messages is recommended, it’s not a complete solution. 发送和处理被退回的消息需要消耗 gas ，如果发件人没有提供足够的 gas ，那么就没有被退回的消息。 Additionally, TON doesn’t support chain bounces, so a bounced message cannot be re-bounced.

### 3. Expect a man-in-the-middle attack

A message cascade can span multiple blocks. Assume that while one message flow is running, an attacker can initiate a parallel flow. If a property, such as the user’s token balance, is checked at the start, don’t assume it will remain valid at later stages.

### 4. 4.使用携带值 (Carry-Value) 模式

由上一段可以看出，合约之间的消息必须携带有值的内容。 在同一个 TON Jetton 中，这一点得到了证明：`sender_wallet` 减去余额并将其与 `op::internal_transfer` 消息一起发送到 `destination_wallet`，反过来，它收到余额并将其与消息一起添加到自己的余额中（或将其弹回）。

An incorrect implementation would be querying the Jetton balance on-chain. By the time the response to `op::get_balance` arrives, the balance might have already been spent.

Instead, implement an alternative flow:

1. 主账户向钱包发送信息 `op::provide_balance` ；
2. 钱包将余额清零，并发回 `op::take_balance`；
3. The master receives the funds, decides if they’re sufficient, and either uses them or returns them to the wallet.

### 5. 5.返回值而不是拒绝

Contracts often receive requests with values. Instead of rejecting invalid requests via `throw_unless()`, return the value to the sender.

例如，考虑一下标准 TON Jetton 的信息流：

1. `sender` 通过 `sender_wallet` 向 `your_contract_wallet` 发送 `op::transfer` 消息，并为您的合约指定 `forward_ton_amount` 和 `forward_payload`；
2. `sender_wallet` 向 `your_contract_wallet` 发送 `op::internal_transfer` 信息；
3. `your_contract_wallet` 向 `your_contract` 发送 `op::transfer_notification` 消息，传递 `forward_ton_amount`, `forward_payload`, 以及 `sender_address` 和 `jetton_amount` ；
4. 在合约的 `handle_transfer_notification()` 中，流程开始了。

At this stage, avoid `throw_if()/throw_unless()`, as it could result in lost Jettons. Use try-catch statements, available in FunC v0.4.0+, to handle errors and return Jettons if necessary.

### 6. 6.计算 gas 并检查 msg_value

根据消息流程图，我们可以估算出每种情况下每个处理程序的成本，并插入 msg_value 的充分性检查。 Avoid demanding excessive gas, as it must be divided among subsequent messages. 如果在开发过程中，您的代码开始发送更多信息，情况就会变得更加复杂。需要重新检查和更新 gas 要求。

### 7. 7.小心退回多余 gas

If excess gas isn’t returned to the sender, funds will accumulate in your contracts. While not catastrophic, this is suboptimal. 如果不将多余的 gas 退还给寄件人，这些资金就会在您的合约中长期累积。从原则上讲，这并不可怕，只是一种次优做法。您可以添加一个功能来清除多余的 gas ，但像 TON Jetton 这样的流行合约仍会以信息 `op::excesses` 返回发送者。

TON provides a useful mechanism: `SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64`. This mode forwards remaining gas with the message. However, avoid this mode if:

1. Your contract has no other non-linear handlers, as storage fees will deplete the contract balance.
2. 如果您的合约发出事件，即向外部地址发送信息。该操作的费用将从合约余额中扣除，而不是从 msg_value 中扣除。
3. 如果您的合约在发送信息时附加了值或使用了 `SEND_MODE_PAY_FEES_SEPARETELY = 1`。这些操作会从合约余额中扣除，这意味着未使用的返回是 "亏本工作"。

In these cases, manually calculate and return excess gas:

```func
int ton_balance_before_msg = my_ton_balance - msg_value;
int storage_fee = const::min_tons_for_storage - min(ton_balance_before_msg, const::min_tons_for_storage);
msg_value -= storage_fee + const::gas_consumption;

if(forward_ton_amount) {
    msg_value -= (forward_ton_amount + fwd_fee);
...
}

if (msg_value > 0) {    ;; there is still something to return

var msg = begin_cell()
    .store_uint(0x10, 6)
    .store_slice(response_address)
    .store_coins(msg_value)
...
}
```

请记住，如果合约余额用完，交易将被部分执行，这是不允许的。

### 10. 使用更多的辅助函数，避免魔法数字

Organize storage into blocks of related data:

```func
() handle_something(...) impure {
    (slice swap_data, cell liquidity_data, cell mining_data, cell discovery_data) = load_data();
    (int total_supply, int swap_fee, int min_amount, int is_stopped) = swap_data.parse_swap_data();
    …
    swap_data = pack_swap_data(total_supply + lp_amount, swap_fee, min_amount, is_stopped);
    save_data(swap_data, liquidity_data, mining_data, discovery_data);
}
```

This approach minimizes changes when adding new fields and avoids namespace pollution. If storage contains many fields, group them hierarchically.

### 9. 9.使用 end_parse()

从存储器和消息有效载荷读取数据时，尽可能使用 `end_parse()`。由于 TON 使用的是数据格式可变的比特流，因此确保读取的数据量与写入的数据量相等是很有帮助的。这可以节省一个小时的调试时间。 This ensures you read as much as you write, preventing hard-to-debug issues.

### 10. Use helper functions and avoid magic numbers

Write wrappers, helper functions, and declare constants to improve code readability. Avoid magic numbers, as they make the code harder to understand and maintain.

For example, instead of:

```func
var msg = begin_cell()
    .store_uint(0xc4ff, 17)         ;; 0 11000100 0xff
    .store_uint(config_addr, 256)
    .store_grams(1 << 30)           ;; ~1 gram of value
    .store_uint(0, 107)
    .store_uint(0x4e565354, 32)
    .store_uint(query_id, 64)
    .store_ref(vset);

send_raw_message(msg.end_cell(), 1);
```

Use:

```func
const int SEND_MODE_REGULAR = 0;
const int SEND_MODE_PAY_FEES_SEPARETELY = 1;
const int SEND_MODE_IGNORE_ERRORS = 2;
const int SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;

builder store_msgbody_prefix_stateinit(builder b) inline {
    return b.store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1);
}

builder store_body_header(builder b, int op, int query_id) inline {
    return b.store_uint(op, 32).store_uint(query_id, 64);
}

() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_address_by_state_init(state_init);

    var msg = begin_cell()
        .store_msg_flags(BOUNCEABLE)
        .store_slice(to_wallet_address)
        .store_coins(amount)
        .store_msgbody_prefix_stateinit()
        .store_ref(state_init)
        .store_ref(master_msg);

    send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);
}
```

## 参考资料

- [原文](https://blog.ton.org/secure-smart-contract-programming-in-func)

<Feedback />
