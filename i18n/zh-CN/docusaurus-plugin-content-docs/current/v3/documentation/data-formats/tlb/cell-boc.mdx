import Feedback from '@site/src/components/Feedback';

import ThemedImage from '@theme/ThemedImage';

# cell与cell包 (BoC)

## cell

A cell is a fundamental data structure in the TON blockchain. Each cell can store up to 1023 bits of data and maintain up to 4 references to other cells.

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-5.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-5-dark.png?raw=true',
}}
/>
<br></br>

## cell包

cell包 (BoC) 是一种将cell序列化为字节数组的格式，这一格式在 [TL-B schema](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25) 中有进一步描述。

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-6.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-6-dark.png?raw=true',
}}
/>
<br></br>

在TON上，所有东西都由cell构成，包括合约代码、存储的数据、区块等，实现了过程中的流线型和强大的灵活性。

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-4.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-4-dark.png?raw=true',
}}
/>
<br></br>

### cell序列化

Let’s walk through a basic example of a BoC:

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-7.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-7-dark.png?raw=true',
}}
/>
<br></br>

```json
1[8_] -> {
  24[0AAAAA],
  7[FE] -> {
    24[0AAAAA]
  }
}
```

In this case, we have a 0-bit root cell that references two other cells:

- The first is a 24-bit cell.
- The second is a 7-bit cell that itself references a 24-bit cell.

To serialize this structure into a byte sequence, we first identify unique cells. In the example, we consider 3 unique cells out of 4 total.

```json
1[8_]
24[0AAAAA]
7[FE]
```

:::note
为了只留下唯一的cell，需要进行比较。为此，我们需要比较cell的[哈希](#cell-hash)。
:::

Next, we arrange the cells in a specific order so that parent cells never reference cells that come before them in the list. In other words, any referenced cell must appear after the cells that reference it. We get:

```json
1[8_]      -> index 0 (root cell)
7[FE]      -> index 1
24[0AAAAA] -> index 2
```

Now, let’s calculate the descriptors for each of the 3 cells mentioned earlier. These descriptors consist of 2 bytes that encode metadata about the cell’s data size and reference structure.

1. **Refs descriptor (1st byte)**

  This byte is calculated using the formula: `r + 8·s + 32·l`.

Where:

- `r` is the number of cell's references (links) in the range `0 ≤ r ≤ 4`.
- `s` is the exotic flag (1 for [exotic](#special-exotic-cells) cells, 0 for ordinary ones).
- 第一个字节 - **引用描述符** - 计算为 `r+8s+32l`，其中 `0 ≤ r ≤ 4` 是cell引用（链接）的数量，`0 ≤ s ≤ 1` 对于[异类](#special-exotic-cells)cell为1，对于普通cell为0，`0 ≤ l ≤ 3` 是cell的[层级](#cell-level)。

2. **Bits descriptor (2nd byte)**

第二个字节 - **位描述符** - 等于 `floor(b / 8) + ceil (b / 8)`，其中 `0 <= b <= 1023` 是cell中的位数。这个描述符代表cell数据的完整4位组的长度（但如果不为空至少为1）。

Where `0 <= b <= 1023` is the number of bits in the cell.

This descriptor represents the length of full 4-bit groups in the cell’s data and is always at least 1 for non-empty data.

结果是：

```json
1[8_]      -> 0201 -> 2 refs, length 1
7[FE]      -> 0101 -> 1 ref, length 1
24[0AAAAA] -> 0006 -> 0 refs, length 6
```

对于不完整的4位组的数据，在序列的末尾添加1位。这意味着它表示组的结束位，并用于确定不完整组的真实大小。让我们添加以下位： This means it denotes the end bit of the group and is used to determine the actual size of incomplete groups. Let's add the bits below:
Let’s add the end bits to each of the cells:

```json
1[8_]      -> C0     -> 0b10000000->0b11000000
7[FE]      -> FF     -> 0b11111110->0b11111111
24[0AAAAA] -> 0AAAAA -> do not change (full groups)
```

We now specify which cells each one references:

```json
0 1[8_]      -> 0201 -> refers to 2 cells with such indexes
1 7[FE]      -> 02 -> refers to cells with index 2
2 24[0AAAAA] -> no refs
```

Now we serialize the cells:

```json
0201 C0     0201
0101 FF     02
0006 0AAAAA
```

接下来，我们将上述所有内容连接成一个字节数组，得到我们最终的BoC：
`b5ee9c7201010301000e000201c002010101ff0200060aaaaa`

Size: 14 bytes.

<details>
  <summary><b>显示示例</b></summary>

```golang
func (c *Cell) descriptors() []byte {
  ceilBytes := c.bitsSz / 8
  if c.bitsSz%8 ! = 0 {
    ceilBytes++
  }

	// calc size
	ln := ceilBytes + c.bitsSz / 8

	specBit := byte(0)
	if c.special {
	  specBit = 8
	}

	return []byte{byte(len(c.refs)) + specBit + c.level*32, byte(ln)}
}
```

[来源](https://github.com/xssnick/tonutils-go/blob/3d9ee052689376061bf7e4a22037ff131183afad/tvm/cell/serialize.go#L205)

</details>

### 打包cell包

因此，我们根据其[架构](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25)构建header。

```
b5ee9c72                      -> id tl-b of the BoC structure
01                            -> flags and size:(## 3), in our case the flags are all 0,
                                 and the number of bytes needed to store the number of cells is 1.
                                 we get - 0b0_0_0_00_001
01                            -> number of bytes to store the size of the serialized cells
03                            -> number of cells, 1 byte (defined by 3 bits size:(## 3), equal to 3.
01                            -> number of root cells - 1
00                            -> absent, always 0 (in current implementations)
0e                            -> size of serialized cells, 1 byte (size defined above), equal to 14
00                            -> root cell index, size 1 (determined by 3 size:(## 3) bits from header),
                                 always 0
0201c002010101ff0200060aaaaa  -> serialized cells
```

We now concatenate the header and the serialized cell content:
`b5ee9c7201010301000e000201c002010101ff0200060aaaaa`

**BoC implementation examples**

- cell是TON区块链上的一种数据结构。cell能够存储多达1023位，并且可以拥有最多4个对其他cell的引用。
- cell包实现示例：[序列化](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/serialize.go)，[反序列化](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/parse.go)

## 特殊cell层级

通常，TON上运行的cell分为两大类：普通cell和特殊cell。用户处理的大多数cell是普通cell，负责携带信息。
Most user-facing cells are ordinary cells, which are responsible for carrying information.

然而，为了实现网络的内部功能，有时需要特殊cell，并且它们用于多种目的，这取决于它们的子类型。 Depending on their specific subtype, these cells serve various purposes.

## cell层级

每个cell都有一个称为`Level`的属性，它由0到3的整数表示。

### 普通cell层级

普通cell的层级始终等于其所有引用的层级的最大值：

```cpp
Lvl(c) = max(Lvl(r_0), ..., Lvl(r_i), ..., Lvl(r_e))
```

其中`i`是`c`的引用索引，`e`是`c`的引用数量。

_没有引用的普通cell层级为零_

### 特殊cell

特殊cell对其层级的设置有不同的规则，这些规则在[此文](/develop/data-formats/exotic-cells)中有描述。

## cell哈希

在大多数情况下，用户使用的是层级为0的普通cell，它们只有一个哈希，称为 representation hash（或 hash infinity）。

层级为`Lvl(c) = l`的cell`c`，其中`1 ≤ l ≤ 3`，除了 representation hash 外，还有`l`个**"更高"**的哈希。

### 标准cell representation hash 计算

首先，我们需要计算cell表示（类似于上面描述的cell序列化）

1. 描述符计算
2. 添加序列化cell数据
3. 对于每个cell的引用，添加其深度
4. 对于每个cell的引用，添加其 representation hash
5. 计算结果的SHA256哈希

让我们分析以下示例：

#### 无引用的cell

```json
32[0000000F]
```

1. **Descriptors computation**

   - 引用描述符等于 `r+8s+32l = 0 + 0 + 0 = 0 = 00`
   - 位描述符等于 `floor(b / 8) + ceil (b / 8) = 8 = 08`
   - Combined descriptor bytes: `0008`.

2. cell数据序列化

   - We have a complete group of 4-bit values in this case, so no padding is needed.
   - Serialized data: `0000000F`

3. **Refs depth**

   - This cell has no references, so we skip depth and reference hash steps.

4. **Refs hashes**

   - This cell has no references, so we skip depth and reference hash steps.

5. SHA256计算

   - Concatenate the bytes from the previous steps: `00080000000F`.
   - Compute the SHA-256 hash of this byte string: `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`.

   This is the **representation hash** of the cell.

#### 带有引用的cell

```json
24[00000B] -> {
	32[0000000F],
	32[0000000F]
}
```

1. **Descriptors computation**

   - 引用描述符等于 `r+8s+32l = 2 + 0 + 0 = 0 = 02`
   - 位描述符等于 `floor(b / 8) + ceil (b / 8) = 6 = 06`
   - Combined descriptor bytes: `0206`.

2. cell数据序列化

   - The data consists of complete 4-bit groups, so no padding is needed.
   - Serialized cell data: `00000B`.

3. **Refs depth**

   - The depth of each reference is represented using 2 bytes.
   - Since both references have a depth of 0, the result is: `00000000`.

4. **Refs hashes**

   - Each reference contributes its representation hash. From the previous example, the result is:

     `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`

5. SHA256计算

   - By concatenating the bytes from the previous steps, we obtain the following byte string:

   `020600000b0000000057b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`.

   - The SHA-256 hash of this byte string is:

   `f345277cc6cfa747f001367e1e873dcfa8a936b8492431248b7a3eeafa8030e7`.

   - This is the representation hash of the cell.

### 更高哈希的计算

普通cell`c`的更高哈希与其 representation hash 的计算类似，但使用其引用的更高哈希而不是它们的 representation hash。

Exotic cells follow separate rules for computing their higher hashes. These are described in detail in [this](/v3/documentation/data-formats/tlb/exotic-cells) article.

## 参阅

[//]: # "* [原文RU](https://github.com/xssnick/ton-deep-doc/blob/master/Cells-BoC.md)"

- [特殊cell](/develop/data-formats/exotic-cells)
- [默克尔证明验证](/develop/data-formats/proofs)

<Feedback />
