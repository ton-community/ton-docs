---
title: 概述
---

import Feedback from "@site/src/components/Feedback";
import Button from "@site/src/components/button";

# Tolk 语言：概述

**Tolk** 是一种在TON中编写智能合约的新语言。可以将 Tolk 视为 "**下一代 FunC**"。
Tolk 编译器是 FunC 编译器的分叉，引入了类似于 TypeScript 的熟悉语法，
，但保留了所有底层优化。
Tolk compiler is a fork of FunC compiler, introducing familiar syntax similar to TypeScript
but leaving all low-level optimizations untouched. Think of Tolk as the next‑generation FunC.

```tolk
import "storage.tolk"

fun loadData() {
    ctxCounter = getContractData().beginParse().loadUint(32);
}

fun onInternalMessage(msgValue: int, msgFull: cell, msgBody: slice) {
    var cs = msgFull.beginParse();
    var flags = cs.loadMessageFlags();
    if (isMessageBounced(flags)) {
        return;
    }
    ...
}

get currentCounter(): int {
    loadData(); // fills global variables
    return ctxCounter;
}
```

<details>
  <summary><b>参见用 FunC 实现的相同逻辑</b></summary>

```func
#include "storage.fc";

() load_data() impure {
  slice cs = get_data().begin_parse();
  ctx_counter = cs~load_uint(32);
}

() recv_internal(int msg_value, cell msg_full, slice msg_body) impure {
  slice cs = msg_full.begin_parse();
  int flags = cs.load_uint(4);
  if (flags & 1) {
    return ();
  }
  ...
}

int currentCounter() method_id {
  load_data(); ;; fills global variables
  return ctx_counter;
}
```

</details>

<Button href="https://github.com/ton-blockchain/convert-func-to-tolk" colorType={'primary'} sizeType={'sm'}>
  尝试使用 FunC → Tolk 转换器
</Button>
<Button href="/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short" colorType={'secondary'} sizeType={'sm'}>
  阅读 "Tolk vs FunC 的区别"
</Button>
<div style={{height: '2em'}}></div>

## Tolk 背后的动机

FunC is awesome.
It is low-level and encourages a programmer to think about compiler internals.
It gives complete control over TVM assembler, allowing a programmer to make his contract as effective as possible.
If you get used to it, you love it.

But there is a problem.
FunC is **functional C**, and it's for ninja.
If you are keen on Lisp and Haskell, you'll be happy.
But if you are a JavaScript / Go / Kotlin developer, its syntax is peculiar for you, leading to occasional mistakes.
A struggle with syntax may decrease your motivation for digging into TON.

想象一下，如果有一种语言，同样智能，同样低级，但不是函数式的，也不像 C 语言，那会怎样？
撇开所有的美感和复杂性不谈，如果它乍一看更像流行语言呢？
Leaving all beauty and complexity inside, what if it would be more similar to popular languages at first glance?

这就是 Tolk 的意义所在。

## 从 FunC 迁移到 Tolk

如果您了解 FunC 并想尝试新的语法，您的方法是

1. 阅读 [Tolk vs FunC: in short](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)。
2. With a blueprint, create a new Tolk contract (for example, a counter) and experiment around it. Remember that almost all stdlib functions are renamed to ~~verbose~~ clear names. Here is [a mapping](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).
3. 请尝试使用[转换器](https://github.com/ton-blockchain/convert-func-to-tolk)或[FunC 合约](/v3/documentation/smart-contracts/contracts-specs/examples)中的转换器。请记住，用 Tolk 从头开始编写的合约肯定比自动转换的合约更美观。例如，使用逻辑运算符而不是按位运算符可以大大提高代码的可读性。 Remember that contracts written in Tolk from scratch look nicer than auto-converted ones. For instance, using logical operators instead of bitwise tremendously increases code readability.

## 如果不了解 FunC，如何尝试 Tolk

:::tip 目前，本文档假定您知道 FunC
This section describes the **Tolk vs FunC** differences.
Later, it will be adapted to land newcomers. 文档介绍了 "Tolk 与 FunC" 的区别。
稍后，它将进行调整，以适应新用户的需要。此外，FunC 最终将被弃用，
，整个文档中的所有代码片段都将改写为 Tolk。
:::

如果您是 TON 的新用户，您的方法是

1. Dig into [this documentation](/v3/documentation/smart-contracts/overview) to acquire basic on development in TON. No matter your language, you must be aware of cells, slices, and TON asynchronous nature.
2. 面对 FunC 代码段，您仍然可以使用 FunC，或者尝试用 Tolk 来表达同样的意思。如果您觉得 FunC 语法很奇怪，不用担心：Tolk 的目标正是解决这个问题。 If FunC syntax is peculiar to you, don't worry: the goal of Tolk is to fix this issue precisely.
3. 一旦您对发生的事情有了一定的了解，请尝试使用 Tolk 和 [ blueprint ](https://github.com/ton-org/blueprint)。

## 围绕 Tolk 的工具

Tolk 编译器的源代码是 `ton-blockchain` [repo](https://github.com/ton-blockchain/ton) 的一部分。
除了编译器，我们还有
Besides the compiler, we have:

1. [tolk-js](https://github.com/ton-blockchain/tolk-js) - Tolk 编译器的 WASM 封装。
2. [JetBrains IDE 插件](https://github.com/ton-blockchain/intellij-ton) 除支持 FunC、Fift、TL/B 和 Tact 外，还支持 Tolk。
3. [VS 代码扩展](https://github.com/ton-blockchain/tolk-vscode) 启用 Tolk 语言支持。
4. [从 FunC 到 Tolk 的转换器](https://github.com/ton-blockchain/convert-func-to-tolk) - 使用一条 `npx` 命令将 `.fc` 文件转换为 `.tolk` 文件。
5. Tolk 可在 [ blueprint ](https://github.com/ton-org/blueprint)中使用。

## Tolk 可以生产吗？

Tolk编译器是FunC编译器的一个分叉，尽管目前还处于试验阶段，但已经可以投入生产。

Undiscovered bugs may exist, potentially inherited from FunC or attributable to TVM characteristics.
Anyway, no matter your language, you should cover your contracts with tests to reach high reliability.

## 路线图

Tolk 的第一个发布版本是 v0.6，强调 [missing](/v3/documentation/smart-contracts/tolk/changelog#how-tolk-was-born) FunC v0.5。

Here are some points to investigate:

- 类型系统改进：布尔类型、无效性、字典
- gas 和堆栈优化、AST 内联
- 扩展和维护 stdlib
- 考虑某种 ABI（探索者如何 "看到 "字节码）
- 从总体上考虑 gas 和收费管理问题

The following strategic milestone for **Tolk v1.0** is structures with auto-serialization into cells (almost done).

This milestone eliminates manual manipulations with builders and slices, allowing data and messages to be described declaratively.
Closely related to this is the **ABI (interface) of contracts**.
Well-designed structures make up the majority of an ABI.

## 问题和联系方式

如果遇到问题，请登录 [TON Dev Chats](https://t.me/addlist/1r5Vcb8eljk5Yzcy) 或创建 GitHub 问题。

## See also

- [Tolk vs FunC: in short](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)

<Feedback />
