---
hide_table_of_contents: true
wrapperClassName: bootstrap-wrapper
---

import { SearchField } from '@site/src/components/SearchField';
import { opcodes } from '@site/src/data/opcodes';

# TVM 指令

:::caution advanced level
此信息是**非常底层的**，对于新手来讲可能很难理解。
:::

## 介绍
本文档提供了TVM指令的列表，包括它们的操作码和助记符。

:::info
[**TVM.pdf**](https://ton.org/tvm.pdf) 最初概念 TON 虚拟机（可能包含过时的信息）。
:::

Fift 是一种基于栈的编程语言，旨在管理 TON 智能合约。Fift 汇编器是一个能够将 TVM 指令的助记符转换为它们的二进制表示形式的 Fift 库。

关于 Fift 的描述，包括介绍 Fift 汇编器，可在[此处](https://github.com/Piterden/TON-docs/blob/master/Fift.%20A%20Brief%20Introduction.md)找到。

本文档为每个指令指定了对应的助记符。

请注意以下几点：

1. Fift 是一种基于栈的语言，因此任何指令的所有参数都写在它之前（例如，[`5 PUSHINT`](#instr-pushint-4)，[`s0 s4 XCHG`](#instr-xchg-ij)）。
2. 栈寄存器由 `s0, s1, ..., s15` 表示。其他栈寄存器（最多255个）由 `i s()` 表示（例如，`100 s()`）。
3. 控制寄存器由 `c0, c1, ..., c15` 表示。

### Gas 价格

本文档中指定了每个指令的 gas 价格。一个指令的基本 gas 价格是 `10 + b`，其中 `b` 是指令长度（以位为单位）。某些操作有附加费用：
1. _解析cell_：将一个cell转换成一个片段的成本是 **100 gas 单位**，如果是在同一交易中首次加载该cell，则为 **25**。对于此类指令，会指定两个 gas 价格（例如，[`CTOS`](#instr-ctos): `118/43`）。
2. _cell创建_：**500 gas 单位**。
3. _抛出异常_：**50 gas 单位**。在本文档中，仅对其主要用途为抛出异常的指令指定异常费（例如，[`THROWIF`](#instr-throwif-short)，[`FITS`](#instr-fits)）。如果指令在某些情况下只抛出异常，则会指定两个 gas 价格（例如，[`FITS`](#instr-fits): `26/76`）。
4. _元组创建_：每个元组元素 **1 gas 单位**。
5. _隐式跳转_：对于一个隐式跳转，**10 gas 单位**；对于隐式后跳，**5 gas 单位**。这项费用不属于任何指令的一部分。
6. _在continuations之间移动栈元素_：每个元素 **1 gas 单位**，但是移动前32个元素是免费的。

### 快速搜索

:::info

一份完整的机器可读的 TVM 指令列表可在[此处](https://github.com/ton-community/ton-docs/blob/main/docs/learn/tvm-instructions/instructions.csv)获取。
:::

随意使用下面的搜索字段来查找特定的指令：

<SearchField
  data={opcodes}
  searchBy="doc_fift"
  placeholder="搜索操作码"
  showKeys={[
    { key: 'doc_opcode', name: '操作码', isGrouped: true },
    { key: 'doc_fift', name: 'Fift 语法', isGrouped: true },
    { key: 'doc_stack', name: '堆栈', isGrouped: true },
    { key: 'doc_gas', name: 'Gas', isGrouped: true },
    { key: 'doc_description', name: '描述' },
  ]}
/>

## 2 堆栈操作原语

这里 `0 <= i,j,k <= 15` 除非另有说明。

### 2.1 基本堆栈操作原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`00`** | `NOP` | _`-`_ | 无操作。 | `18` |
| **`01`** | `SWAP` | _`x y - y x`_ | 等同于 [`s1 XCHG0`](#instr-xchg-0i)。 | `18` |
| **`0i`** | `s[i] XCHG0` |  | 交换 `s0` 与 `s[i]`，`1 <= i <= 15`。 | `18` |
| **`10ij`** | `s[i] s[j] XCHG` |  | 交换 `s[i]` 与 `s[j]`，`1 <= i < j <= 15`。 | `26` |
| **`11ii`** | `s0 [ii] s() XCHG` |  | 交换 `s0` 与 `s[ii]`，`0 <= ii <= 255`。 | `26` |
| **`1i`** | `s1 s[i] XCHG` |  | 交换 `s1` 与 `s[i]`，`2 <= i <= 15`。 | `18` |
| **`2i`** | `s[i] PUSH` |  | 将旧的 `s[i]` 的一个副本推入堆栈。 | `18` |
| **`20`** | `DUP` | _`x - x x`_ | 等同于 [`s0 PUSH`](#instr-push)。 | `18` |
| **`21`** | `OVER` | _`x y - x y x`_ | 等同于 [`s1 PUSH`](#instr-push)。 | `18` |
| **`3i`** | `s[i] POP` |  | 将旧的 `s0` 值弹出到旧的 `s[i]` 中。等同于 [`s[i] XCHG0`](#instr-xchg-0i) [`DROP`](#instr-drop) | `18` |
| **`30`** | `DROP` | _`x -`_ | 等同于 [`s0 POP`](#instr-pop)，丢弃堆栈顶部值。 | `18` |
| **`31`** | `NIP` | _`x y - y`_ | 等同于 [`s1 POP`](#instr-pop)。 | `18` |
### 2.2 复杂堆栈操作原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`4ijk`** | `s[i] s[j] s[k] XCHG3` |  | 等同于 [`s2 s[i] XCHG`](#instr-xchg-ij) [`s1 s[j] XCHG`](#instr-xchg-ij) [`s[k] XCHG0`](#instr-xchg-0i)。 | `26` |
| **`50ij`** | `s[i] s[j] XCHG2` |  | 等同于 [`s1 s[i] XCHG`](#instr-xchg-ij) [`s[j] XCHG0`](#instr-xchg-0i)。 | `26` |
| **`51ij`** | `s[i] s[j] XCPU` |  | 等同于 [`s[i] XCHG0`](#instr-xchg-0i) [`s[j] PUSH`](#instr-push)。 | `26` |
| **`52ij`** | `s[i] s[j-1] PUXC` |  | 等同于 [`s[i] PUSH`](#instr-push) [`SWAP`](#instr-swap) [`s[j] XCHG0`](#instr-xchg-0i)。 | `26` |
| **`53ij`** | `s[i] s[j] PUSH2` |  | 等同于 [`s[i] PUSH`](#instr-push) [`s[j+1] PUSH`](#instr-push)。 | `26` |
| **`540ijk`** | `s[i] s[j] s[k] XCHG3_l` |  | [`XCHG3`](#instr-xchg3) 的长格式。 | `34` |
| 541ijk | `s[i] s[j] s[k] XC2PU` |  | 等同于 [`s[i] s[j] XCHG2`](#instr-xchg2) [`s[k] PUSH`](#instr-push)。 | `34` |
| **`542ijk`** | `s[i] s[j] s[k-1] XCPUXC` |  | 等同于 [`s1 s[i] XCHG`](#instr-xchg-ij) [`s[j] s[k-1] PUXC`](#instr-puxc)。 | `34` |
| **`543ijk`** | `s[i] s[j] s[k] XCPU2` |  | 等同于 [`s[i] XCHG0`](#instr-xchg-0i) [`s[j] s[k] PUSH2`](#instr-push2)。 | `34` |
| **`544ijk`** | `s[i] s[j-1] s[k-1] PUXC2` |  | 等同于 [`s[i] PUSH`](#instr-push) [`s2 XCHG0`](#instr-xchg-0i) [`s[j] s[k] XCHG2`](#instr-xchg2)。 | `34` |
| **`545ijk`** | `s[i] s[j-1] s[k-1] PUXCPU` |  | 等同于 [`s[i] s[j-1] PUXC`](#instr-puxc) [`s[k] PUSH`](#instr-push)。 | `34` |
| **`546ijk`** | `s[i] s[j-1] s[k-2] PU2XC` |  | 等同于 [`s[i] PUSH`](#instr-push) [`SWAP`](#instr-swap) [`s[j] s[k-1] PUXC`](#instr-puxc)。 | `34` |
| **`547ijk`** | `s[i] s[j] s[k] PUSH3` |  | 等同于 [`s[i] PUSH`](#instr-push) [`s[j+1] s[k+1] PUSH2`](#instr-push2)。 | `34` |
| **`55ij`** | `[i+1] [j+1] BLKSWAP` |  | 交换两个块 `s[j+i+1] … s[j+1]` 和 `s[j] … s0`。<br/> `0 <= i,j <= 15`<br/>等同于 [`[i+1] [j+1] REVERSE`](#instr-reverse) [`[j+1] 0 REVERSE`](#instr-reverse) [`[i+j+2] 0 REVERSE`](#instr-reverse)。 | `26` |
| **`5513`** | `ROT2`<br/>`2ROT` | _`a b c d e f - c d e f a b`_ | 旋转三对堆栈最顶部的条目。 | `26` |
| **`550i`** | `[i+1] ROLL` |  | 旋转顶部 `i+1` 个堆栈条目。<br/>等同于 [`1 [i+1] BLKSWAP`](#instr-blkswap)。 | `26` |
| **`55i0`** | `[i+1] -ROLL`<br/>`[i+1] ROLLREV` |  | 以相反方向旋转顶部 `i+1` 个堆栈条目。<br/>等同于 [`[i+1] 1 BLKSWAP`](#instr-blkswap)。 | `26` |
| **`56ii`** | `[ii] s() PUSH` |  | 将旧的 `s[ii]` 的一个副本推入堆栈。<br/>`0 <= ii <= 255` | `26` |
| **`57ii`** | `[ii] s() POP` |  | 将旧的 `s0` 值弹出到旧的 `s[ii]` 中。<br/>`0 <= ii <= 255` | `26` |
| **`58`** | `ROT` | _`a b c - b c a`_ | 等同于 [`1 2 BLKSWAP`](#instr-blkswap) 或 [`s2 s1 XCHG2`](#instr-xchg2)。 | `18` |
| **`59`** | `ROTREV`<br/>`-ROT` | _`a b c - c a b`_ | 等同于 [`2 1 BLKSWAP`](#instr-blkswap) 或 [`s2 s2 XCHG2`](#instr-xchg2)。 | `18` |
| **`5A`** | `SWAP2`<br/>`2SWAP` | _`a b c d - c d a b`_ | 等同于 [`2 2 BLKSWAP`](#instr-blkswap) 或 [`s3 s2 XCHG2`](#instr-xchg2)。 | `18` |
| **`5B`** | `DROP2`<br/>`2DROP` | _`a b - `_ | 等同于两次执行 [`DROP`](#instr-drop)。 | `18` |
| **`5C`** | `DUP2`<br/>`2DUP` | _`a b - a b a b`_ | 等同于 [`s1 s0 PUSH2`](#instr-push2)。 | `18` |
| **`5D`** | `OVER2`<br/>`2OVER` | _`a b c d - a b c d a b`_ | 等同于 [`s3 s2 PUSH2`](#instr-push2)。 | `18` |
| **`5Eij`** | `[i+2] [j] REVERSE` |  | 反转 `s[j+i+1] … s[j]` 的顺序。 | `26` |
| **`5F0i`** | `[i] BLKDROP` |  | 执行 `i` 次 [`DROP`](#instr-drop)。 | `26` |
| **`5Fij`** | `[i] [j] BLKPUSH` |  | 执行 `i` 次 `PUSH s(j)`。<br/>`1 <= i <= 15`, `0 <= j <= 15`。 | `26` |
| **`60`** | `PICK`<br/>`PUSHX` |  | 从堆栈弹出整数 `i`，然后执行 [`s[i] PUSH`](#instr-push)。 | `18` |
| **`61`** | `ROLLX` |  | 从堆栈弹出整数 `i`，然后执行 [`1 [i] BLKSWAP`](#instr-blkswap)。 | `18` |
| **`62`** | `-ROLLX`<br/>`ROLLREVX` |  | 从堆栈弹出整数 `i`，然后执行 [`[i] 1 BLKSWAP`](#instr-blkswap)。 | `18` |
| **`63`** | `BLKSWX` |  | 从堆栈弹出整数 `i`、`j`，然后执行 [`[i] [j] BLKSWAP`](#instr-blkswap)。 | `18` |
| **`64`** | `REVX` |  | 从堆栈弹出整数 `i`、`j`，然后执行 [`[i] [j] REVERSE`](#instr-reverse)。 | `18` |
| **`65`** | `DROPX` |  | 从堆栈弹出整数 `i`，然后执行 [`[i] BLKDROP`](#instr-blkdrop)。 | `18` |
| **`66`** | `TUCK` | _`a b - b a b`_ | 等同于 [`SWAP`](#instr-swap) [`OVER`](#instr-over) 或 [`s1 s1 XCPU`](#instr-xcpu)。 | `18` |
| **`67`** | `XCHGX` |  | 从堆栈弹出整数 `i`，然后执行 [`s[i] XCHG`](#instr-xchg-ij)。 | `18` |
| **`68`** | `DEPTH` | _`- depth`_ | 推入当前堆栈深度。 | `18` |
| **`69`** | `CHKDEPTH` | _`i -`_ | 从堆栈弹出整数 `i`，然后检查是否至少有 `i` 个元素，否则生成堆栈下溢异常。 | `18/58` |
| **`6A`** | `ONLYTOPX` |  | 从堆栈弹出整数 `i`，然后移除除顶部 `i` 个元素之外的所有元素。 | `18` |
| **`6B`** | `ONLYX` |  | 从堆栈弹出整数 `i`，然后仅保留底部 `i` 个元素。大致等同于 [`DEPTH`](#instr-depth) [`SWAP`](#instr-swap) [`SUB`](#instr-sub) [`DROPX`](#instr-dropx)。 | `18` |
| **`6Cij`** | `[i] [j] BLKDROP2` |  | 在顶部 `j` 个元素下方丢弃 `i` 个堆栈元素。<br/>`1 <= i <= 15`, `0 <= j <= 15`<br/>等同于 [`[i+j] 0 REVERSE`](#instr-reverse) [`[i] BLKDROP`](#instr-blkdrop) [`[j] 0 REVERSE`](#instr-reverse)。 | `26` |

## 3 元组、列表和 Null 原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`6D`** | `NULL`<br/>`PUSHNULL` | _` - null`_ | 推入类型为 _Null_ 的唯一值。 | `18` |
| **`6E`** | `ISNULL` | _`x - ?`_ | 检查 `x` 是否为 _Null_，根据情况分别返回 `-1` 或 `0`。 | `18` |
| **`6F0n`** | `[n] TUPLE` | _`x_1 ... x_n - t`_ | 创建包含 `n` 值 `x_1`,..., `x_n` 的新 _Tuple_ `t=(x_1, … ,x_n)`。<br/>`0 <= n <= 15` | `26+n` |
| **`6F00`** | `NIL` | _`- t`_ | 推入长度为零的唯一 _Tuple_ `t=()`。 | `26` |
| **`6F01`** | `SINGLE` | _`x - t`_ | 创建单例 `t:=(x)`，即长度为一的 _Tuple_。 | `27` |
| **`6F02`** | `PAIR`<br/>`CONS` | _`x y - t`_ | 创建对 `t:=(x,y)`。 | `28` |
| **`6F03`** | `TRIPLE` | _`x y z - t`_ | 创建三元组 `t:=(x,y,z)`。 | `29` |
| **`6F1k`** | `[k] INDEX` | _`t - x`_ | 返回 _Tuple_ `t` 的第 `k` 个元素。<br/>`0 <= k <= 15`。 | `26` |
| **`6F10`** | `FIRST`<br/>`CAR` | _`t - x`_ | 返回 _Tuple_ 的第一个元素。 | `26` |
| **`6F11`** | `SECOND`<br/>`CDR` | _`t - y`_ | 返回 _Tuple_ 的第二个元素。 | `26` |
| **`6F12`** | `THIRD` | _`t - z`_ | 返回 _Tuple_ 的第三个元素。 | `26` |
| **`6F2n`** | `[n] UNTUPLE` | _`t - x_1 ... x_n`_ | 解包长度等于 `0 <= n <= 15` 的 _Tuple_ `t=(x_1,...,x_n)`。<br/>如果 `t` 不是 _Tuple_ 或 `\|t\| != n`，则抛出类型检查异常。 | `26+n` |
| **`6F21`** | `UNSINGLE` | _`t - x`_ | 解包单例 `t=(x)`。 | `27` |
| **`6F22`** | `UNPAIR`<br/>`UNCONS` | _`t - x y`_ | 解包对 `t=(x,y)`。 | `28` |
| **`6F23`** | `UNTRIPLE` | _`t - x y z`_ | 解包三元组 `t=(x,y,z)`。 | `29` |
| **`6F3k`** | `[k] UNPACKFIRST` | _`t - x_1 ... x_k`_ | 解包 _Tuple_ `t` 的前 `0 <= k <= 15` 个元素。<br/>如果 `\|t\|<k`，抛出类型检查异常。 | `26+k` |
| **`6F30`** | `CHKTUPLE` | _`t -`_ | 检查 `t` 是否为 _Tuple_。如果不是，则抛出类型检查异常。 | `26` |
| **`6F4n`** | `[n] EXPLODE` | _`t - x_1 ... x_m m`_ | 解包 _Tuple_ `t=(x_1,...,x_m)` 并返回其长度 `m`，但仅当 `m <= n <= 15`。否则抛出类型检查异常。 | `26+m` |
| **`6F5k`** | `[k] SETINDEX` | _`t x - t'`_ | 计算 _Tuple_ `t'`，它与 `t` 仅在位置 `t'_{k+1}` 上不同，该位置被设置为 `x`。<br/>`0 <= k <= 15`<br/>如果 `k >= \|t\|`，则抛出范围检查异常。 | `26+\|t\|` |
| **`6F50`** | `SETFIRST` | _`t x - t'`_ | 将 _Tuple_ `t` 的第一个组件设置为 `x` 并返回结果 _Tuple_ `t'`。 | `26+\|t\|` |
| **`6F51`** | `SETSECOND` | _`t x - t'`_ | 将 _Tuple_ `t` 的第二个组件设置为 `x` 并返回结果 _Tuple_ `t'`。 | `26+\|t\|` |
| **`6F52`** | `SETTHIRD` | _`t x - t'`_ | 将 _Tuple_ `t` 的第三个组件设置为 `x` 并返回结果 _Tuple_ `t'`。 | `26+\|t\|` |
| **`6F6k`** | `[k] INDEXQ` | _`t - x`_ | 返回 _Tuple_ `t` 的第 `k` 个元素，其中 `0 <= k <= 15`。换句话说，如果 `t=(x_1,...,x_n)`，则返回 `x_{k+1}`。如果 `k>=n` 或 `t` 为 _Null_，则返回 _Null_ 而不是 `x`。 | `26` |
| **`6F60`** | `FIRSTQ`<br/>`CARQ` | _`t - x`_ | 返回 _Tuple_ 的第一个元素。 | `26` |
| **`6F61`** | `SECONDQ`<br/>`CDRQ` | _`t - y`_ | 返回 _Tuple_ 的第二个元素。 | `26` |
| **`6F62`** | `THIRDQ` | _`t - z`_ | 返回 _Tuple_ 的第三个元素。 | `26` |
| **`6F7k`** | `[k] SETINDEXQ` | _`t x - t'`_ | 在 _Tuple_ `t` 中设置第 `k` 个组件为 `x`，其中 `0 <= k < 16`，并返回结果 _Tuple_ `t'`。<br/>如果 `\|t\| <= k`，首先通过将所有新组件设置为 _Null_ 来将原始 _Tuple_ 扩展到长度 `n’=k+1`。如果原始值 `t` 为 _Null_，则将其视为空 _Tuple_。如果 `t` 既不是 _Null_ 也不是 _Tuple_，抛出异常。如果 `x` 为 _Null_ 且 `\|t\| <= k` 或 `t` 为 _Null_，则总是返回 `t'=t`（并且不消耗元组创建 gas）。 | `26+\|t’\|` |
| **`6F70`** | `SETFIRSTQ` | _`t x - t'`_ | 将 _Tuple_ `t` 的第一个组件设置为 `x` 并返回结果 _元组_ `t'`。 | `26+\|t’\|` |
| **`6F71`** | `SETSECONDQ` | _`t x - t'`_ | 将 _Tuple_ `t` 的第二个组件设置为 `x` 并返回结果 _元组_ `t'`。 | `26+\|t’\|` |
| **`6F72`** | `SETTHIRDQ` | _`t x - t'`_ | 将 _Tuple组_ `t` 的第三个组件设置为 `x` 并返回结果 _元组_ `t'`。 | `26+\|t’\|` |
| **`6F80`** | `TUPLEVAR` | _`x_1 ... x_n n - t`_ | 以类似于 [`TUPLE`](#instr-tuple) 的方式创建长度为 `n` 的新 _Tuple_ `t`，但 `0 <= n <= 255` 从堆栈获取。 | `26+n` |
| **`6F81`** | `INDEXVAR` | _`t k - x`_ | 类似于 [`k INDEX`](#instr-index)，但 `0 <= k <= 254` 从堆栈获取。 | `26` |
| **`6F82`** | `UNTUPLEVAR` | _`t n - x_1 ... x_n`_ | 类似于 [`n UNTUPLE`](#instr-untuple)，但 `0 <= n <= 255` 从堆栈获取。 | `26+n` |
| **`6F83`** | `UNPACKFIRSTVAR` | _`t n - x_1 ... x_n`_ | 类似于 [`n UNPACKFIRST`](#instr-unpackfirst)，但 `0 <= n <= 255` 从堆栈获取。 | `26+n` |
| **`6F84`** | `EXPLODEVAR` | _`t n - x_1 ... x_m m`_ | 类似于 [`n EXPLODE`](#instr-explode)，但 `0 <= n <= 255` 从堆栈获取。 | `26+m` |
| **`6F85`** | `SETINDEXVAR` | _`t x k - t'`_ | 类似于 [`k SETINDEX`](#instr-setindex)，但 `0 <= k <= 254` 从堆栈获取。 | `26+\|t’\|` |
| **`6F86`** | `INDEXVARQ` | _`t k - x`_ | 类似于 [`n INDEXQ`](#instr-indexq)，但 `0 <= k <= 254` 从堆栈获取。 | `26` |
| **`6F87`** | `SETINDEXVARQ` | _`t x k - t'`_ | 类似于 [`k SETINDEXQ`](#instr-setindexq)，但 `0 <= k <= 254` 从堆栈获取。 | `26+\|t’\|` |
| **`6F88`** | `TLEN` | _`t - n`_ | 返回 _Tuple_ 的长度。 | `26` |
| **`6F89`** | `QTLEN` | _`t - n or -1`_ | 类似于 [`TLEN`](#instr-tlen)，但如果 `t` 不是 _Tuple_，则返回 `-1`。 | `26` |
| **`6F8A`** | `ISTUPLE` | _`t - ?`_ | 根据 `t` 是否为 _Tuple_，分别返回 `-1` 或 `0`。 | `26` |
| **`6F8B`** | `LAST` | _`t - x`_ | 返回非空 _Tuple_ `t` 的最后一个元素。 | `26` |
| **`6F8C`** | `TPUSH`<br/>`COMMA` | _`t x - t'`_ | 将值 `x` 附加到 _Tuple_ `t=(x_1,...,x_n)`，但仅当结果 _Tuple_ `t'=(x_1,...,x_n,x)` 的长度最多为 255 时。否则抛出类型检查异常。 | `26+\|t’\|` |
| **`6F8D`** | `TPOP` | _`t - t' x`_ | 从非空 _Tuple_ `t=(x_1,...,x_n)` 分离最后一个元素 `x=x_n`，并返回结果 _Tuple_ `t'=(x_1,...,x_{n-1})` 和原始的最后一个元素 `x`。 | `26+\|t’\|` |
| **`6FA0`** | `NULLSWAPIF` | _`x - x or null x`_ | 在顶部的 _Integer_ `x` 下推入一个 _Null_，但仅当 `x!=0` 时。 | `26` |
| **`6FA1`** | `NULLSWAPIFNOT` | _`x - x or null x`_ | 在顶部的 _Integer_ `x` 下推入一个 _Null_，但仅当 `x=0` 时。可用于在类似于 [`PLDUXQ`](#instr-plduxq) 这样的静默原语后进行堆栈对齐。 | `26` |
| **`6FA2`** | `NULLROTRIF` | _`x y - x y or null x y`_ | 在顶部第二个堆栈条目下推入一个 _Null_，但仅当顶部的 _Integer_ `y` 非零时。 | `26` |
| **`6FA3`** | `NULLROTRIFNOT` | _`x y - x y or null x y`_ | 在顶部第二个堆栈条目下推入一个 _Null_，但仅当顶部的 _Integer_ `y` 为零时。可用于在类似于 [`LDUXQ`](#instr-lduxq) 这样的静默原语后进行堆栈对齐。 | `26` |
| **`6FA4`** | `NULLSWAPIF2` | _`x - x or null null x`_ | 在顶部的 _Integer_ `x` 下推入两个 _Null_，但仅当 `x!=0` 时。<br/>等同于 [`NULLSWAPIF`](#instr-nullswapif) [`NULLSWAPIF`](#instr-nullswapif)。 | `26` |
| **`6FA5`** | `NULLSWAPIFNOT2` | _`x - x or null null x`_ | 在顶部的 _Integer_ `x` 下推入两个 _Null_，但仅当 `x=0` 时。<br/>等同于 [`NULLSWAPIFNOT`](#instr-nullswapifnot) [`NULLSWAPIFNOT`](#instr-nullswapifnot)。 | `26` |
| **`6FA6`** | `NULLROTRIF2` | _`x y - x y or null null x y`_ | 在顶部第二个堆栈条目下推入两个 _Null_，但仅当顶部的 _Integer_ `y` 非零时。<br/>等同于 [`NULLROTRIF`](#instr-nullrotrif) [`NULLROTRIF`](#instr-nullrotrif)。 | `26` |
| **`6FA7`** | `NULLROTRIFNOT2` | _`x y - x y 或 null null x y`_ | 仅当最顶部的 _Integer_ `y` 为零时，才在顶部第二个堆栈条目下推入两个 _Null_。<br/>等同于两次 [`NULLROTRIFNOT`](#instr-nullrotrifnot)。 | `26` |
| **`6FBij`** | `[i] [j] INDEX2` | _`t - x`_ | 对于 `0 <= i,j <= 3`，恢复 `x=(t_{i+1})_{j+1}`。<br/>等同于 [`[i] INDEX`](#instr-index) [`[j] INDEX`](#instr-index)。 | `26` |
| **`6FB4`** | `CADR` | _`t - x`_ | 恢复 `x=(t_2)_1`。 | `26` |
| **`6FB5`** | `CDDR` | _`t - x`_ | 恢复 `x=(t_2)_2`。 | `26` |
| **`6FE_ijk`** | `[i] [j] [k] INDEX3` | _`t - x`_ | 恢复 `x=t_{i+1}_{j+1}_{k+1}`。<br/>`0 <= i,j,k <= 3`<br/>等同于 [`[i] [j] INDEX2`](#instr-index2) [`[k] INDEX`](#instr-index)。 | `26` |
| **`6FD4`** | `CADDR` | _`t - x`_ | 恢复 `x=t_2_2_1`。 | `26` |
| **`6FD5`** | `CDDDR` | _`t - x`_ | 恢复 `x=t_2_2_2`。 | `26` |

## 4 常量或字面量原语
### 4.1 整数和布尔常量
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`7i`** | `[x] PUSHINT`<br/>`[x] INT` | _`- x`_ | 将整数 `x` 压入栈。`-5 <= x <= 10`。<br/>这里的 `i` 等于 `x` 的四个低阶位 (`i=x mod 16`)。 | `18` |
| **`70`** | `ZERO`<br/>`FALSE` | _`- 0`_ |  | `18` |
| **`71`** | `ONE` | _`- 1`_ |  | `18` |
| **`72`** | `TWO` | _`- 2`_ |  | `18` |
| **`7A`** | `TEN` | _`- 10`_ |  | `18` |
| **`7F`** | `TRUE` | _`- -1`_ |  | `18` |
| **`80xx`** | `[xx] PUSHINT`<br/>`[xx] INT` | _`- xx`_ | 将整数 `xx` 压入栈。`-128 <= xx <= 127`。 | `26` |
| **`81xxxx`** | `[xxxx] PUSHINT`<br/>`[xxxx] INT` | _`- xxxx`_ | 将整数 `xxxx` 压入栈。`-2^15 <= xx < 2^15`。 | `34` |
| **`82lxxx`** | `[xxx] PUSHINT`<br/>`[xxx] INT` | _`- xxx`_ | 将整数 `xxx` 压入栈。<br/>_细节:_ 5位的 `0 <= l <= 30` 决定了有符号大端整数 `xxx` 的长度 `n=8l+19`。<br/>此指令的总长度为 `l+4` 字节或 `n+13=8l+32` 位。 | `23` |
| **`83xx`** | `[xx+1] PUSHPOW2` | _`- 2^(xx+1)`_ | （静默地）推送 `2^(xx+1)`，对于 `0 <= xx <= 255`。<br/>`2^256` 是一个 `NaN`。 | `26` |
| **`83FF`** | `PUSHNAN` | _`- NaN`_ | 推送一个 `NaN`。 | `26` |
| **`84xx`** | `[xx+1] PUSHPOW2DEC` | _`- 2^(xx+1)-1`_ | 推送 `2^(xx+1)-1`，对于 `0 <= xx <= 255`。 | `26` |
| **`85xx`** | `[xx+1] PUSHNEGPOW2` | _`- -2^(xx+1)`_ | 推送 `-2^(xx+1)`，对于 `0 <= xx <= 255`。 | `26` |
### 4.2 常量切片、continuation、cell和引用
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`88`** | `[ref] PUSHREF` | _`- c`_ | 将引用 `ref` 推送到栈中。<br/>_细节:_ 将 `cc.code` 的第一个引用作为 _cell_ 推入栈（并从当前continuation中移除此引用）。 | `18` |
| **`89`** | `[ref] PUSHREFSLICE` | _`- s`_ | 类似于 [`PUSHREF`](#instr-pushref)，但将cell转换为 _切片_。 | `118/43` |
| **`8A`** | `[ref] PUSHREFCONT` | _`- cont`_ | 类似于 [`PUSHREFSLICE`](#instr-pushrefslice)，但将cell制作成一个简单的普通 _continuation_。 | `118/43` |
| **`8Bxsss`** | `[slice] PUSHSLICE`<br/>`[slice] SLICE` | _`- s`_ | 将切片 `slice` 推入栈。<br/>_细节:_ 推送 `cc.code` 的 (前缀) 子切片，其由其前 `8x+4` 位和零个引用组成（即，基本上是一个位串），其中 `0 <= x <= 15`。<br/>假设有一个完成标记，意味着所有尾随零和最后一个二进制一（如果存在）都从这个位串中被移除。<br/>如果原始位串仅由零组成，则会推入一个空切片。 | `22` |
| **`8Crxxssss`** | `[slice] PUSHSLICE`<br/>`[slice] SLICE` | _`- s`_ | 将切片 `slice` 推入栈。<br/>_细节:_ 推送 `cc.code` 的 (前缀) 子切片，其由其前 `1 <= r+1 <= 4` 个引用和最多前 `8xx+1` 位数据组成，其中 `0 <= xx <= 31`。<br/>也假设有一个完成标记。 | `25` |
| **`8Drxxsssss`** | `[slice] PUSHSLICE`<br/>`[slice] SLICE` | _`- s`_ | 将切片 `slice` 推入栈。<br/>_细节:_ 推送 `cc.code` 的子切片，其由 `0 <= r <= 4` 个引用和最多 `8xx+6` 位数据组成，其中 `0 <= xx <= 127`。<br/>假设有一个完成标记。 | `28` |
|  | `x{} PUSHSLICE`<br/>`x{ABCD1234} PUSHSLICE`<br/>`b{01101} PUSHSLICE` | _`- s`_ | [`PUSHSLICE`](#instr-pushslice) 的示例。<br/>`x{}` 是一个空切片。`x{...}` 是一个十六进制字面量。`b{...}` 是一个二进制字面量。<br/>关于切片字面量的更多信息[在这里](https://github.com/Piterden/TON-docs/blob/master/Fift.%20A%20Brief%20Introduction.md#user-content-51-slice-literals)。<br/>注意，汇编程序可以在某些情况下（例如，如果当前continuation中没有足够的空间）将 [`PUSHSLICE`](#instr-pushslice) 替换为 [`PUSHREFSLICE`](#instr-pushrefslice)。 |  |
|  | `<b x{AB12} s, b> PUSHREF`<br/>`<b x{AB12} s, b> PUSHREFSLICE` | _`- c/s`_ | [`PUSHREF`](#instr-pushref) 和 [`PUSHREFSLICE`](#instr-pushrefslice) 的示例。<br/>关于在 fift 中构建cell的更多信息[在这里](https://github.com/Piterden/TON-docs/blob/master/Fift.%20A%20Brief%20Introduction.md#user-content-52-builder-primitives)。 |  |
| **`8F_rxxcccc`** | `[builder] PUSHCONT`<br/>`[builder] CONT` | _`- c`_ | 从 `builder` 中推送continuation。<br/>_细节:_ 推送由 `cc.code` 的前 `0 <= r <= 3` 个引用和前 `0 <= xx <= 127` 字节制成的简单普通continuation `cccc`。 | `26` |
| **`9xccc`** | `[builder] PUSHCONT`<br/>`[builder] CONT` | _`- c`_ | 从 `builder` 中推送continuation。<br/>_细节:_ 推送一个 `x` 字节的continuation，对于 `0 <= x <= 15`。 | `18` |
|  | `<{ code }> PUSHCONT`<br/>`<{ code }> CONT`<br/>`CONT:<{ code }>` | _`- c`_ | 用代码 `code` 推送continuation。<br/>注意，汇编程序可以在某些情况下（例如，如果当前continuation中没有足够的空间）将 [`PUSHCONT`](#instr-pushcont) 替换为 [`PUSHREFCONT`](#instr-pushrefcont)。 |  |

## 5 算术原语
### 5.1 加法、减法、乘法
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`A0`** | `ADD` | _`x y - x+y`_ |  | `18` |
| **`A1`** | `SUB` | _`x y - x-y`_ |  | `18` |
| **`A2`** | `SUBR` | _`x y - y-x`_ | 等同于 [`SWAP`](#instr-swap) [`SUB`](#instr-sub)。 | `18` |
| **`A3`** | `NEGATE` | _`x - -x`_ | 等同于 [`-1 MULCONST`](#instr-mulconst) 或 [`ZERO SUBR`](#instr-subr)。<br/>注意，如果 `x=-2^256` 时会触发整数溢出异常。 | `18` |
| **`A4`** | `INC` | _`x - x+1`_ | 等同于 [`1 ADDCONST`](#instr-addconst)。 | `18` |
| **`A5`** | `DEC` | _`x - x-1`_ | 等同于 [`-1 ADDCONST`](#instr-addconst)。 | `18` |
| **`A6cc`** | `[cc] ADDCONST`<br/>`[cc] ADDINT`<br/>`[-cc] SUBCONST`<br/>`[-cc] SUBINT` | _`x - x+cc`_ | `-128 <= cc <= 127`。 | `26` |
| **`A7cc`** | `[cc] MULCONST`<br/>`[cc] MULINT` | _`x - x*cc`_ | `-128 <= cc <= 127`。 | `26` |
| **`A8`** | `MUL` | _`x y - x*y`_ |  | `18` |
### 5.2 除法
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`A9mscdf`** |  |  | 这是除法的通用编码，可选进行预乘和用移位替换除法或乘法。变量字段如下：<br/>`0 <= m <= 1`  -  表示是否有预乘（[`MULDIV`](#instr-muldiv) 及其变体），可能被左移替换。<br/>`0 <= s <= 2`  -  表示乘法或除法中的哪一个被移位替换：`s=0` - 无替换，`s=1` - 除法被右移替换，`s=2` - 乘法被左移替换（仅当 `m=1` 时可能）。<br/>`0 <= c <= 1`  -  表示是否有移位操作符的一个字节常量参数 `tt`（如果 `s!=0`）。对于 `s=0`，`c=0`。如果 `c=1`，则 `0 <= tt <= 255`，并且移位由 `tt+1` 位执行。如果 `s!=0` 且 `c=0`，则移位量作为栈顶的 _整数_在 `0...256` 范围内提供。<br/>`1 <= d <= 3`  -  表示需要哪些除法结果：`1` - 仅商，`2` - 仅余数，`3` - 商和余数。<br/>`0 <= f <= 2`  -  舍入模式：`0` - 向下取整，`1` - 最近整数，`2` - 向上取整。<br/>下列所有指令均为此变体。 | `26` |
| **`A904`** | `DIV` | _`x y - q`_ | `q=floor(x/y)`，`r=x-y*q` | `26` |
| **`A905`** | `DIVR` | _`x y - q’`_ | `q’=round(x/y)`，`r’=x-y*q’` | `26` |
| **`A906`** | `DIVC` | _`x y - q''`_ | `q’’=ceil(x/y)`，`r’’=x-y*q’’` | `26` |
| **`A908`** | `MOD` | _`x y - r`_ |  | `26` |
| **`A90C`** | `DIVMOD` | _`x y - q r`_ |  | `26` |
| **`A90D`** | `DIVMODR` | _`x y - q' r'`_ |  | `26` |
| **`A90E`** | `DIVMODC` | _`x y - q'' r''`_ |  | `26` |
| **`A925`** | `RSHIFTR` | _`x y - round(x/2^y)`_ |  | `26` |
| **`A926`** | `RSHIFTC` | _`x y - ceil(x/2^y)`_ |  | `34` |
| **`A935tt`** | `[tt+1] RSHIFTR#` | _`x y - round(x/2^(tt+1))`_ |  | `34` |
| **`A936tt`** | `[tt+1] RSHIFTC#` | _`x y - ceil(x/2^(tt+1))`_ |  | `34` |
| **`A938tt`** | `[tt+1] MODPOW2#` | _`x - x mod 2^(tt+1)`_ |  | `34` |
| **`A98`** | `MULDIV` | _`x y z - q`_ | `q=floor(x*y/z)` | `26` |
| **`A985`** | `MULDIVR` | _`x y z - q'`_ | `q'=round(x*y/z)` | `26` |
| **`A98C`** | `MULDIVMOD` | _`x y z - q r`_ | `q=floor(x*y/z)`，`r=x*y-z*q` | `26` |
| **`A9A4`** | `MULRSHIFT` | _`x y z - floor(x*y/2^z)`_ | `0 <= z <= 256` | `26` |
| **`A9A5`** | `MULRSHIFTR` | _`x y z - round(x*y/2^z)`_ | `0 <= z <= 256` | `26` |
| **`A9A6`** | `MULRSHIFTC` | _`x y z - ceil(x*y/2^z)`_ | `0 <= z <= 256` | `34` |
| **`A9B4tt`** | `[tt+1] MULRSHIFT#` | _`x y - floor(x*y/2^(tt+1))`_ |  | `34` |
| **`A9B5tt`** | `[tt+1] MULRSHIFTR#` | _`x y - round(x*y/2^(tt+1))`_ |  | `34` |
| **`A9B6tt`** | `[tt+1] MULRSHIFTC#` | _`x y - ceil(x*y/2^(tt+1))`_ |  | `26` |
| **`A9C4`** | `LSHIFTDIV` | _`x y z - floor(2^z*x/y)`_ | `0 <= z <= 256` | `26` |
| **`A9C5`** | `LSHIFTDIVR` | _`x y z - round(2^z*x/y)`_ | `0 <= z <= 256` | `26` |
| **`A9C6`** | `LSHIFTDIVC` | _`x y z - ceil(2^z*x/y)`_ | `0 <= z <= 256` | `34` |
| **`A9D4tt`** | `[tt+1] LSHIFT#DIV` | _`x y - floor(2^(tt+1)*x/y)`_ |  | `34` |
| **`A9D5tt`** | `[tt+1] LSHIFT#DIVR` | _`x y - round(2^(tt+1)*x/y)`_ |  | `34` |
| **`A9D6tt`** | `[tt+1] LSHIFT#DIVC` | _`x y - ceil(2^(tt+1)*x/y)`_ |  | `26` |
### 5.3 移位、逻辑操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`AAcc`** | `[cc+1] LSHIFT#` | _`x - x*2^(cc+1)`_ | `0 <= cc <= 255` | `26` |
| **`ABcc`** | `[cc+1] RSHIFT#` | _`x - floor(x/2^(cc+1))`_ | `0 <= cc <= 255` | `18` |
| **`AC`** | `LSHIFT` | _`x y - x*2^y`_ | `0 <= y <= 1023` | `18` |
| **`AD`** | `RSHIFT` | _`x y - floor(x/2^y)`_ | `0 <= y <= 1023` | `18` |
| **`AE`** | `POW2` | _`y - 2^y`_ | `0 <= y <= 1023`<br/>等同于 [`ONE`](#instr-one) [`SWAP`](#instr-swap) [`LSHIFT`](#instr-lshift-var)。 | `18` |
| **`B0`** | `AND` | _`x y - x&y`_ | 对两个有符号整数 `x` 和 `y` 进行按位与运算，符号扩展到无限。 | `18` |
| **`B1`** | `OR` | _`x y - x\|y`_ | 对两个整数进行按位或运算。 | `18` |
| **`B2`** | `XOR` | _`x y - x xor y`_ | 对两个整数进行按位异或运算。 | `18` |
| **`B3`** | `NOT` | _`x - ~x`_ | 一个整数的按位非运算。 | `26` |
| **`B4cc`** | `[cc+1] FITS` | _`x - x`_ | 检查 `x` 是否为 `cc+1` 位有符号整数，对于 `0 <= cc <= 255`（即 `-2^cc <= x < 2^cc`）。<br/>如果不是，要么触发整数溢出异常，要么用 `NaN` 替换 `x`（静默版本）。 | `26/76` |
| **`B400`** | `CHKBOOL` | _`x - x`_ | 检查 `x` 是否为“布尔值”（即 0 或 -1）。 | `26/76` |
| **`B5cc`** | `[cc+1] UFITS` | _`x - x`_ | 检查 `x` 是否为 `cc+1` 位无符号整数，对于 `0 <= cc <= 255`（即 `0 <= x < 2^(cc+1)`）。 | `26/76` |
| **`B500`** | `CHKBIT` | _`x - x`_ | 检查 `x` 是否为二进制数字（即零或一）。 | `26/76` |
| **`B600`** | `FITSX` | _`x c - x`_ | 检查 `x` 是否为 `c` 位有符号整数，对于 `0 <= c <= 1023`。 | `26/76` |
| **`B601`** | `UFITSX` | _`x c - x`_ | 检查 `x` 是否为 `c` 位无符号整数，对于 `0 <= c <= 1023`。 | `26/76` |
| **`B602`** | `BITSIZE` | _`x - c`_ | 计算最小的 `c >= 0` 使得 `x` 适合于 `c` 位有符号整数（`-2^(c-1) <= c < 2^(c-1)`）。 | `26` |
| **`B603`** | `UBITSIZE` | _`x - c`_ | 计算最小的 `c >= 0` 使得 `x` 适合于 `c` 位无符号整数（`0 <= x < 2^c`），或抛出范围检查异常。 | `26` |
| **`B608`** | `MIN` | _`x y - x or y`_ | 计算两个整数 `x` 和 `y` 的最小值。 | `26` |
| **`B609`** | `MAX` | _`x y - x or y`_ | 计算两个整数 `x` 和 `y` 的最大值。 | `26` |
| **`B60A`** | `MINMAX`<br/>`INTSORT2` | _`x y - x y or y x`_ | 排序两个整数。如果任一参数为 `NaN`s，静默版本的此操作返回两个 `NaN`s。 | `26` |
| **`B60B`** | `ABS` | _`x - \|x\|`_ | 计算整数 `x` 的绝对值。 | `26` |
### 5.4 静默算术原语
静默操作在其参数之一为 `NaN` 或在整数溢出的情况下返回 `NaN`，而不是抛出异常。
静默操作如下所示带有 `Q` 前缀。另一种使操作变为静默的方法是在其前添加 `QUIET`（即可以写 [`QUIET ADD`](#instr-add) 而不是 [`QADD`](#instr-qadd)）。
整数比较原语的静默版本也可用（[`QUIET SGN`](#instr-sgn)，[`QUIET LESS`](#instr-less) 等）。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`B7A0`** | `QADD` | _`x y - x+y`_ |  | `26` |
| **`B7A1`** | `QSUB` | _`x y - x-y`_ |  | `26` |
| **`B7A2`** | `QSUBR` | _`x y - y-x`_ |  | `26` |
| **`B7A3`** | `QNEGATE` | _`x - -x`_ |  | `26` |
| **`B7A4`** | `QINC` | _`x - x+1`_ |  | `26` |
| **`B7A5`** | `QDEC` | _`x - x-1`_ |  | `26` |
| **`B7A8`** | `QMUL` | _`x y - x*y`_ |  | `26` |
| **`B7A904`** | `QDIV` | _`x y - q`_ | 如果 `y=0` 则除法返回 `NaN`。 | `34` |
| **`B7A905`** | `QDIVR` | _`x y - q’`_ |  | `34` |
| **`B7A906`** | `QDIVC` | _`x y - q''`_ |  | `34` |
| **`B7A908`** | `QMOD` | _`x y - r`_ |  | `34` |
| **`B7A90C`** | `QDIVMOD` | _`x y - q r`_ |  | `34` |
| **`B7A90D`** | `QDIVMODR` | _`x y - q' r'`_ |  | `34` |
| **`B7A90E`** | `QDIVMODC` | _`x y - q'' r''`_ |  | `34` |
| **`B7A985`** | `QMULDIVR` | _`x y z - q'`_ |  | `34` |
| **`B7A98C`** | `QMULDIVMOD` | _`x y z - q r`_ |  | `34` |
| **`B7AC`** | `QLSHIFT` | _`x y - x*2^y`_ |  | `26` |
| **`B7AD`** | `QRSHIFT` | _`x y - floor(x/2^y)`_ |  | `26` |
| **`B7AE`** | `QPOW2` | _`y - 2^y`_ |  | `26` |
| **`B7B0`** | `QAND` | _`x y - x&y`_ |  | `26` |
| **`B7B1`** | `QOR` | _`x y - x\|y`_ |  | `26` |
| **`B7B2`** | `QXOR` | _`x y - x xor y`_ |  | `26` |
| **`B7B3`** | `QNOT` | _`x - ~x`_ |  | `26` |
| **`B7B4cc`** | `[cc+1] QFITS` | _`x - x`_ | 如果 `x` 不是 `cc+1` 位有符号整数，则用 `NaN` 替换 `x`，否则保持不变。 | `34` |
| **`B7B5cc`** | `[cc+1] QUFITS` | _`x - x`_ | 如果 `x` 不是 `cc+1` 位无符号整数，则用 `NaN` 替换 `x`，否则保持不变。 | `34` |
| **`B7B600`** | `QFITSX` | _`x c - x`_ | 如果 `x` 不是 `c` 位有符号整数，则用 `NaN` 替换 `x`，否则保持不变。 | `34` |
| **`B7B601`** | `QUFITSX` | _`x c - x`_ | 如果 `x` 不是 `c` 位无符号整数，则用 `NaN` 替换 `x`，否则保持不变。 | `34` |

## 6 比较原语
### 6.1 整数比较
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`B8`** | `SGN` | _`x - sgn(x)`_ | 计算整数 `x` 的符号：<br/>`x<0` 时为 `-1`，`x=0` 时为 `0`，`x>0` 时为 `1`。 | `18` |
| **`B9`** | `LESS` | _`x y - x<y`_ | 如 `x<y`，返回 `-1`，否则返回 `0`。 | `18` |
| **`BA`** | `EQUAL` | _`x y - x=y`_ | 如 `x=y`，返回 `-1`，否则返回 `0`。 | `18` |
| **`BB`** | `LEQ` | _`x y - x<=y`_ |  | `18` |
| **`BC`** | `GREATER` | _`x y - x>y`_ |  | `18` |
| **`BD`** | `NEQ` | _`x y - x!=y`_ | 等同于 [`EQUAL`](#instr-equal) [`NOT`](#instr-not)。 | `18` |
| **`BE`** | `GEQ` | _`x y - x>=y`_ | 等同于 [`LESS`](#instr-less) [`NOT`](#instr-not)。 | `18` |
| **`BF`** | `CMP` | _`x y - sgn(x-y)`_ | 计算 `x-y` 的符号：<br/>`x<y` 时为 `-1`，`x=y` 时为 `0`，`x>y` 时为 `1`。<br/>除非 `x` 或 `y` 为 `NaN`，否则不会发生整数溢出。 | `18` |
| **`C0yy`** | `[yy] EQINT` | _`x - x=yy`_ | 如 `x=yy`，返回 `-1`，否则返回 `0`。<br/>`-2^7 <= yy < 2^7`。 | `26` |
| **`C000`** | `ISZERO` | _`x - x=0`_ | 检查一个整数是否为零。对应 Forth 的 `0=`。 | `26` |
| **`C1yy`** | `[yy] LESSINT`<br/>`[yy-1] LEQINT` | _`x - x<yy`_ | 如 `x<yy`，返回 `-1`，否则返回 `0`。<br/>`-2^7 <= yy < 2^7`。 | `26` |
| **`C100`** | `ISNEG` | _`x - x<0`_ | 检查一个整数是否为负数。对应 Forth 的 `0<`。 | `26` |
| **`C101`** | `ISNPOS` | _`x - x<=0`_ | 检查一个整数是否非正。 | `26` |
| **`C2yy`** | `[yy] GTINT`<br/>`[yy+1] GEQINT` | _`x - x>yy`_ | 如 `x>yy`，返回 `-1`，否则返回 `0`。<br/>`-2^7 <= yy < 2^7`。 | `26` |
| **`C200`** | `ISPOS` | _`x - x>0`_ | 检查一个整数是否为正数。对应 Forth 的 `0>`。 | `26` |
| **`C2FF`** | `ISNNEG` | _`x - x >=0`_ | 检查一个整数是否非负。 | `26` |
| **`C3yy`** | `[yy] NEQINT` | _`x - x!=yy`_ | 如 `x!=yy`，返回 `-1`，否则返回 `0`。<br/>`-2^7 <= yy < 2^7`。 | `26` |
| **`C4`** | `ISNAN` | _`x - x=NaN`_ | 检查 `x` 是否为 `NaN`。 | `18` |
| **`C5`** | `CHKNAN` | _`x - x`_ | 如果 `x` 为 `NaN`，抛出算术溢出异常。 | `18/68` |
### 6.2 其他比较
这些“其他比较”原语中的大多数实际上将_Slice_的数据部分作为位串进行比较（如果没有另外声明，忽略引用）。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`C700`** | `SEMPTY` | _`s - ?`_ | 检查切片 `s` 是否为空（即，不包含任何数据位和cell引用）。 | `26` |
| **`C701`** | `SDEMPTY` | _`s - ?`_ | 检查切片 `s` 是否没有数据位。 | `26` |
| **`C702`** | `SREMPTY` | _`s - ?`_ | 检查切片 `s` 是否没有引用。 | `26` |
| **`C703`** | `SDFIRST` | _`s - ?`_ | 检查切片 `s` 的第一个位是否为一。 | `26` |
| **`C704`** | `SDLEXCMP` | _`s s' - x`_ | 字典序比较 `s` 和 `s'` 的数据，根据结果返回 `-1`、0 或 1。 | `26` |
| **`C705`** | `SDEQ` | _`s s' - ?`_ | 检查 `s` 和 `s'` 的数据部分是否一致，等同于 [`SDLEXCMP`](#instr-sdlexcmp) [`ISZERO`](#instr-iszero)。 | `26` |
| **`C708`** | `SDPFX` | _`s s' - ?`_ | 检查 `s` 是否是 `s'` 的前缀。 | `26` |
| **`C709`** | `SDPFXREV` | _`s s' - ?`_ | 检查 `s'` 是否是 `s` 的前缀，等同于 [`SWAP`](#instr-swap) [`SDPFX`](#instr-sdpfx)。 | `26` |
| **`C70A`** | `SDPPFX` | _`s s' - ?`_ | 检查 `s` 是否是 `s'` 的真前缀（即，一个与 `s'` 不同的前缀）。 | `26` |
| **`C70B`** | `SDPPFXREV` | _`s s' - ?`_ | 检查 `s'` 是否是 `s` 的真前缀。 | `26` |
| **`C70C`** | `SDSFX` | _`s s' - ?`_ | 检查 `s` 是否是 `s'` 的后缀。 | `26` |
| **`C70D`** | `SDSFXREV` | _`s s' - ?`_ | 检查 `s'` 是否是 `s` 的后缀。 | `26` |
| **`C70E`** | `SDPSFX` | _`s s' - ?`_ | 检查 `s` 是否是 `s'` 的真后缀。 | `26` |
| **`C70F`** | `SDPSFXREV` | _`s s' - ?`_ | 检查 `s'` 是否是 `s` 的真后缀。 | `26` |
| **`C710`** | `SDCNTLEAD0` | _`s - n`_ | 返回 `s` 中前导零的数量。 | `26` |
| **`C711`** | `SDCNTLEAD1` | _`s - n`_ | 返回 `s` 中前导一的数量。 | `26` |
| **`C712`** | `SDCNTTRAIL0` | _`s - n`_ | 返回 `s` 中末尾零的数量。 | `26` |
| **`C713`** | `SDCNTTRAIL1` | _`s - n`_ | 返回 `s` 中末尾一的数量。 | `26` |

## 7 Cell 原语
### 7.1 Cell 序列化原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`C8`** | `NEWC` | _`- b`_ | 创建一个新的空 _构建器_。 | `18` |
| **`C9`** | `ENDC` | _`b - c`_ | 将 _构建器_ 转换为普通的 _cell_。 | `518` |
| **`CAcc`** | `[cc+1] STI` | _`x b - b'`_ | 将 `0 <= cc <= 255` 的有符号 `cc+1`-位整数 `x` 存入 _构建器_ `b` 中，如果 `x` 不适合于 `cc+1` 位，则抛出范围检查异常。 | `26` |
| **`CBcc`** | `[cc+1] STU` | _`x b - b'`_ | 将无符号的 `cc+1`-位整数 `x` 存入 _构建器_ `b` 中。在其他方面，它与 [`STI`](#instr-sti) 类似。 | `26` |
| **`CC`** | `STREF` | _`c b - b'`_ | 将 _cell_ `c` 的引用存入 _构建器_ `b` 中。 | `18` |
| **`CD`** | `STBREFR`<br/>`ENDCST` | _`b b'' - b`_ | 等同于 [`ENDC`](#instr-endc) [`SWAP`](#instr-swap) [`STREF`](#instr-stref)。 | `518` |
| **`CE`** | `STSLICE` | _`s b - b'`_ | 将 _分片_ `s` 存入 _构建器_ `b` 中。 | `18` |
| **`CF00`** | `STIX` | _`x b l - b'`_ | 为 `0 <= l <= 257`，将有符号 `l`-位整数 `x` 存入 `b` 中。 | `26` |
| **`CF01`** | `STUX` | _`x b l - b'`_ | 为 `0 <= l <= 256`，将无符号 `l`-位整数 `x` 存入 `b` 中。 | `26` |
| **`CF02`** | `STIXR` | _`b x l - b'`_ | 与 [`STIX`](#instr-stix) 类似，但参数顺序不同。 | `26` |
| **`CF03`** | `STUXR` | _`b x l - b'`_ | 与 [`STUX`](#instr-stux) 类似，但参数顺序不同。 | `26` |
| **`CF04`** | `STIXQ` | _`x b l - x b f or b' 0`_ | [`STIX`](#instr-stix) 的静默版本。如果 `b` 中没有空间，将 `b'=b` 和 `f=-1`。<br/>如果 `x` 不适合于 `l` 位，将 `b'=b` 和 `f=1`。<br/>如果操作成功，`b'` 是新的 _构建器_ 和 `f=0`。<br/>然而，`0 <= l <= 257`，如果不是这样，则抛出范围检查异常。 | `26` |
| **`CF05`** | `STUXQ` | _`x b l - x b f or b' 0`_ | [`STUX`](#instr-stux) 的静默版本。 | `26` |
| **`CF06`** | `STIXRQ` | _`b x l - b x f or b' 0`_ | [`STIXR`](#instr-stixr) 的静默版本。 | `26` |
| **`CF07`** | `STUXRQ` | _`b x l - b x f or b' 0`_ | [`STUXR`](#instr-stuxr) 的静默版本。 | `26` |
| **`CF08cc`** | `[cc+1] STI_l` | _`x b - b'`_ | [`[cc+1] STI`](#instr-sti) 的更长版本。 | `34` |
| **`CF09cc`** | `[cc+1] STU_l` | _`x b - b'`_ | [`[cc+1] STU`](#instr-stu) 的更长版本。 | `34` |
| **`CF0Acc`** | `[cc+1] STIR` | _`b x - b'`_ | 等同于 [`SWAP`](#instr-swap) [`[cc+1] STI`](#instr-sti)。 | `34` |
| **`CF0Bcc`** | `[cc+1] STUR` | _`b x - b'`_ | 等同于 [`SWAP`](#instr-swap) [`[cc+1] STU`](#instr-stu)。 | `34` |
| **`CF0Ccc`** | `[cc+1] STIQ` | _`x b - x b f or b' 0`_ | [`STI`](#instr-sti) 的静默版本。 | `34` |
| **`CF0Dcc`** | `[cc+1] STUQ` | _`x b - x b f or b' 0`_ | [`STU`](#instr-stu) 的静默版本。 | `34` |
| **`CF0Ecc`** | `[cc+1] STIRQ` | _`b x - b x f or b' 0`_ | [`STIR`](#instr-stir) 的静默版本。 | `34` |
| **`CF0Fcc`** | `[cc+1] STURQ` | _`b x - b x f or b' 0`_ | [`STUR`](#instr-stur) 的静默版本。 | `34` |
| **`CF10`** | `STREF_l` | _`c b - b'`_ | [`STREF`](#instr-stref) 的更长版本。 | `26` |
| **`CF11`** | `STBREF` | _`b' b - b''`_ | 等同于 [`SWAP`](#instr-swap) [`STBREFR`](#instr-stbrefr)。 | `526` |
| **`CF12`** | `STSLICE_l` | _`s b - b'`_ | [`STSLICE`](#instr-stslice) 的更长版本。 | `26` |
| **`CF13`** | `STB` | _`b' b - b''`_ | 将 _构建器_ `b'` 中的所有数据附加到 _构建器_ `b` 中。 | `26` |
| **`CF14`** | `STREFR` | _`b c - b'`_ | 等同于 [`SWAP`](#instr-swap) [`STREF`](#instr-stref)。 | `26` |
| **`CF15`** | `STBREFR_l` | _`b b' - b''`_ | [`STBREFR`](#instr-stbrefr) 的更长编码。 | `526` |
| **`CF16`** | `STSLICER` | _`b s - b'`_ | 等同于 [`SWAP`](#instr-swap) [`STSLICE`](#instr-stslice)。 | `26` |
| **`CF17`** | `STBR`<br/>`BCONCAT` | _`b b' - b''`_ | 连接两个构建器。<br/>等同于 [`SWAP`](#instr-swap) [`STB`](#instr-stb)。 | `26` |
| **`CF18`** | `STREFQ` | _`c b - c b -1 or b' 0`_ | [`STREF`](#instr-stref) 的静默版本。 | `26` |
| **`CF19`** | `STBREFQ` | _`b' b - b' b -1 or b'' 0`_ | [`STBREF`](#instr-stbref) 的静默版本。 | `526` |
| **`CF1A`** | `STSLICEQ` | _`s b - s b -1 or b' 0`_ | [`STSLICE`](#instr-stslice) 的静默版本。 | `26` |
| **`CF1B`** | `STBQ` | _`b' b - b' b -1 or b'' 0`_ | [`STB`](#instr-stb) 的静默版本。 | `26` |
| **`CF1C`** | `STREFRQ` | _`b c - b c -1 or b' 0`_ | [`STREFR`](#instr-strefr) 的静默版本。 | `26` |
| **`CF1D`** | `STBREFRQ` | _`b b' - b b' -1 or b'' 0`_ | [`STBREFR`](#instr-stbrefr) 的静默版本。 | `526` |
| **`CF1E`** | `STSLICERQ` | _`b s - b s -1 or b'' 0`_ | [`STSLICER`](#instr-stslicer) 的静默版本。 | `26` |
| **`CF1F`** | `STBRQ`<br/>`BCONCATQ` | _`b b' - b b' -1 or b'' 0`_ | [`STBR`](#instr-stbr) 的静默版本。 | `26` |
| **`CF20`** | `[ref] STREFCONST` | _`b - b’`_ | 等同于 [`PUSHREF`](#instr-pushref) [`STREFR`](#instr-strefr)。 | `26` |
| **`CF21`** | `[ref] [ref] STREF2CONST` | _`b - b’`_ | 等同于 [`STREFCONST`](#instr-strefconst) [`STREFCONST`](#instr-strefconst)。 | `26` |
| **`CF23`** |  | _`b x - c`_ | 如果 `x!=0`，从 _构建器_ `b` 创建一个 _特殊_ 或 _异类_ cell。<br/>异类cell的类型必须存储在 `b` 的前 8 位中。<br/>如果 `x=0`，它相当于 [`ENDC`](#instr-endc)。否则，将在创建异类cell之前对 `b` 的数据和引用执行一些有效性检查。 | `526` |
| **`CF28`** | `STILE4` | _`x b - b'`_ | 存储一个小端有符号 32 位整数。 | `26` |
| **`CF29`** | `STULE4` | _`x b - b'`_ | 存储一个小端无符号 32 位整数。 | `26` |
| **`CF2A`** | `STILE8` | _`x b - b'`_ | 存储一个小端有符号 64 位整数。 | `26` |
| **`CF2B`** | `STULE8` | _`x b - b'`_ | 存储一个小端无符号 64 位整数。 | `26` |
| **`CF30`** | `BDEPTH` | _`b - x`_ | 返回 _构建器_ `b` 的深度。如果 `b` 中没有存储cell引用，则 `x=0`；否则 `x` 是对 `b` 中引用的cell的深度的最大值加 1。 | `26` |
| **`CF31`** | `BBITS` | _`b - x`_ | 返回已经存储在 _构建器_ `b` 中的数据位数。 | `26` |
| **`CF32`** | `BREFS` | _`b - y`_ | 返回已经存储在 `b` 中的cell引用数。 | `26` |
| **`CF33`** | `BBITREFS` | _`b - x y`_ | 返回 `b` 中数据位数和cell引用数。 | `26` |
| **`CF35`** | `BREMBITS` | _`b - x'`_ | 返回仍然可以存储在 `b` 中的数据位数。 | `26` |
| **`CF36`** | `BREMREFS` | _`b - y'`_ | 返回仍然可以存储在 `b` 中的引用数。 | `26` |
| **`CF37`** | `BREMBITREFS` | _`b - x' y'`_ | 返回仍然可以存储在 `b` 中的数据位数和引用数。 | `26` |
| **`CF38cc`** | `[cc+1] BCHKBITS#` | _`b -`_ | 检查是否能将 `cc+1` 位存储到 `b` 中，其中 `0 <= cc <= 255`。 | `34/84` |
| **`CF39`** | `BCHKBITS` | _`b x - `_ | 检查是否能将 `x` 位存储到 `b` 中，`0 <= x <= 1023`。如果 `b` 中没有足够空间存储 `x` 更多位，或者 `x` 不在范围 `0...1023` 内，则抛出异常。 | `26/76` |
| **`CF3A`** | `BCHKREFS` | _`b y - `_ | 检查是否能将 `y` 引用存储到 `b` 中，`0 <= y <= 7`。 | `26/76` |
| **`CF3B`** | `BCHKBITREFS` | _`b x y - `_ | 检查是否能将 `x` 位和 `y` 引用存储到 `b` 中，`0 <= x <= 1023`，`0 <= y <= 7`。 | `26/76` |
| **`CF3Ccc`** | `[cc+1] BCHKBITSQ#` | _`b - ?`_ | 检查是否能将 `cc+1` 位存储到 `b` 中，其中 `0 <= cc <= 255`。 | `34` |
| **`CF3D`** | `BCHKBITSQ` | _`b x - ?`_ | 检查是否能将 `x` 位存储到 `b` 中，`0 <= x <= 1023`。 | `26` |
| **`CF3E`** | `BCHKREFSQ` | _`b y - ?`_ | 检查是否能将 `y` 引用存储到 `b` 中，`0 <= y <= 7`。 | `26` |
| **`CF3F`** | `BCHKBITREFSQ` | _`b x y - ?`_ | 检查是否能将 `x` 位和 `y` 引用存储到 `b` 中，`0 <= x <= 1023`，`0 <= y <= 7`。 | `26` |
| **`CF40`** | `STZEROES` | _`b n - b'`_ | 将 `n` 个二进制零存储到 _构建器_ `b` 中。 | `26` |
| **`CF41`** | `STONES` | _`b n - b'`_ | 将 `n` 个二进制一存储到 _构建器_ `b` 中。 | `26` |
| **`CF42`** | `STSAME` | _`b n x - b'`_ | 将 `n` 个二进制 `x`（`0 <= x <= 1`）存储到 _构建器_ `b` 中。 | `26` |
| **`CFC0_xysss`** | `[slice] STSLICECONST` | _`b - b'`_ | 存储一个常量子切片 `sss`。<br/>_详情：_ `sss` 由 `0 <= x <= 3` 个引用和最多 `8y+2` 个数据位组成，其中 `0 <= y <= 7`。假定有完成位。<br/>注意，如果切片过大，汇编器可以将 [`STSLICECONST`](#instr-stsliceconst) 替换为 [`PUSHSLICE`](#instr-pushslice) [`STSLICER`](#instr-stslicer)。 | `24` |
| **`CF81`** | `STZERO` | _`b - b'`_ | 存储一个二进制零。 | `24` |
| **`CF83`** | `STONE` | _`b - b'`_ | 存储一个二进制一。 | `24` |
### 7.2 Cell 反序列化原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`D0`** | `CTOS` | _`c - s`_ | 将 _cell_ 转换为 _切片_。请注意，`c` 必须是普通cell，或者是自动 _加载_ 以产生普通cell `c'` 的异类cell，然后转换为 _切片_。 | `118/43` |
| **`D1`** | `ENDS` | _`s - `_ | 从堆栈中移除 _切片_ `s`，如果不为空则抛出异常。 | `18/68` |
| **`D2cc`** | `[cc+1] LDI` | _`s - x s'`_ | 从 _切片_ `s` 中加载（即解析）一个有符号的 `cc+1`-位整数 `x`，并返回 `s` 的剩余部分作为 `s'`。 | `26` |
| **`D3cc`** | `[cc+1] LDU` | _`s - x s'`_ | 从 _切片_ `s` 中加载一个无符号 `cc+1`-位整数 `x`。 | `26` |
| **`D4`** | `LDREF` | _`s - c s'`_ | 从 `s` 中加载一个cell引用 `c`。 | `18` |
| **`D5`** | `LDREFRTOS` | _`s - s' s''`_ | 等效于 [`LDREF`](#instr-ldref) [`SWAP`](#instr-swap) [`CTOS`](#instr-ctos)。 | `118/43` |
| **`D6cc`** | `[cc+1] LDSLICE` | _`s - s'' s'`_ | 将 `s` 的接下来的 `cc+1` 位切割为一个独立的 _切片_ `s''`。 | `26` |
| **`D700`** | `LDIX` | _`s l - x s'`_ | 从 _切片_ `s` 中加载一个有符号的 `l`-位（`0 <= l <= 257`）整数 `x`，并返回 `s` 的剩余部分作为 `s'`。 | `26` |
| **`D701`** | `LDUX` | _`s l - x s'`_ | 从 `s` 的前 `l` 位（`0 <= l <= 256`）加载一个无符号 `l`-位整数 `x`。 | `26` |
| **`D702`** | `PLDIX` | _`s l - x`_ | 从 _切片_ `s` 中预加载一个有符号 `l`-位整数，`0 <= l <= 257`。 | `26` |
| **`D703`** | `PLDUX` | _`s l - x`_ | 从 `s` 中预加载一个无符号 `l`-位整数，`0 <= l <= 256`。 | `26` |
| **`D704`** | `LDIXQ` | _`s l - x s' -1 or s 0`_ | [`LDIX`](#instr-ldix) 的静默版本：类似地从 `s` 中加载一个有符号 `l`-位整数，但在成功时返回一个成功标志位 `-1`，失败时（如果 `s` 没有 `l` 位）返回 `0`，而不是抛出cell下溢异常。 | `26` |
| **`D705`** | `LDUXQ` | _`s l - x s' -1 or s 0`_ | [`LDUX`](#instr-ldux) 的静默版本。 | `26` |
| **`D706`** | `PLDIXQ` | _`s l - x -1 or 0`_ | [`PLDIX`](#instr-pldix) 的静默版本。 | `26` |
| **`D707`** | `PLDUXQ` | _`s l - x -1 or 0`_ | [`PLDUX`](#instr-pldux) 的静默版本。 | `26` |
| **`D708cc`** | `[cc+1] LDI_l` | _`s - x s'`_ | [`LDI`](#instr-ldi) 的更长编码。 | `34` |
| **`D709cc`** | `[cc+1] LDU_l` | _`s - x s'`_ | [`LDU`](#instr-ldu) 的更长编码。 | `34` |
| **`D70Acc`** | `[cc+1] PLDI` | _`s - x`_ | 从 _切片_ `s` 中预加载一个有符号 `cc+1`-位整数。 | `34` |
| **`D70Bcc`** | `[cc+1] PLDU` | _`s - x`_ | 从 `s` 中预加载一个无符号 `cc+1`-位整数。 | `34` |
| **`D70Ccc`** | `[cc+1] LDIQ` | _`s - x s' -1 or s 0`_ | [`LDI`](#instr-ldi) 的静默版本。 | `34` |
| **`D70Dcc`** | `[cc+1] LDUQ` | _`s - x s' -1 or s 0`_ | [`LDU`](#instr-ldu) 的静默版本。 | `34` |
| **`D70Ecc`** | `[cc+1] PLDIQ` | _`s - x -1 or 0`_ | [`PLDI`](#instr-pldi) 的静默版本。 | `34` |
| **`D70Fcc`** | `[cc+1] PLDUQ` | _`s - x -1 or 0`_ | [`PLDU`](#instr-pldu) 的静默版本。 | `34` |
| **`D714_c`** | `[32(c+1)] PLDUZ` | _`s - s x`_ | 从 _切片_ `s` 中预加载前 `32(c+1)` 位到无符号整数 `x` 中，`0 <= c <= 7`。如果 `s` 比必要的短，缺失的位假定为零。此操作旨在与 [`IFBITJMP`](#instr-ifbitjmp) 及类似指令一起使用。 | `26` |
| **`D718`** | `LDSLICEX` | _`s l - s'' s'`_ | 从 _切片_ `s` 中加载前 `0 <= l <= 1023` 位到一个单独的 _切片_ `s''` 中，返回 `s` 的剩余部分作为 `s'`。 | `26` |
| **`D719`** | `PLDSLICEX` | _`s l - s''`_ | 返回 `s` 的前 `0 <= l <= 1023` 位作为 `s''`。 | `26` |
| **`D71A`** | `LDSLICEXQ` | _`s l - s'' s' -1 or s 0`_ | [`LDSLICEX`](#instr-ldslicex) 的静默版本。 | `26` |
| **`D71B`** | `PLDSLICEXQ` | _`s l - s' -1 or 0`_ | [`LDSLICEXQ`](#instr-ldslicexq) 的静默版本。 | `26` |
| **`D71Ccc`** | `[cc+1] LDSLICE_l` | _`s - s'' s'`_ | [`LDSLICE`](#instr-ldslice) 的更长编码。 | `34` |
| **`D71Dcc`** | `[cc+1] PLDSLICE` | _`s - s''`_ | 返回 `s` 的前 `0 < cc+1 <= 256` 位作为 `s''`。 | `34` |
| **`D71Ecc`** | `[cc+1] LDSLICEQ` | _`s - s'' s' -1 or s 0`_ | [`LDSLICE`](#instr-ldslice) 的静默版本。 | `34` |
| **`D71Fcc`** | `[cc+1] PLDSLICEQ` | _`s - s'' -1 or 0`_ | [`PLDSLICE`](#instr-pldslice) 的静默版本。 | `34` |
| **`D720`** | `SDCUTFIRST` | _`s l - s'`_ | 返回 `s` 的前 `0 <= l <= 1023` 位。与 [`PLDSLICEX`](#instr-pldslicex) 等效。 | `26` |
| **`D721`** | `SDSKIPFIRST` | _`s l - s'`_ | 返回除了 `s` 的前 `0 <= l <= 1023` 位以外的所有位。与 [`LDSLICEX`](#instr-ldslicex) [`NIP`](#instr-nip) 等效。 | `26` |
| **`D722`** | `SDCUTLAST` | _`s l - s'`_ | 返回 `s` 的后 `0 <= l <= 1023` 位。 | `26` |
| **`D723`** | `SDSKIPLAST` | _`s l - s'`_ | 返回除了 `s` 的后 `0 <= l <= 1023` 位以外的所有位。 | `26` |
| **`D724`** | `SDSUBSTR` | _`s l l' - s'`_ | 返回 `s` 的从偏移量 `0 <= l <= 1023` 开始的 `0 <= l' <= 1023` 位，从 `s` 的数据中提取出一个位子字符串。 | `26` |
| **`D726`** | `SDBEGINSX` | _`s s' - s''`_ | 检查 `s` 是否以 `s'`（数据位）开始，并在成功时从 `s` 中移除 `s'`。失败抛出cell反序列化异常。原语 [`SDPFXREV`](#instr-sdpfxrev) 可以认为是 [`SDBEGINSX`](#instr-sdbeginsx) 的静默版本。 | `26` |
| **`D727`** | `SDBEGINSXQ` | _`s s' - s'' -1 or s 0`_ | [`SDBEGINSX`](#instr-sdbeginsx) 的静默版本。 | `26` |
| **`D72A_xsss`** | `[slice] SDBEGINS` | _`s - s''`_ | 检查 `s` 是否以常量位串 `sss` 开始，`sss` 的长度为 `8x+3`（假定有完成位），其中 `0 <= x <= 127`，并在成功时从 `s` 中移除 `sss`。 | `31` |
| **`D72E_xsss`** | `[slice] SDBEGINSQ` | _`s - s'' -1 or s 0`_ | [`SDBEGINS`](#instr-sdbegins) 的静默版本。 | `31` |
| **`D730`** | `SCUTFIRST` | _`s l r - s'`_ | 返回 `s` 的前 `0 <= l <= 1023` 位和前 `0 <= r <= 4` 个引用。 | `26` |
| **`D731`** | `SSKIPFIRST` | _`s l r - s'`_ | 返回除了 `s` 的前 `l` 位和 `r` 个引用以外的所有内容。 | `26` |
| **`D732`** | `SCUTLAST` | _`s l r - s'`_ | 返回 `s` 的后 `0 <= l <= 1023` 个数据位和后 `0 <= r <= 4` 个引用。 | `26` |
| **`D733`** | `SSKIPLAST` | _`s l r - s'`_ | 返回除了 `s` 的后 `l` 位和 `r` 个引用以外的所有内容。 | `26` |
| **`D734`** | `SUBSLICE` | _`s l r l' r' - s'`_ | 在跳过 `s` 的前 `0 <= l <= 1023` 位和前 `0 <= r <= 4` 个引用后，返回来自 _切片_ `s` 的 `0 <= l' <= 1023` 位和 `0 <= r' <= 4` 个引用。 | `26` |
| **`D736`** | `SPLIT` | _`s l r - s' s''`_ | 将 `s` 的前 `0 <= l <= 1023` 个数据位和前 `0 <= r <= 4` 个引用分割成 `s'`，并返回 `s` 的剩余部分作为 `s''`。 | `26` |
| **`D737`** | `SPLITQ` | _`s l r - s' s'' -1 或 s 0`_ | [`SPLIT`](#instr-split) 的静默版本。 | `26` |
| **`D739`** |  | _`c - s？`_ | 将普通或异类cell转换为 _切片_，就好像它是一个普通cell一样。返回一个标志位，指示 `c` 是否是异类的。如果是这样，其类型可以稍后从 `s` 的前八位中反序列化。 |  |
| **`D73A`** |  | _`c - c'`_ | 加载异类cell `c` 并返回一个普通cell `c'`。如果 `c` 已经是普通的，则不执行任何操作。如果 `c` 无法加载，抛出异常。 |  |
| **`D73B`** |  | _`c - c' -1 或 c 0`_ | 加载异类cell `c` 并返回一个普通cell `c'`。如果 `c` 已经是普通的，则不执行任何操作。如果 `c` 无法加载，返回 0。 |  |
| **`D741`** | `SCHKBITS` | _`s l - `_ | 检查 _切片_ `s` 中是否至少有 `l` 个数据位。如果不是这种情况，抛出cell反序列化（即cell下溢）异常。 | `26/76` |
| **`D742`** | `SCHKREFS` | _`s r - `_ | 检查 _切片_ `s` 中是否至少有 `r` 个引用。 | `26/76` |
| **`D743`** | `SCHKBITREFS` | _`s l r - `_ | 检查 _切片_ `s` 中是否至少有 `l` 个数据位和 `r` 个引用。 | `26/76` |
| **`D745`** | `SCHKBITSQ` | _`s l - ?`_ | 检查 _切片_ `s` 中是否至少有 `l` 个数据位。 | `26` |
| **`D746`** | `SCHKREFSQ` | _`s r - ?`_ | 检查 _切片_ `s` 中是否至少有 `r` 个引用。 | `26` |
| **`D747`** | `SCHKBITREFSQ` | _`s l r - ?`_ | 检查 _切片_ `s` 中是否至少有 `l` 个数据位和 `r` 个引用。 | `26` |
| **`D748`** | `PLDREFVAR` | _`s n - c`_ | 返回 _切片_ `s` 的第 `n` 个cell引用，`0 <= n <= 3`。 | `26` |
| **`D749`** | `SBITS` | _`s - l`_ | 返回 _切片_ `s` 中的数据位数。 | `26` |
| **`D74A`** | `SREFS` | _`s - r`_ | 返回 _切片_ `s` 中的引用数。 | `26` |
| **`D74B`** | `SBITREFS` | _`s - l r`_ | 返回 `s` 中的数据位数和引用数。 | `26` |
| **`D74E_n`** | `[n] PLDREFIDX` | _`s - c`_ | 返回 _切片_ `s` 的第 `n` 个cell引用，`0 <= n <= 3`。 | `26` |
| **`D74C`** | `PLDREF` | _`s - c`_ | 预加载 _切片_ 的第一个cell引用。 | `26` |
| **`D750`** | `LDILE4` | _`s - x s'`_ | 加载一个小端有符号 32 位整数。 | `26` |
| **`D751`** | `LDULE4` | _`s - x s'`_ | 加载一个小端无符号 32 位整数。 | `26` |
| **`D752`** | `LDILE8` | _`s - x s'`_ | 加载一个小端有符号 64 位整数。 | `26` |
| **`D753`** | `LDULE8` | _`s - x s'`_ | 加载一个小端无符号 64 位整数。 | `26` |
| **`D754`** | `PLDILE4` | _`s - x`_ | 预加载一个小端有符号 32 位整数。 | `26` |
| **`D755`** | `PLDULE4` | _`s - x`_ | 预加载一个小端无符号 32 位整数。 | `26` |
| **`D756`** | `PLDILE8` | _`s - x`_ | 预加载一个小端有符号 64 位整数。 | `26` |
| **`D757`** | `PLDULE8` | _`s - x`_ | 预加载一个小端无符号 64 位整数。 | `26` |
| **`D758`** | `LDILE4Q` | _`s - x s' -1 或 s 0`_ | 静默加载一个小端有符号 32 位整数。 | `26` |
| **`D759`** | `LDULE4Q` | _`s - x s' -1 或 s 0`_ | 静默加载一个小端无符号 32 位整数。 | `26` |
| **`D75A`** | `LDILE8Q` | _`s - x s' -1 或 s 0`_ | 静默加载一个小端有符号 64 位整数。 | `26` |
| **`D75B`** | `LDULE8Q` | _`s - x s' -1 或 s 0`_ | 静默加载一个小端无符号 64 位整数。 | `26` |
| **`D75C`** | `PLDILE4Q` | _`s - x -1 或 0`_ | 静默预加载一个小端有符号 32 位整数。 | `26` |
| **`D75D`** | `PLDULE4Q` | _`s - x -1 或 0`_ | 静默预加载一个小端无符号 32 位整数。 | `26` |
| **`D75E`** | `PLDILE8Q` | _`s - x -1 或 0`_ | 静默预加载一个小端有符号 64 位整数。 | `26` |
| **`D75F`** | `PLDULE8Q` | _`s - x -1 或 0`_ | 静默预加载一个小端无符号 64 位整数。 | `26` |
| **`D760`** | `LDZEROES` | _`s - n s'`_ | 返回 `s` 中前导零位的计数 `n`，并从 `s` 中移除这些位。 | `26` |
| **`D761`** | `LDONES` | _`s - n s'`_ | 返回 `s` 中前导一位的计数 `n`，并从 `s` 中移除这些位。 | `26` |
| **`D762`** | `LDSAME` | _`s x - n s'`_ | 返回 `s` 中与 `0 <= x <= 1` 相等的前导位的计数 `n`，并从 `s` 中移除这些位。 | `26` |
| **`D764`** | `SDEPTH` | _`s - x`_ | 返回 _切片_ `s` 的深度。如果 `s` 没有引用，则 `x=0`；否则 `x` 是从 `s` 引用的cell的最大深度加 1。 | `26` |
| **`D765`** | `CDEPTH` | _`c - x`_ | 返回 _cell_ `c` 的深度。如果 `c` 没有引用，则 `x=0`；否则 `x` 是从 `c` 引用的cell的最大深度加 1。如果 `c` 是 _空（Null）_ 而不是 _cell_，返回零。 | `26` |

## 8 Continuation 和控制流原语
### 8.1 无条件控制流原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`D8`** | `EXECUTE`<br/>`CALLX` | _`c - `_ | _调用_ 或 _执行_ Continuation `c`。 | `18` |
| **`D9`** | `JMPX` | _`c - `_ | _跳转_ 或 控制转移到 Continuation `c`。<br/>之前当前continuation `cc`的剩余部分被丢弃。 | `18` |
| **`DApr`** | `[p] [r] CALLXARGS` | _`c - `_ | 用 `p` 参数 _调用_ continuation `c` 并期待 `r` 返回值<br/>`0 <= p <= 15`, `0 <= r <= 15` | `26` |
| **`DB0p`** | `[p] -1 CALLXARGS` | _`c - `_ | 用 `0 <= p <= 15` 参数 _调用_ continuation `c`, 期望任意数量的返回值。 | `26` |
| **`DB1p`** | `[p] JMPXARGS` | _`c - `_ | _跳转_ 到 continuation `c`, 只将当前栈顶的 `0 <= p <= 15` 个值传递给它（当前栈的其余部分被丢弃）。 | `26` |
| **`DB2r`** | `[r] RETARGS` |  | _返回_ 到 `c0`, 携带 `0 <= r <= 15` 个从当前栈中取得的返回值。 | `26` |
| **`DB30`** | `RET`<br/>`RETTRUE` |  | _返回_ 到 continuation `c0`。当前 continuation `cc`的剩余部分被丢弃。<br/>大致相当于 [`c0 PUSHCTR`](#instr-pushctr) [`JMPX`](#instr-jmpx)。 | `26` |
| **`DB31`** | `RETALT`<br/>`RETFALSE` |  | _返回_ 到 continuation `c1`。<br/>大致相当于 [`c1 PUSHCTR`](#instr-pushctr) [`JMPX`](#instr-jmpx)。 | `26` |
| **`DB32`** | `BRANCH`<br/>`RETBOOL` | _`f - `_ | 如果整数 `f!=0`, 执行 [`RETTRUE`](#instr-ret)，如果 `f=0`，执行 [`RETFALSE`](#instr-retalt)。 | `26` |
| **`DB34`** | `CALLCC` | _`c - `_ | _带当前 continuation 调用_，控制权转移到 `c`，将旧的 `cc` 值推入 `c` 的栈中（而不是丢弃它或将其写入新的 `c0`中）。 | `26` |
| **`DB35`** | `JMPXDATA` | _`c - `_ | 类似于 [`CALLCC`](#instr-callcc)，但是当前 continuation 的剩余部分（旧的 `cc` 值）在推入 `c` 的栈之前被转换成一个 _Slice_。 | `26` |
| **`DB36pr`** | `[p] [r] CALLCCARGS` | _`c - `_ | 类似于 [`CALLXARGS`](#instr-callxargs)，但是将旧的 `cc` 值（连同最初栈顶的 `0 <= p <= 15` 个值）推入被调用 continuation `c` 的栈中，设置 `cc.nargs` 为 `-1 <= r <= 14`。 | `34` |
| **`DB38`** | `CALLXVARARGS` | _`c p r - `_ | 类似于 [`CALLXARGS`](#instr-callxargs)，但从栈中取 `-1 <= p,r <= 254`。接下来的三个操作也从栈中取 `p` 和 `r`，范围都是 `-1...254`。 | `26` |
| **`DB39`** | `RETVARARGS` | _`p r - `_ | 类似于 [`RETARGS`](#instr-retargs)。 | `26` |
| **`DB3A`** | `JMPXVARARGS` | _`c p r - `_ | 类似于 [`JMPXARGS`](#instr-jmpxargs)。 | `26` |
| **`DB3B`** | `CALLCCVARARGS` | _`c p r - `_ | 类似于 [`CALLCCARGS`](#instr-callccargs)。 | `26` |
| **`DB3C`** | `[ref] CALLREF` |  | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`CALLX`](#instr-execute)。 | `126/51` |
| **`DB3D`** | `[ref] JMPREF` |  | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`JMPX`](#instr-jmpx)。 | `126/51` |
| **`DB3E`** | `[ref] JMPREFDATA` |  | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`JMPXDATA`](#instr-jmpxdata)。 | `126/51` |
| **`DB3F`** | `RETDATA` |  | 等同于 [`c0 PUSHCTR`](#instr-pushctr) [`JMPXDATA`](#instr-jmpxdata)。这样，当前 continuation 的剩余部分被转换成一个 _Slice_ 并返回给调用者。 | `26` |
### 8.2 条件控制流原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`DC`** | `IFRET`<br/>`IFNOT:` | _`f - `_ | 如果整数 `f` 非零，则执行 [`RET`](#instr-ret)。如果 `f` 是 `NaN`, 抛出一个整数溢出异常。 | `18` |
| **`DD`** | `IFNOTRET`<br/>`IF:` | _`f - `_ | 如果整数 `f` 为零，则执行 [`RET`](#instr-ret)。 | `18` |
| **`DE`** | `IF` | _`f c - `_ | 如果整数 `f` 非零，执行 `c`（即，_执行_ `c`），否则简单地丢弃两个值。 | `18` |
| **`DE`** | `IF:<{ code }>`<br/>`<{ code }>IF` | _`f -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`IF`](#instr-if)。 |  |
| **`DF`** | `IFNOT` | _`f c - `_ | 如果整数 `f` 为零，则执行 continuation `c`，否则简单地丢弃两个值。 | `18` |
| **`DF`** | `IFNOT:<{ code }>`<br/>`<{ code }>IFNOT` | _`f -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`IFNOT`](#instr-ifnot)。 |  |
| **`E0`** | `IFJMP` | _`f c - `_ | 只有当 `f` 非零时，跳转到 `c`（类似于 [`JMPX`](#instr-jmpx)）。 | `18` |
| **`E0`** | `IFJMP:<{ code }>` | _`f -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`IFJMP`](#instr-ifjmp)。 |  |
| **`E1`** | `IFNOTJMP` | _`f c - `_ | 只有当 `f` 为零时，跳转到 `c`（类似于 [`JMPX`](#instr-jmpx)）。 | `18` |
| **`E1`** | `IFNOTJMP:<{ code }>` | _`f -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`IFNOTJMP`](#instr-ifnotjmp)。 |  |
| **`E2`** | `IFELSE` | _`f c c' - `_ | 如果整数 `f` 非零，执行 `c`，否则执行 `c'`。等同于 [`CONDSELCHK`](#instr-condselchk) [`EXECUTE`](#instr-execute)。 | `18` |
| **`E2`** | `IF:<{ code1 }>ELSE<{ code2 }>` | _`f -`_ | 等同于 [`<{ code1 }> CONT`](#instr-pushcont) [`<{ code2 }> CONT`](#instr-pushcont) [`IFELSE`](#instr-ifelse)。 |  |
| **`E300`** | `[ref] IFREF` | _`f - `_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`IF`](#instr-if)，但优化了cell引用不实际加载入一个 _Slice_ 再转换成一个普通 _Continuation_ 如果 `f=0`。<br/>这个原语的 Gas 消耗取决于 `f=0` 以及引用是否之前加载过。<br/>类似的评论适用于接受 continuation 作为引用的其他原语。 | `26/126/51` |
| **`E301`** | `[ref] IFNOTREF` | _`f - `_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`IFNOT`](#instr-ifnot)。 | `26/126/51` |
| **`E302`** | `[ref] IFJMPREF` | _`f - `_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`IFJMP`](#instr-ifjmp)。 | `26/126/51` |
| **`E303`** | `[ref] IFNOTJMPREF` | _`f - `_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`IFNOTJMP`](#instr-ifnotjmp)。 | `26/126/51` |
| **`E304`** | `CONDSEL` | _`f x y - x 或 y`_ | 如果整数 `f` 非零，返回 `x`，否则返回 `y`。注意 `x` 和 `y` 上不执行类型检查；因此，它更像是一个条件栈操作。大致等同于 [`ROT`](#instr-rot) [`ISZERO`](#instr-iszero) [`INC`](#instr-inc) [`ROLLX`](#instr-rollx) [`NIP`](#instr-nip)。 | `26` |
| **`E305`** | `CONDSELCHK` | _`f x y - x 或 y`_ | 与 [`CONDSEL`](#instr-condsel) 相同，但首先检查 `x` 和 `y` 是否类型相同。 | `26` |
| **`E308`** | `IFRETALT` | _`f -`_ | 如果整数 `f!=0` 执行 [`RETALT`](#instr-retalt)。 | `26` |
| **`E309`** | `IFNOTRETALT` | _`f -`_ | 如果整数 `f=0` 执行 [`RETALT`](#instr-retalt)。 | `26` |
| **`E30D`** | `[ref] IFREFELSE` | _`f c -`_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`SWAP`](#instr-swap) [`IFELSE`](#instr-ifelse)，但优化了在 `f=0` 时，实际上并不需要将cell引用加载进一个_Slice_，然后再转换成普通的 _Continuation_。对接下来的两个原语也适用类似的备注：只有在必要时，才将cell转换成 continuations。 | `26/126/51` |
| **`E30E`** | `[ref] IFELSEREF` | _`f c -`_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`IFELSE`](#instr-ifelse)。 | `26/126/51` |
| **`E30F`** | `[ref] [ref] IFREFELSEREF` | _`f -`_ | 等同于 [`PUSHREFCONT`](#instr-pushrefcont) [`PUSHREFCONT`](#instr-pushrefcont) [`IFELSE`](#instr-ifelse)。 | `126/51` |
| **`E39_n`** | `[n] IFBITJMP` | _`x c - x`_ | 检查整数 `x` 中是否设置了位 `0 <= n <= 31`，如果是，则执行 [`JMPX`](#instr-jmpx) 跳转到 continuation `c`。值 `x` 保留在栈中。 | `26` |
| **`E3B_n`** | `[n] IFNBITJMP` | _`x c - x`_ | 如果整数 `x` 中位 `0 <= n <= 31` 未设置，跳转到 `c`。 | `26` |
| **`E3D_n`** | `[ref] [n] IFBITJMPREF` | _`x - x`_ | 如果整数 `x` 中设置了位 `0 <= n <= 31`，执行 [`JMPREF`](#instr-jmpref)。 | `126/51` |
| **`E3F_n`** | `[ref] [n] IFNBITJMPREF` | _`x - x`_ | 如果整数 `x` 中未设置位 `0 <= n <= 31`，执行 [`JMPREF`](#instr-jmpref)。 | `126/51` |
### 8.3 控制流原语：循环
| xxxxxxx<br />操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`E4`** | `REPEAT` | _`n c - `_ | 如果整数 `n` 为非负数，则执行 continuation `c` `n` 次。如果 `n>=2^31` 或 `n<-2^31`，会生成一个范围检查异常。<br/>注意，在 `c` 的代码内部的 [`RET`](#instr-ret) 作为 `continue` 使用，而不是 `break`。应使用另一种（实验性的）循环或者 [`RETALT`](#instr-retalt)（循环前与 [`SETEXITALT`](#instr-setexitalt) 一起使用）来从循环中 `break` 出去。 | `18` |
| **`E4`** | `REPEAT:<{ code }>`<br/>`<{ code }>REPEAT` | _`n -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`REPEAT`](#instr-repeat)。 |  |
| **`E5`** | `REPEATEND`<br/>`REPEAT:` | _`n - `_ | 类似于 [`REPEAT`](#instr-repeat)，但它应用于当前 continuation `cc`。 | `18` |
| **`E6`** | `UNTIL` | _`c - `_ | 执行 continuation `c`，然后从结果栈中弹出一个整数 `x`。如果 `x` 为零，执行此循环的另一次迭代。这个原语的实际实现涉及一个特殊的 continuation `ec_until`，其参数设置为循环体（continuation `c`）和原始的当前 continuation `cc`。然后这个特殊的 continuation 被保存到 `c` 的 savelist 作为 `c.c0`，然后执行修改后的 `c`。其他循环原语也类似地借助适当的特殊 continuations 实现。 | `18` |
| **`E6`** | `UNTIL:<{ code }>`<br/>`<{ code }>UNTIL` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`UNTIL`](#instr-until)。 |  |
| **`E7`** | `UNTILEND`<br/>`UNTIL:` | _`-`_ | 类似于 [`UNTIL`](#instr-until)，但在循环中执行当前 continuation `cc`。当满足循环退出条件时，执行 [`RET`](#instr-ret)。 | `18` |
| **`E8`** | `WHILE` | _`c' c - `_ | 执行 `c'` 并从结果栈中弹出一个整数 `x`。如果 `x` 为零，则退出循环并将控制权转移给原始 `cc`。如果 `x` 非零，则执行 `c`，然后开始新的迭代。 | `18` |
| **`E8`** | `WHILE:<{ cond }>DO<{ code }>` | _`-`_ | 等同于 [`<{ cond }> CONT`](#instr-pushcont) [`<{ code }> CONT`](#instr-pushcont) [`WHILE`](#instr-while)。 |  |
| **`E9`** | `WHILEEND` | _`c' - `_ | 类似于 [`WHILE`](#instr-while)，但使用当前 continuation `cc` 作为循环体。 | `18` |
| **`EA`** | `AGAIN` | _`c - `_ | 类似于 [`REPEAT`](#instr-repeat)，但无限次执行 `c`。一个 [`RET`](#instr-ret) 只是开始一个无限循环的新迭代，只能通过异常或 [`RETALT`](#instr-retalt)（或显式的 [`JMPX`](#instr-jmpx)）退出。 | `18` |
| **`EA`** | `AGAIN:<{ code }>`<br/>`<{ code }>AGAIN` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`AGAIN`](#instr-again)。 |  |
| **`EB`** | `AGAINEND`<br/>`AGAIN:` | _`-`_ | 类似于 [`AGAIN`](#instr-again)，但相对于当前 continuation `cc` 执行。 | `18` |
| **`E314`** | `REPEATBRK` | _`n c -`_ | 类似于 [`REPEAT`](#instr-repeat)，但在将旧的 `c1` 值保存到原始 `cc`的 savelist 后，还将 `c1` 设置为原始 `cc`。这样，[`RETALT`](#instr-retalt) 可以用来退出循环体。 | `26` |
| **`E314`** | `REPEATBRK:<{ code }>`<br/>`<{ code }>REPEATBRK` | _`n -`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`REPEATBRK`](#instr-repeatbrk)。 |  |
| **`E315`** | `REPEATENDBRK` | _`n -`_ | 类似于 [`REPEATEND`](#instr-repeatend)，但在将旧的 `c1` 值保存到原始 `c0`的 savelist 后，还将 `c1` 设置为原始 `c0`。等同于 [`SAMEALTSAVE`](#instr-samealtsave) [`REPEATEND`](#instr-repeatend)。 | `26` |
| **`E316`** | `UNTILBRK` | _`c -`_ | 类似于 [`UNTIL`](#instr-until)，但也以与 [`REPEATBRK`](#instr-repeatbrk) 相同的方式修改 `c1`。 | `26` |
| **`E316`** | `UNTILBRK:<{ code }>` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`UNTILBRK`](#instr-untilbrk)。 |  |
| **`E317`** | `UNTILENDBRK`<br/>`UNTILBRK:` | _`-`_ | 等同于 [`SAMEALTSAVE`](#instr-samealtsave) [`UNTILEND`](#instr-untilend)。 | `26` |
| **`E318`** | `WHILEBRK` | _`c' c -`_ | 类似于 [`WHILE`](#instr-while)，但也以与 [`REPEATBRK`](#instr-repeatbrk) 相同的方式修改 `c1`。 | `26` |
| **`E318`** | `WHILEBRK:<{ cond }>DO<{ code }>` | _`-`_ | 等同于 [`<{ cond }> CONT`](#instr-pushcont) [`<{ code }> CONT`](#instr-pushcont) [`WHILEBRK`](#instr-whilebrk)。 |  |
| **`E319`** | `WHILEENDBRK` | _`c -`_ | 等同于 [`SAMEALTSAVE`](#instr-samealtsave) [`WHILEEND`](#instr-whileend)。 | `26` |
| **`E31A`** | `AGAINBRK` | _`c -`_ | 类似于 [`AGAIN`](#instr-again)，但也以与 [`REPEATBRK`](#instr-repeatbrk) 相同的方式修改 `c1`。 | `26` |
| **`E31A`** | `AGAINBRK:<{ code }>` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`AGAINBRK`](#instr-againbrk)。 |  |
| **`E31B`** | `AGAINENDBRK`<br/>`AGAINBRK:` | _`-`_ | 等同于 [`SAMEALTSAVE`](#instr-samealtsave) [`AGAINEND`](#instr-againend)。 | `26` |
### 8.4 操作 continuation 栈
这里的 `s"` 是[在 continuations 之间移动栈元素的费用](#11-gas-prices)。它等于结果栈的大小减去32（如果栈大小小于32，则为0）。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`ECrn`** | `[r] [n] SETCONTARGS` | _`x_1 x_2...x_r c - c'`_ | 类似于 [`[r] -1 SETCONTARGS`](#instr-setcontargs-n)，但将 `c.nargs` 设置为 `c'` 的栈的最终大小加上 `n`。换句话说，将 `c` 转换成一个_闭包_或_部分应用函数_，缺少 `0 <= n <= 14` 个参数。 | `26+s”` |
| **`EC0n`** | `[n] SETNUMARGS` | _`c - c'`_ | 设置 `c.nargs` 为 `n` 加上 `c` 的当前栈的深度，其中 `0 <= n <= 14`。如果 `c.nargs` 已经设置为非负值，则不进行任何操作。 | `26` |
| **`ECrF`** | `[r] -1 SETCONTARGS` | _`x_1 x_2...x_r c - c'`_ | 将 `0 <= r <= 15` 个值 `x_1...x_r` 推入（复制的）continuation `c` 的栈中，从 `x_1` 开始。如果 `c` 的栈最终深度超过了 `c.nargs`，将生成栈溢出异常。 | `26+s”` |
| **`ED0p`** | `[p] RETURNARGS` | _`-`_ | 仅保留当前栈顶的 `0 <= p <= 15` 个值（类似于 [`ONLYTOPX`](#instr-onlytopx)），所有未使用的底部值不被丢弃，而是以与 [`SETCONTARGS`](#instr-setcontargs-n) 相同的方式保存到 continuation `c0` 中。 | `26+s”` |
| **`ED10`** | `RETURNVARARGS` | _`p -`_ | 类似于 [`RETURNARGS`](#instr-returnargs)，但从栈中取整数 `0 <= p <= 255`。 | `26+s”` |
| **`ED11`** | `SETCONTVARARGS` | _`x_1 x_2...x_r c r n - c'`_ | 类似于 [`SETCONTARGS`](#instr-setcontargs-n)，但从栈中取 `0 <= r <= 255` 和 `-1 <= n <= 255`。 | `26+s”` |
| **`ED12`** | `SETNUMVARARGS` | _`c n - c'`_ | `-1 <= n <= 255`<br/>如果 `n=-1`，此操作不进行任何操作（`c'=c`）。<br/>否则其行为类似于 [`[n] SETNUMARGS`](#instr-setnumargs)，但 `n` 是从栈中取得的。 | `26` |
### 8.5 创建简单的 continuations 和 闭包
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`ED1E`** | `BLESS` | _`s - c`_ | 将 _Slice_ `s` 转换为简单的普通 continuation `c`，其中 `c.code=s`，并且栈和 savelist 为空。 | `26` |
| **`ED1F`** | `BLESSVARARGS` | _`x_1...x_r s r n - c`_ | 等同于 [`ROT`](#instr-rot) [`BLESS`](#instr-bless) [`ROTREV`](#instr-rotrev) [`SETCONTVARARGS`](#instr-setcontvarargs)。 | `26+s”` |
| **`EErn`** | `[r] [n] BLESSARGS` | _`x_1...x_r s - c`_ | `0 <= r <= 15`, `-1 <= n <= 14`<br/>等同于 [`BLESS`](#instr-bless) [`[r] [n] SETCONTARGS`](#instr-setcontargs-n)。<br/>`n` 的值由 4 位整数 `n mod 16` 内部表示。 | `26` |
| **`EE0n`** | `[n] BLESSNUMARGS` | _`s - c`_ | 也将 _Slice_ `s` 转换为 _Continuation_ `c`，但将 `c.nargs` 设置为 `0 <= n <= 14`。 | `26` |
### 8.6 Continuation 保存列表和控制寄存器的操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`ED4i`** | `c[i] PUSHCTR`<br/>`c[i] PUSH` | _`- x`_ | 推送控制寄存器 `c(i)` 的当前值。如果当前代码页不支持该控制寄存器，或者它没有值，则触发异常。 | `26` |
| **`ED44`** | `c4 PUSHCTR`<br/>`c4 PUSH` | _`- x`_ | 推送“全局数据根”cell引用，从而使访问持久智能合约数据成为可能。 | `26` |
| **`ED5i`** | `c[i] POPCTR`<br/>`c[i] POP` | _`x - `_ | 从栈中弹出一个值 `x` 并存储到控制寄存器 `c(i)` 中（如果当前代码页支持）。注意，如果控制寄存器仅接受特定类型的值，则可能发生类型检查异常。 | `26` |
| **`ED54`** | `c4 POPCTR`<br/>`c4 POP` | _`x -`_ | 设置“全局数据根”cell引用，从而允许修改持久智能合约数据。 | `26` |
| **`ED6i`** | `c[i] SETCONT`<br/>`c[i] SETCONTCTR` | _`x c - c'`_ | 将 `x` 存储到 continuation `c` 的 savelist 中作为 `c(i)`，并返回结果 continuation `c'`。几乎所有与 continuations 的操作都可以用 [`SETCONTCTR`](#instr-setcontctr)、[`POPCTR`](#instr-popctr) 和 [`PUSHCTR`](#instr-pushctr) 来表达。 | `26` |
| **`ED7i`** | `c[i] SETRETCTR` | _`x - `_ | 等同于 [`c0 PUSHCTR`](#instr-pushctr) [`c[i] SETCONTCTR`](#instr-setcontctr) [`c0 POPCTR`](#instr-popctr)。 | `26` |
| **`ED8i`** | `c[i] SETALTCTR` | _`x - `_ | 等同于 [`c1 PUSHCTR`](#instr-pushctr) [`c[i] SETCONTCTR`](#instr-setcontctr) [`c0 POPCTR`](#instr-popctr)。 | `26` |
| **`ED9i`** | `c[i] POPSAVE`<br/>`c[i] POPCTRSAVE` | _`x -`_ | 类似于 [`c[i] POPCTR`](#instr-popctr)，但还将 `c[i]` 的旧值保存到 continuation `c0` 中。<br/>等同于（直到异常）[`c[i] SAVECTR`](#instr-save) [`c[i] POPCTR`](#instr-popctr)。 | `26` |
| **`EDAi`** | `c[i] SAVE`<br/>`c[i] SAVECTR` |  | 将 `c(i)` 的当前值保存到 continuation `c0` 的 savelist 中。如果 `c0` 的 savelist 中已存在 `c[i]` 的条目，则不做任何操作。等同于 [`c[i] PUSHCTR`](#instr-pushctr) [`c[i] SETRETCTR`](#instr-setretctr)。 | `26` |
| **`EDBi`** | `c[i] SAVEALT`<br/>`c[i] SAVEALTCTR` |  | 类似于 [`c[i] SAVE`](#instr-save)，但将 `c[i]` 的当前值保存到 `c1`（而不是 `c0`）的 savelist 中。 | `26` |
| **`EDCi`** | `c[i] SAVEBOTH`<br/>`c[i] SAVEBOTHCTR` |  | 等同于 [`DUP`](#instr-dup) [`c[i] SAVE`](#instr-save) [`c[i] SAVEALT`](#instr-savealt)。 | `26` |
| **`EDE0`** | `PUSHCTRX` | _`i - x`_ | 类似于 [`c[i] PUSHCTR`](#instr-pushctr)，但 `i`, `0 <= i <= 255`, 来自栈。<br/>注意，这个原语是少数“异乎寻常”的原语之一，它们不像栈操作原语那样是多态的，同时参数和返回值的类型也没有良好定义，因为 `x` 的类型取决于 `i`。 | `26` |
| **`EDE1`** | `POPCTRX` | _`x i - `_ | 类似于 [`c[i] POPCTR`](#instr-popctr)，但 `0 <= i <= 255` 来自栈。 | `26` |
| **`EDE2`** | `SETCONTCTRX` | _`x c i - c'`_ | 类似于 [`c[i] SETCONTCTR`](#instr-setcontctr)，但 `0 <= i <= 255` 来自栈。 | `26` |
| **`EDF0`** | `COMPOS`<br/>`BOOLAND` | _`c c' - c''`_ | 计算组合 `compose0(c, c’)`，它的意义为“执行 `c`，如果成功，执行 `c'`”（如果 `c` 是布尔电路）或简单地“执行 `c`，然后执行 `c'`”。等同于 [`SWAP`](#instr-swap) [`c0 SETCONT`](#instr-setcontctr)。 | `26` |
| **`EDF1`** | `COMPOSALT`<br/>`BOOLOR` | _`c c' - c''`_ | 计算替代组合 `compose1(c, c’)`，它的意义为“执行 `c`，如果不成功，执行 `c'`”（如果 `c` 是布尔电路）。等同于 [`SWAP`](#instr-swap) [`c1 SETCONT`](#instr-setcontctr)。 | `26` |
| **`EDF2`** | `COMPOSBOTH` | _`c c' - c''`_ | 计算组合 `compose1(compose0(c, c’), c’)`，它的意义为“计算布尔电路 `c`，然后无论 `c` 的结果如何，都计算 `c'`”。 | `26` |
| **`EDF3`** | `ATEXIT` | _`c - `_ | 将 `c0` 设置为 `compose0(c, c0)`。换句话说，`c` 将在退出当前子程序之前执行。 | `26` |
| **`EDF3`** | `ATEXIT:<{ code }>`<br/>`<{ code }>ATEXIT` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`ATEXIT`](#instr-atexit)。 |  |
| **`EDF4`** | `ATEXITALT` | _`c - `_ | 将 `c1` 设置为 `compose1(c, c1)`。换句话说，`c` 将在通过其替代返回路径退出当前子程序之前执行。 | `26` |
| **`EDF4`** | `ATEXITALT:<{ code }>`<br/>`<{ code }>ATEXITALT` | _`-`_ | 等同于 [`<{ code }> CONT`](#instr-pushcont) [`ATEXITALT`](#instr-atexitalt)。 |  |
| **`EDF5`** | `SETEXITALT` | _`c - `_ | 将 `c1` 设置为 `compose1(compose0(c, c0), c1)`，<br/>这样，后续的 [`RETALT`](#instr-retalt) 将首先执行 `c`，然后将控制权转移给原始的 `c0`。例如，这可以用来从嵌套循环中退出。 | `26` |
| **`EDF6`** | `THENRET` | _`c - c'`_ | 计算 `compose0(c, c0)`。 | `26` |
| **`EDF7`** | `THENRETALT` | _`c - c'`_ | 计算 `compose0(c, c1)` | `26` |
| **`EDF8`** | `INVERT` | _`-`_ | 交换 `c0` 和 `c1`。 | `26` |
| **`EDF9`** | `BOOLEVAL` | _`c - ?`_ | 执行 `cc:=compose1(compose0(c, compose0(-1 PUSHINT, cc)), compose0(0 PUSHINT, cc))`。如果 `c` 代表一个布尔电路，其最终效果是评估它，并在继续执行之前将 `-1` 或 `0` 推入栈中。 | `26` |
| **`EDFA`** | `SAMEALT` | _`-`_ | 将 `c1` 设置为 `c0`。等同于 [`c0 PUSHCTR`](#instr-pushctr) [`c1 POPCTR`](#instr-popctr)。 | `26` |
| **`EDFB`** | `SAMEALTSAVE` | _`-`_ | 将 `c1` 设置为 `c0`，但首先将 `c1` 的旧值保存到 `c0` 的 savelist 中。<br/>等同于 [`c1 SAVE`](#instr-save) [`SAMEALT`](#instr-samealt)。 | `26` |
### 8.7 字典子程序调用和跳转
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F0nn`** | `[nn] CALL`<br/>`[nn] CALLDICT` | _`- nn`_ | 调用 `c3` 中的 continuation，将整数 `0 <= nn <= 255` 作为参数推入其栈。<br/>大致相当于 [`[nn] PUSHINT`](#instr-pushint-4) [`c3 PUSHCTR`](#instr-pushctr) [`EXECUTE`](#instr-execute)。 |  |
| **`F12_n`** | `[n] CALL`<br/>`[n] CALLDICT` | _`- n`_ | 对于 `0 <= n < 2^14`，这是更大值的 `n` 的 [`[n] CALL`](#instr-calldict) 的编码。 |  |
| **`F16_n`** | `[n] JMP` | _` - n`_ | 跳转到 `c3` 中的 continuation，将整数 `0 <= n < 2^14` 作为其参数推入。<br/>大致相当于 [`n PUSHINT`](#instr-pushint-4) [`c3 PUSHCTR`](#instr-pushctr) [`JMPX`](#instr-jmpx)。 |  |
| **`F1A_n`** | `[n] PREPARE`<br/>`[n] PREPAREDICT` | _` - n c`_ | 等同于 [`n PUSHINT`](#instr-pushint-4) [`c3 PUSHCTR`](#instr-pushctr)，适用于 `0 <= n < 2^14`。<br/>这样，[`[n] CALL`](#instr-calldict) 大致等同于 [`[n] PREPARE`](#instr-preparedict) [`EXECUTE`](#instr-execute)，而 [`[n] JMP`](#instr-jmpdict) 大致等同于 [`[n] PREPARE`](#instr-preparedict) [`JMPX`](#instr-jmpx)。<br/>例如，这里可以使用 [`CALLXARGS`](#instr-callxargs) 或 [`CALLCC`](#instr-callcc) 代替 [`EXECUTE`](#instr-execute)。 |  |

## 9 异常产生与处理原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F22_n`** | `[n] THROW` | _` - 0 n`_ | 抛出参数为零的 `0 <= n <= 63` 异常。<br/>换句话说，它将控制权转移到 `c2` 中的continuation，将 `0` 和 `n` 推入其堆栈，并彻底丢弃旧堆栈。 | `76` |
| **`F26_n`** | `[n] THROWIF` | _`f - `_ | 只有当整数 `f!=0` 时，才抛出参数为零的 `0 <= n <= 63` 异常。 | `26/76` |
| **`F2A_n`** | `[n] THROWIFNOT` | _`f - `_ | 只有当整数 `f=0` 时，才抛出参数为零的 `0 <= n <= 63` 异常。 | `26/76` |
| **`F2C4_n`** | `[n] THROW` | _`- 0 nn`_ | 对于 `0 <= n < 2^11`，是 [`[n] THROW`](#instr-throw-short) 的编码，用于 `n` 的较大值。 | `84` |
| **`F2CC_n`** | `[n] THROWARG` | _`x - x nn`_ | 抛出带有参数 `x` 的 `0 <= n <  2^11` 异常，通过将 `x` 和 `n` 复制到 `c2` 的堆栈并将控制权转移给 `c2`。 | `84` |
| **`F2D4_n`** | `[n] THROWIF` | _`f - `_ | 对于 `0 <= n < 2^11`，是 [`[n] THROWIF`](#instr-throwif-short) 的编码，用于 `n` 的较大值。 | `34/84` |
| **`F2DC_n`** | `[n] THROWARGIF` | _`x f - `_ | 只有当整数 `f!=0` 时，才抛出带有参数 `x` 的 `0 <= nn < 2^11` 异常。 | `34/84` |
| **`F2E4_n`** | `[n] THROWIFNOT` | _`f - `_ | 对于 `0 <= n < 2^11`，是 [`[n] THROWIFNOT`](#instr-throwifnot-short) 的编码，用于 `n` 的较大值。 | `34/84` |
| **`F2EC_n`** | `[n] THROWARGIFNOT` | _`x f - `_ | 只有当整数 `f=0` 时，才抛出带有参数 `x` 的 `0 <= n < 2^11` 异常。 | `34/84` |
| **`F2F0`** | `THROWANY` | _`n - 0 n`_ | 抛出参数为零的 `0 <= n < 2^16` 异常。<br/>大致相当于 [`ZERO`](#instr-zero) [`SWAP`](#instr-swap) [`THROWARGANY`](#instr-throwargany)。 | `76` |
| **`F2F1`** | `THROWARGANY` | _`x n - x n`_ | 抛出带有参数 `x` 的 `0 <= n < 2^16` 异常，将控制权转移到 `c2` 中。<br/>大致相当于 [`c2 PUSHCTR`](#instr-pushctr) [`2 JMPXARGS`](#instr-jmpxargs)。 | `76` |
| **`F2F2`** | `THROWANYIF` | _`n f - `_ | 只有当 `f!=0` 时，才抛出参数为零的 `0 <= n < 2^16` 异常。 | `26/76` |
| **`F2F3`** | `THROWARGANYIF` | _`x n f - `_ | 只有当 `f!=0` 时，才抛出带有参数 `x` 的 `0 <= n<2^16` 异常。 | `26/76` |
| **`F2F4`** | `THROWANYIFNOT` | _`n f - `_ | 只有当 `f=0` 时，才抛出参数为零的 `0 <= n<2^16` 异常。 | `26/76` |
| **`F2F5`** | `THROWARGANYIFNOT` | _`x n f - `_ | 只有当 `f=0` 时，才抛出带有参数 `x` 的 `0 <= n<2^16` 异常。 | `26/76` |
| **`F2FF`** | `TRY` | _`c c' - `_ | 设置 `c2` 为 `c'`，首先将 `c2` 的旧值同时保存到 `c'` 的保存列表和当前continuation的保存列表中，该当前continuation存储到 `c.c0` 和 `c'.c0` 中。然后类似于 [`EXECUTE`](#instr-execute) 运行 `c`。如果 `c` 没有引发任何异常，从 `c` 返回时会自动恢复 `c2` 的原始值。如果发生异常，则执行权转移到 `c'`，但在此过程中恢复了 `c2` 的原始值，以便 `c'` 可以通过 [`THROWANY`](#instr-throwany) 重新抛出异常（如果它自己无法处理）。 | `26` |
| **`F2FF`** | `TRY:<{ code1 }>CATCH<{ code2 }>` | _`-`_ | 等效于 [`<{ code1 }> CONT`](#instr-pushcont) [`<{ code2 }> CONT`](#instr-pushcont) [`TRY`](#instr-try)。 |  |
| **`F3pr`** | `[p] [r] TRYARGS` | _`c c' - `_ | 类似于 [`TRY`](#instr-try)，但内部使用的是 [`[p] [r] CALLXARGS`](#instr-callxargs) 而不是 [`EXECUTE`](#instr-execute)。<br/>这样，顶部 `0 <= p <= 15` 堆栈元素以外的所有元素将保存到当前continuation的堆栈中，然后从 `c` 或 `c'` 返回时恢复，并将 `c` 或 `c'` 的结果堆栈的顶部 `0 <= r <= 15` 值作为返回值复制。 | `26` |

## 10 字典操作原语
大多数字典操作的燃气消耗不是固定的，它取决于给定字典的内容。
### 10.1 字典创建
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`6D`** | `NEWDICT` | _` - D`_ | 返回一个新的空字典。<br/>它是 [`PUSHNULL`](#instr-null) 的另一种助记符。 | `18` |
| **`6E`** | `DICTEMPTY` | _`D - ?`_ | 检查字典 `D` 是否为空，并相应地返回 `-1` 或 `0`。<br/>它是 [`ISNULL`](#instr-isnull) 的另一种助记符。 | `18` |
### 10.2 字典序列化与反序列化
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`CE`** | `STDICTS`<br/>`` | _`s b - b'`_ | 将以_切片_表示的字典 `s` 存储进_构建器_ `b`中。<br/>实际上，这是 [`STSLICE`](#instr-stslice) 的同义词。 | `18` |
| **`F400`** | `STDICT`<br/>`STOPTREF` | _`D b - b'`_ | 将字典 `D` 存入_构建器_ `b`，返回结果 _构建器_ `b'`。<br/>换言之，如果 `D` 是一个cell，执行 [`STONE`](#instr-stone) 和 [`STREF`](#instr-stref)；如果 `D` 是 _Null_，执行 [`NIP`](#instr-nip) 和 [`STZERO`](#instr-stzero)；否则抛出类型检查异常。 | `26` |
| **`F401`** | `SKIPDICT`<br/>`SKIPOPTREF` | _`s - s'`_ | 相当于 [`LDDICT`](#instr-lddict) [`NIP`](#instr-nip)。 | `26` |
| **`F402`** | `LDDICTS` | _`s - s' s''`_ | 从_切片_ `s`中加载（解析）以_切片_表示的字典 `s'`，并将 `s`的剩余部分作为 `s''` 返回。<br/>这是所有 `HashmapE(n,X)` 类型字典的“分裂函数”。 | `26` |
| **`F403`** | `PLDDICTS` | _`s - s'`_ | 从_切片_ `s`中预加载以_切片_表示的字典 `s'`。<br/>大致相当于 [`LDDICTS`](#instr-lddicts) [`DROP`](#instr-drop)。 | `26` |
| **`F404`** | `LDDICT`<br/>`LDOPTREF` | _`s - D s'`_ | 从_切片_ `s`中加载（解析）字典 `D`，并将 `s`的剩余部分作为 `s'` 返回。可应用于字典或任意 `(^Y)?` 类型的值。 | `26` |
| **`F405`** | `PLDDICT`<br/>`PLDOPTREF` | _`s - D`_ | 从_切片_ `s`中预加载字典 `D`。<br/>大致相当于 [`LDDICT`](#instr-lddict) [`DROP`](#instr-drop)。 | `26` |
| **`F406`** | `LDDICTQ` | _`s - D s' -1或 s 0`_ | [`LDDICT`](#instr-lddict) 的静默版本。 | `26` |
| **`F407`** | `PLDDICTQ` | _`s - D -1或0`_ | [`PLDDICT`](#instr-plddict) 的静默版本。 | `26` |
### 10.3 获取字典操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F40A`** | `DICTGET` | _`k D n - x -1或0`_ | 在类型为 `HashmapE(n,X)` 且拥有 `n`-位键的字典 `D` 中查找键 `k`（由_切片_表示，其前 `0 <= n <= 1023` 数据位被用作键）。<br/>成功时，以_切片_ `x` 的形式返回找到的值。 |  |
| **`F40B`** | `DICTGETREF` | _`k D n - c -1或0`_ | 与 [`DICTGET`](#instr-dictget) 类似，但在成功时对 `x` 应用 [`LDREF`](#instr-ldref) [`ENDS`](#instr-ends)。<br/>此操作对于类型为 `HashmapE(n,^Y)` 的字典很有用。 |  |
| **`F40C`** | `DICTIGET` | _`i D n - x -1或0`_ | 与 [`DICTGET`](#instr-dictget) 类似，但使用带符号的（大端）`n`-位 _整型_ `i` 作为键。如果 `i` 不能放入 `n` 位，则返回 `0`。如果 `i` 是 `NaN`，抛出整数溢出异常。 |  |
| **`F40D`** | `DICTIGETREF` | _`i D n - c -1或0`_ | 组合 [`DICTIGET`](#instr-dictiget) 与 [`DICTGETREF`](#instr-dictgetref)：它使用带符号的 `n`-位 _整型_ `i` 作为键，并在成功时返回 _cell_ 而不是_切片_。 |  |
| **`F40E`** | `DICTUGET` | _`i D n - x -1或0`_ | 与 [`DICTIGET`](#instr-dictiget) 类似，但使用_无符号_的（大端）`n`-位 _整型_ `i` 作为键。 |  |
| **`F40F`** | `DICTUGETREF` | _`i D n - c -1或0`_ | 与 [`DICTIGETREF`](#instr-dictigetref) 类似，但使用一个无符号 `n`-位 _整型_ 键 `i`。 |  |
### 10.4 设置/替换/添加字典操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F412`** | `DICTSET` | _`x k D n - D'`_ | 在字典 `D`（同样用_切片_表示）中设置 `n`-位键 `k`（如 [`DICTGET`](#instr-dictget) 中用_切片_表示）关联的值为 `x`（再次是_切片_），并返回结果字典 `D'`。 |  |
| **`F413`** | `DICTSETREF` | _`c k D n - D'`_ | 类似于 [`DICTSET`](#instr-dictset)，但设置的值为对_cell_ `c` 的引用。 |  |
| **`F414`** | `DICTISET` | _`x i D n - D'`_ | 类似于 [`DICTSET`](#instr-dictset)，但键由（大端）有符号 `n`-位整数 `i` 表示。如果 `i` 不能放入 `n` 位，则生成范围检查异常。 |  |
| **`F415`** | `DICTISETREF` | _`c i D n - D'`_ | 类似于 [`DICTSETREF`](#instr-dictsetref)，但键由 [`DICTISET`](#instr-dictiset) 中的有符号 `n`-位整数表示。 |  |
| **`F416`** | `DICTUSET` | _`x i D n - D'`_ | 类似于 [`DICTISET`](#instr-dictiset)，但 `i` 为 _无符号_ `n`-位整数。 |  |
| **`F417`** | `DICTUSETREF` | _`c i D n - D'`_ | 类似于 [`DICTISETREF`](#instr-dictisetref)，但 `i` 为无符号。 |  |
| **`F41A`** | `DICTSETGET` | _`x k D n - D' y -1或 D' 0`_ | 结合 [`DICTSET`](#instr-dictset) 和 [`DICTGET`](#instr-dictget)：它将键 `k` 对应的值设置为 `x`，但也返回该键原有的旧值 `y`（如果存在）。 |  |
| **`F41B`** | `DICTSETGETREF` | _`c k D n - D' c' -1或 D' 0`_ | 类似于 [`DICTSETGET`](#instr-dictsetget) 的 [`DICTSETREF`](#instr-dictsetref) 与 [`DICTGETREF`](#instr-dictgetref) 的组合。 |  |
| **`F41C`** | `DICTISETGET` | _`x i D n - D' y -1或 D' 0`_ | [`DICTISETGET`](#instr-dictisetget)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F41D`** | `DICTISETGETREF` | _`c i D n - D' c' -1或 D' 0`_ | [`DICTISETGETREF`](#instr-dictisetgetref)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F41E`** | `DICTUSETGET` | _`x i D n - D' y -1或 D' 0`_ | [`DICTISETGET`](#instr-dictisetget)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F41F`** | `DICTUSETGETREF` | _`c i D n - D' c' -1或 D' 0`_ | [`DICTISETGETREF`](#instr-dictisetgetref)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F422`** | `DICTREPLACE` | _`x k D n - D' -1或 D 0`_ | 一个 _替换_ 操作，类似于 [`DICTSET`](#instr-dictset)，但只有当键 `k` 已经存在于 `D` 中时才会将 `D` 中键 `k` 的值设置为 `x`。 |  |
| **`F423`** | `DICTREPLACEREF` | _`c k D n - D' -1或 D 0`_ | [`DICTSETREF`](#instr-dictsetref) 的 _替换_ 对应操作。 |  |
| **`F424`** | `DICTIREPLACE` | _`x i D n - D' -1或 D 0`_ | [`DICTREPLACE`](#instr-dictreplace)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F425`** | `DICTIREPLACEREF` | _`c i D n - D' -1或 D 0`_ | [`DICTREPLACEREF`](#instr-dictreplaceref)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F426`** | `DICTUREPLACE` | _`x i D n - D' -1或 D 0`_ | [`DICTREPLACE`](#instr-dictreplace)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F427`** | `DICTUREPLACEREF` | _`c i D n - D' -1或 D 0`_ | [`DICTREPLACEREF`](#instr-dictreplaceref)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F42A`** | `DICTREPLACEGET` | _`x k D n - D' y -1或 D 0`_ | [`DICTSETGET`](#instr-dictsetget) 的 _替换_ 对应操作：成功时，还会返回与该键相关的旧值。 |  |
| **`F42B`** | `DICTREPLACEGETREF` | _`c k D n - D' c' -1或 D 0`_ | [`DICTSETGETREF`](#instr-dictsetgetref) 的 _替换_ 对应操作。 |  |
| **`F42C`** | `DICTIREPLACEGET` | _`x i D n - D' y -1或 D 0`_ | [`DICTREPLACEGET`](#instr-dictreplaceget)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F42D`** | `DICTIREPLACEGETREF` | _`c i D n - D' c' -1或 D 0`_ | [`DICTREPLACEGETREF`](#instr-dictreplacegetref)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F42E`** | `DICTUREPLACEGET` | _`x i D n - D' y -1或 D 0`_ | [`DICTREPLACEGET`](#instr-dictreplaceget)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F42F`** | `DICTUREPLACEGETREF` | _`c i D n - D' c' -1或 D 0`_ | [`DICTREPLACEGETREF`](#instr-dictreplacegetref)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F432`** | `DICTADD` | _`x k D n - D' -1或 D 0`_ | [`DICTSET`](#instr-dictset) 的 _添加_ 对应操作：在字典 `D` 中将与键 `k` 关联的值设置为 `x`，但只有当它还未在 `D` 中存在时。 |  |
| **`F433`** | `DICTADDREF` | _`c k D n - D' -1或 D 0`_ | [`DICTSETREF`](#instr-dictsetref) 的 _添加_ 对应操作。 |  |
| **`F434`** | `DICTIADD` | _`x i D n - D' -1或 D 0`_ | [`DICTADD`](#instr-dictadd)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F435`** | `DICTIADDREF` | _`c i D n - D' -1或 D 0`_ | [`DICTADDREF`](#instr-dictaddref)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F436`** | `DICTUADD` | _`x i D n - D' -1或 D 0`_ | [`DICTADD`](#instr-dictadd)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F437`** | `DICTUADDREF` | _`c i D n - D' -1或 D 0`_ | [`DICTADDREF`](#instr-dictaddref)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F43A`** | `DICTADDGET` | _`x k D n - D' -1或 D y 0`_ | [`DICTSETGET`](#instr-dictsetget) 的 _添加_ 对应操作：在字典 `D` 中将与键 `k` 关联的值设置为 `x`，但只有当键 `k` 还未在 `D` 中存在时。否则，仅返回旧值 `y`，不更改字典。 |  |
| **`F43B`** | `DICTADDGETREF` | _`c k D n - D' -1或 D c' 0`_ | [`DICTSETGETREF`](#instr-dictsetgetref) 的 _添加_ 对应操作。 |  |
| **`F43C`** | `DICTIADDGET` | _`x i D n - D' -1或 D y 0`_ | [`DICTADDGET`](#instr-dictaddget)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F43D`** | `DICTIADDGETREF` | _`c i D n - D' -1或 D c' 0`_ | [`DICTADDGETREF`](#instr-dictaddgetref)，但 `i` 为有符号 `n`-位整数。 |  |
| **`F43E`** | `DICTUADDGET` | _`x i D n - D' -1或 D y 0`_ | [`DICTADDGET`](#instr-dictaddget)，但 `i` 为无符号 `n`-位整数。 |  |
| **`F43F`** | `DICTUADDGETREF` | _`c i D n - D' -1或 D c' 0`_ | [`DICTADDGETREF`](#instr-dictaddgetref)，但 `i` 为无符号 `n`-位整数。 |  |
### 10.5 接受构建器的字典设置操作变体
以下操作接受新值作为_构建器_ `b`，而不是_切片_ `x`。
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F441`** | `DICTSETB` | _`b k D n - D'`_ |  |  |
| **`F442`** | `DICTISETB` | _`b i D n - D'`_ |  |  |
| **`F443`** | `DICTUSETB` | _`b i D n - D'`_ |  |  |
| **`F445`** | `DICTSETGETB` | _`b k D n - D' y -1或 D' 0`_ |  |  |
| **`F446`** | `DICTISETGETB` | _`b i D n - D' y -1或 D' 0`_ |  |  |
| **`F447`** | `DICTUSETGETB` | _`b i D n - D' y -1或 D' 0`_ |  |  |
| **`F449`** | `DICTREPLACEB` | _`b k D n - D' -1或 D 0`_ |  |  |
| **`F44A`** | `DICTIREPLACEB` | _`b i D n - D' -1或 D 0`_ |  |  |
| **`F44B`** | `DICTUREPLACEB` | _`b i D n - D' -1或 D 0`_ |  |  |
| **`F44D`** | `DICTREPLACEGETB` | _`b k D n - D' y -1或 D 0`_ |  |  |
| **`F44E`** | `DICTIREPLACEGETB` | _`b i D n - D' y -1或 D 0`_ |  |  |
| **`F44F`** | `DICTUREPLACEGETB` | _`b i D n - D' y -1或 D 0`_ |  |  |
| **`F451`** | `DICTADDB` | _`b k D n - D' -1或 D 0`_ |  |  |
| **`F452`** | `DICTIADDB` | _`b i D n - D' -1或 D 0`_ |  |  |
| **`F453`** | `DICTUADDB` | _`b i D n - D' -1或 D 0`_ |  |  |
| **`F455`** | `DICTADDGETB` | _`b k D n - D' -1或 D y 0`_ |  |  |
| **`F456`** | `DICTIADDGETB` | _`b i D n - D' -1或 D y 0`_ |  |  |
| **`F457`** | `DICTUADDGETB` | _`b i D n - D' -1或 D y 0`_ |  |  |
### 10.6 删除字典操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F459`** | `DICTDEL` | _`k D n - D' -1或 D 0`_ | 从字典 `D` 中删除由_切片_ `k` 表示的 `n`-位键。如果键存在，返回修改后的字典 `D'` 和成功标志位 `-1`。否则，返回原始字典 `D` 和 `0`。 |  |
| **`F45A`** | `DICTIDEL` | _`i D n - D' ?`_ | [`DICTDEL`](#instr-dictdel) 的一个版本，键由有符号的 `n`-位 _整数_ `i` 表示。如果 `i` 不能放入 `n` 位，简单地返回 `D` `0`（“键未找到，字典未修改”）。 |  |
| **`F45B`** | `DICTUDEL` | _`i D n - D' ?`_ | 类似于 [`DICTIDEL`](#instr-dictidel)，但 `i` 为无符号的 `n`-位整数。 |  |
| **`F462`** | `DICTDELGET` | _`k D n - D' x -1或 D 0`_ | 从字典 `D` 中删除由_切片_ `k` 表示的 `n`-位键。如果键存在，返回修改后的字典 `D'`、与键 `k` 关联的原始值 `x`（由_切片_表示），和成功标志位 `-1`。否则，返回原始字典 `D` 和 `0`。 |  |
| **`F463`** | `DICTDELGETREF` | _`k D n - D' c -1或 D 0`_ | 类似于 [`DICTDELGET`](#instr-dictdelget)，但成功时对 `x` 应用 [`LDREF`](#instr-ldref) [`ENDS`](#instr-ends)，以便返回的值 `c` 是一个_cell_。 |  |
| **`F464`** | `DICTIDELGET` | _`i D n - D' x -1或 D 0`_ | [`DICTDELGET`](#instr-dictdelget)，但 `i` 为有符号的 `n`-位整数。 |  |
| **`F465`** | `DICTIDELGETREF` | _`i D n - D' c -1或 D 0`_ | [`DICTDELGETREF`](#instr-dictdelgetref)，但 `i` 为有符号的 `n`-位整数。 |  |
| **`F466`** | `DICTUDELGET` | _`i D n - D' x -1或 D 0`_ | [`DICTDELGET`](#instr-dictdelget)，但 `i` 为无符号的 `n`-位整数。 |  |
| **`F467`** | `DICTUDELGETREF` | _`i D n - D' c -1或 D 0`_ | [`DICTDELGETREF`](#instr-dictdelgetref)，但 `i` 为无符号的 `n`-位整数。 |  |
### 10.7 “可能是引用”的字典操作
以下操作假设使用字典存储类型为_可能是cell（Maybe Cell）_的值 `c?`。表示如下：如果 `c?` 是一个_cell_，它作为一个没有数据位且恰好有一个对这个_cell_的引用的值存储。如果 `c?` 是_Null_，则对应的键必须从字典中缺失。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F469`** | `DICTGETOPTREF` | _`k D n - c^?`_ | [`DICTGETREF`](#instr-dictgetref) 的一个变体，如果键 `k` 不存在于字典 `D` 中，则返回 _Null_ 而不是值 `c^?`。 |  |
| **`F46A`** | `DICTIGETOPTREF` | _`i D n - c^?`_ | [`DICTGETOPTREF`](#instr-dictgetoptref) 的版本，但 `i` 为有符号的 `n`-位整数。如果键 `i` 超出范围，也返回 _Null_。 |  |
| **`F46B`** | `DICTUGETOPTREF` | _`i D n - c^?`_ | [`DICTGETOPTREF`](#instr-dictgetoptref) 的版本，但 `i` 为无符号的 `n`-位整数。如果键 `i` 超出范围，也返回 _Null_。 |  |
| **`F46D`** | `DICTSETGETOPTREF` | _`c^? k D n - D' ~c^?`_ | [`DICTGETOPTREF`](#instr-dictgetoptref) 和 [`DICTSETGETREF`](#instr-dictsetgetref) 的一个变体，将字典 `D` 中键 `k` 对应的值设置为 `c^?`（如果 `c^?` 是_Null_，则删除该键），并返回旧值 `~c^?`（如果键 `k` 之前缺失，返回_Null_）。 |  |
| **`F46E`** | `DICTISETGETOPTREF` | _`c^? i D n - D' ~c^?`_ | 类似于 [`DICTSETGETOPTREF`](#instr-dictsetgetoptref) 的原语，但使用有符号的 `n`-位 _整数_ `i` 作为键。如果 `i` 不能放入 `n` 位，抛出范围检查异常。 |  |
| **`F46F`** | `DICTUSETGETOPTREF` | _`c^? i D n - D' ~c^?`_ | 类似于 [`DICTSETGETOPTREF`](#instr-dictsetgetoptref) 的原语，但使用无符号的 `n`-位 _整数_ `i` 作为键。 |  |
### 10.8 前缀码字典操作
构建前缀码字典的一些基本操作。
这些原语与它们非前缀码（[`DICTSET`](#instr-dictset) 等）的对应操作完全相同，不过在前缀码字典中，即使是 _Set_ 也可能失败，因此 [`PFXDICTSET`](#instr-pfxdictset) 也必须返回成功标志位。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F470`** | `PFXDICTSET` | _`x k D n - D' -1或 D 0`_ |  |  |
| **`F471`** | `PFXDICTREPLACE` | _`x k D n - D' -1或 D 0`_ |  |  |
| **`F472`** | `PFXDICTADD` | _`x k D n - D' -1或 D 0`_ |  |  |
| **`F473`** | `PFXDICTDEL` | _`k D n - D' -1或 D 0`_ |  |  |
### 10.9 GetNext 和 GetPrev 操作的变体
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F474`** | `DICTGETNEXT` | _`k D n - x' k' -1或 0`_ | 计算字典 `D` 中字典序大于 `k` 的最小键 `k'`，并返回 `k'`（由_切片_表示）及其关联的值 `x'`（也由_切片_表示）。 |  |
| **`F475`** | `DICTGETNEXTEQ` | _`k D n - x' k' -1或 0`_ | 类似于 [`DICTGETNEXT`](#instr-dictgetnext)，但计算字典序大于或等于 `k` 的最小键 `k'`。 |  |
| **`F476`** | `DICTGETPREV` | _`k D n - x' k' -1或 0`_ | 类似于 [`DICTGETNEXT`](#instr-dictgetnext)，但计算字典序小于 `k` 的最大键 `k'`。 |  |
| **`F477`** | `DICTGETPREVEQ` | _`k D n - x' k' -1或 0`_ | 类似于 [`DICTGETPREV`](#instr-dictgetprev)，但计算字典序小于或等于 `k` 的最大键 `k'`。 |  |
| **`F478`** | `DICTIGETNEXT` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETNEXT`](#instr-dictgetnext)，但将字典 `D` 中的所有键解释为大端有符号的 `n`-位整数，并计算大于整数 `i` 的最小键 `i'`（`i` 不一定能放入 `n` 位）。 |  |
| **`F479`** | `DICTIGETNEXTEQ` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETNEXTEQ`](#instr-dictgetnexteq)，但将键解释为有符号的 `n`-位整数。 |  |
| **`F47A`** | `DICTIGETPREV` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETPREV`](#instr-dictgetprev)，但将键解释为有符号的 `n`-位整数。 |  |
| **`F47B`** | `DICTIGETPREVEQ` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETPREVEQ`](#instr-dictgetpreveq)，但将键解释为有符号的 `n`-位整数。 |  |
| **`F47C`** | `DICTUGETNEXT` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETNEXT`](#instr-dictgetnext)，但将字典 `D` 中的所有键解释为大端无符号的 `n`-位整数，并计算大于整数 `i` 的最小键 `i'`（`i` 不一定能放入 `n` 位，也不一定是非负的）。 |  |
| **`F47D`** | `DICTUGETNEXTEQ` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETNEXTEQ`](#instr-dictgetnexteq)，但将键解释为无符号的 `n`-位整数。 |  |
| **`F47E`** | `DICTUGETPREV` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETPREV`](#instr-dictgetprev)，但将键解释为无符号的 `n`-位整数。 |  |
| **`F47F`** | `DICTUGETPREVEQ` | _`i D n - x' i' -1或 0`_ | 类似于 [`DICTGETPREVEQ`](#instr-dictgetpreveq)，但将键解释为无符号的 `n`-位整数。 |  |
### 10.10 GetMin, GetMax, RemoveMin, RemoveMax 操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F482`** | `DICTMIN` | _`D n - x k -1或 0`_ | 计算字典 `D` 中的最小键 `k`（由拥有 `n` 数据位的_切片_表示），并返回 `k` 及其关联的值 `x`。 |  |
| **`F483`** | `DICTMINREF` | _`D n - c k -1或 0`_ | 类似于 [`DICTMIN`](#instr-dictmin)，但返回值中唯一的引用作为_cell_ `c`。 |  |
| **`F484`** | `DICTIMIN` | _`D n - x i -1或 0`_ | 类似于 [`DICTMIN`](#instr-dictmin)，但在假设所有键为大端有符号的 `n`-位整数的情况下计算最小键 `i`。注意，返回的键和值可能与 [`DICTMIN`](#instr-dictmin) 和 [`DICTUMIN`](#instr-dictumin) 计算出的不同。 |  |
| **`F485`** | `DICTIMINREF` | _`D n - c i -1或 0`_ | 类似于 [`DICTIMIN`](#instr-dictimin)，但返回值中唯一的引用。 |  |
| **`F486`** | `DICTUMIN` | _`D n - x i -1或 0`_ | 类似于 [`DICTMIN`](#instr-dictmin)，但以无符号 `n`-位 _整数_ `i` 的形式返回键。 |  |
| **`F487`** | `DICTUMINREF` | _`D n - c i -1或 0`_ | 类似于 [`DICTUMIN`](#instr-dictumin)，但返回值中唯一的引用。 |  |
| **`F48A`** | `DICTMAX` | _`D n - x k -1或 0`_ | 计算字典 `D` 中的最大键 `k`（由拥有 `n` 数据位的_切片_表示），并返回 `k` 及其关联的值 `x`。 |  |
| **`F48B`** | `DICTMAXREF` | _`D n - c k -1或 0`_ | 类似于 [`DICTMAX`](#instr-dictmax)，但返回值中唯一的引用。 |  |
| **`F48C`** | `DICTIMAX` | _`D n - x i -1或 0`_ | 类似于 [`DICTMAX`](#instr-dictmax)，但在假设所有键为大端有符号的 `n`-位整数的情况下计算最大键 `i`。注意，返回的键和值可能与 [`DICTMAX`](#instr-dictmax) 和 [`DICTUMAX`](#instr-dictumax) 计算出的不同。 |  |
| **`F48D`** | `DICTIMAXREF` | _`D n - c i -1或 0`_ | 类似于 [`DICTIMAX`](#instr-dictimax)，但返回值中唯一的引用。 |  |
| **`F48E`** | `DICTUMAX` | _`D n - x i -1或 0`_ | 类似于 [`DICTMAX`](#instr-dictmax)，但以无符号 `n`-位 _整数_ `i` 的形式返回键。 |  |
| **`F48F`** | `DICTUMAXREF` | _`D n - c i -1或 0`_ | 类似于 [`DICTUMAX`](#instr-dictumax)，但返回值中唯一的引用。 |  |
| **`F492`** | `DICTREMMIN` | _`D n - D' x k -1或D 0`_ | 计算字典 `D` 中的最小键 `k`（以_n_数据位的_切片_形式表示），从字典中移除 `k`，并返回 `k` 及其关联的值 `x` 和修改后的字典 `D'`。 |  |
| **`F493`** | `DICTREMMINREF` | _`D n - D' c k -1或D 0`_ | 类似于 [`DICTREMMIN`](#instr-dictremmin)，但返回值中唯一的引用作为_cell_ `c`。 |  |
| **`F494`** | `DICTIREMMIN` | _`D n - D' x i -1或D 0`_ | 类似于 [`DICTREMMIN`](#instr-dictremmin)，但计算最小键 `i`，假设所有键都是大端有符号的_n_-位整数。请注意，返回的键和值可能与[`DICTREMMIN`](#instr-dictremmin) 和 [`DICTUREMMIN`](#instr-dicturemmin)计算的不同。 |  |
| **`F495`** | `DICTIREMMINREF` | _`D n - D' c i -1或D 0`_ | 类似于 [`DICTIREMMIN`](#instr-dictiremmin)，但返回值中唯一的引用。 |  |
| **`F496`** | `DICTUREMMIN` | _`D n - D' x i -1或D 0`_ | 类似于 [`DICTREMMIN`](#instr-dictremmin)，但以无符号_n_-位_整数_ `i` 形式返回键。 |  |
| **`F497`** | `DICTUREMMINREF` | _`D n - D' c i -1或D 0`_ | 类似于 [`DICTUREMMIN`](#instr-dicturemmin)，但返回值中唯一的引用。 |  |
| **`F49A`** | `DICTREMMAX` | _`D n - D' x k -1或D 0`_ | 计算字典 `D` 中的最大键 `k`（以_n_数据位的_切片_形式表示），从字典中移除 `k`，并返回 `k` 及其关联的值 `x` 和修改后的字典 `D'`。 |  |
| **`F49B`** | `DICTREMMAXREF` | _`D n - D' c k -1或D 0`_ | 类似于 [`DICTREMMAX`](#instr-dictremmax)，但返回值中唯一的引用作为_cell_ `c`。 |  |
| **`F49C`** | `DICTIREMMAX` | _`D n - D' x i -1或D 0`_ | 类似于 [`DICTREMMAX`](#instr-dictremmax)，但计算最大键 `i`，假设所有键都是大端有符号的_n_-位整数。请注意，返回的键和值可能与[`DICTREMMAX`](#instr-dictremmax) 和 [`DICTUREMMAX`](#instr-dicturemmax)计算的不同。 |  |
| **`F49D`** | `DICTIREMMAXREF` | _`D n - D' c i -1或D 0`_ | 类似于 [`DICTIREMMAX`](#instr-dictiremmax)，但返回值中唯一的引用。 |  |
| **`F49E`** | `DICTUREMMAX` | _`D n - D' x i -1或D 0`_ | 类似于 [`DICTREMMAX`](#instr-dictremmax)，但以无符号_n_-位_整数_ `i` 形式返回键。 |  |
| **`F49F`** | `DICTUREMMAXREF` | _`D n - D' c i -1或D 0`_ | 类似于 [`DICTUREMMAX`](#instr-dicturemmax)，但返回值中唯一的引用。 |  |
### 10.11 特殊的获取字典和前缀码字典操作以及常量字典
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F4A0`** | `DICTIGETJMP` | _`i D n - `_ | 类似于 [`DICTIGET`](#instr-dictiget)，但在成功时将 `x` [`BLESS`](#instr-bless) 成一个continuation，并随后执行对其的 [`JMPX`](#instr-jmpx)。失败时不执行任何操作。这对于实现 `switch`/`case` 结构很有用。 |  |
| **`F4A1`** | `DICTUGETJMP` | _`i D n - `_ | 类似于 [`DICTIGETJMP`](#instr-dictigetjmp)，但执行 [`DICTUGET`](#instr-dictuget) 而非 [`DICTIGET`](#instr-dictiget)。 |  |
| **`F4A2`** | `DICTIGETEXEC` | _`i D n - `_ | 类似于 [`DICTIGETJMP`](#instr-dictigetjmp)，但使用 [`EXECUTE`](#instr-execute) 而非 [`JMPX`](#instr-jmpx)。 |  |
| **`F4A3`** | `DICTUGETEXEC` | _`i D n - `_ | 类似于 [`DICTUGETJMP`](#instr-dictugetjmp)，但使用 [`EXECUTE`](#instr-execute) 而非 [`JMPX`](#instr-jmpx)。 |  |
| **`F4A6_n`** | `[ref] [n] DICTPUSHCONST` | _` - D n`_ | 推送非空常量字典 `D`（作为`Cell^?`）和其键长 `0 <= n <= 1023`，存储为指令的一部分。字典本身是从当前continuation的剩余引用中的第一个创建的。通过这种方式，完整的 [`DICTPUSHCONST`](#instr-dictpushconst) 指令可以通过首先序列化 `xF4A4_`，然后是非空字典本身（一个 `1` 位和一个cell引用），然后是无符号的 10 位整数 `n`（仿佛通过 `STU 10` 指令）获得。空字典可以通过 [`NEWDICT`](#instr-newdict) 原语推送。 | `34` |
| **`F4A8`** | `PFXDICTGETQ` | _`s D n - s' x s'' -1或s 0`_ | 在前缀码字典中查找切片 `s` 的唯一前缀，该字典由 `Cell^?` `D` 和 `0 <= n <= 1023` 表示。如果找到，作为 `s'` 返回 `s` 的前缀，并作为切片 `x` 返回相应的值。`s` 的剩余部分作为切片 `s''` 返回。如果 `s` 的任何前缀不是前缀码字典 `D` 中的键，则返回未更改的 `s` 和零标志位以表示失败。 |  |
| **`F4A9`** | `PFXDICTGET` | _`s D n - s' x s''`_ | 类似于 [`PFXDICTGET`](#instr-pfxdictget)，但在失败时抛出cell反序列化失败异常。 |  |
| **`F4AA`** | `PFXDICTGETJMP` | _`s D n - s' s''或s`_ | 类似于 [`PFXDICTGETQ`](#instr-pfxdictgetq)，但成功时将值 `x` [`BLESS`](#instr-bless) 成一个_continuation_，并像执行 [`JMPX`](#instr-jmpx) 一样转移控制权。失败时，返回未改变的 `s` 并继续执行。 |  |
| **`F4AB`** | `PFXDICTGETEXEC` | _`s D n - s' s''`_ | 类似于 [`PFXDICTGETJMP`](#instr-pfxdictgetjmp)，但执行找到的continuation而非跳转它。失败时，抛出cell反序列化异常。 |  |
| **`F4AE_n`** | `[ref] [n] PFXDICTCONSTGETJMP`<br/>`[ref] [n] PFXDICTSWITCH` | _`s - s' s''或s`_ | 将 [`[n] DICTPUSHCONST`](#instr-dictpushconst) 和 [`PFXDICTGETJMP`](#instr-pfxdictgetjmp) 结合起来，用于 `0 <= n <= 1023`。 |  |
| **`F4BC`** | `DICTIGETJMPZ` | _`i D n - i或nothing`_ | [`DICTIGETJMP`](#instr-dictigetjmp) 的一个变种，在失败时返回索引 `i`。 |  |
| **`F4BD`** | `DICTUGETJMPZ` | _`i D n - i或nothing`_ | [`DICTUGETJMP`](#instr-dictugetjmp) 的一个变种，在失败时返回索引 `i`。 |  |
| **`F4BE`** | `DICTIGETEXECZ` | _`i D n - i或nothing`_ | [`DICTIGETEXEC`](#instr-dictigetexec) 的一个变种，在失败时返回索引 `i`。 |  |
| **`F4BF`** | `DICTUGETEXECZ` | _`i D n - i或nothing`_ | [`DICTUGETEXEC`](#instr-dictugetexec) 的一个变种，在失败时返回索引 `i`。 |  |
### 10.12 SubDict 字典操作
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F4B1`** | `SUBDICTGET` | _`k l D n - D'`_ | 构建一个由所有以前缀 `k`（由一个_切片_表示，其前 `0 <= l <= n <= 1023` 个数据位用作键）为前缀的字典 `D` 中的键组成的子字典。这里的 `D` 是类型为 `HashmapE(n,X)` 的字典，拥有 `n` 位的键。成功时，返回同类型 `HashmapE(n,X)` 的新子字典作为一个_切片_ `D'`。 |  |
| **`F4B2`** | `SUBDICTIGET` | _`x l D n - D'`_ | [`SUBDICTGET`](#instr-subdictget) 的变体，前缀由有符号的大端 `l`-位_整数_ `x` 表示，必须满足 `l <= 257`。 |  |
| **`F4B3`** | `SUBDICTUGET` | _`x l D n - D'`_ | [`SUBDICTGET`](#instr-subdictget) 的变体，前缀由无符号的大端 `l`-位_整数_ `x` 表示，必须满足 `l <= 256`。 |  |
| **`F4B5`** | `SUBDICTRPGET` | _`k l D n - D'`_ | 类似于 [`SUBDICTGET`](#instr-subdictget)，但从新字典 `D'` 的所有键中移除公共前缀 `k`，它变为 `HashmapE(n-l,X)` 类型。 |  |
| **`F4B6`** | `SUBDICTIRPGET` | _`x l D n - D'`_ | [`SUBDICTRPGET`](#instr-subdictrpget) 的变体，前缀由有符号的大端 `l`-位_整数_ `x` 表示，必须满足 `l <= 257`。 |  |
| **`F4B7`** | `SUBDICTURPGET` | _`x l D n - D'`_ | [`SUBDICTRPGET`](#instr-subdictrpget) 的变体，前缀由无符号的大端 `l`-位_整数_ `x` 表示，必须满足 `l <= 256`。 |  |

## 11 应用特定原语
### 11.1 与 Gas 相关的原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F800`** | `ACCEPT` | _`-`_ | 将当前的 Gas 限制 `g_l` 设置为其允许的最大值 `g_m`，并将 Gas 信用 `g_c` 重置为零，同时减少 `g_r` 的值 `g_c`。<br/>换句话说，当前的智能合约同意购买一些 Gas 以完成当前交易。此操作是处理外部消息所必需的，这些消息本身不携带价值（因而没有 Gas）。 | `26` |
| **`F801`** | `SETGASLIMIT` | _`g - `_ | 将当前的 Gas 限制 `g_l` 设置为 `g` 与 `g_m` 的最小值，并将 Gas 信用 `g_c` 重置为零。如果到目前为止所消耗的 Gas（包括当前指令）超过了所得的 `g_l` 值，则在设置新的 Gas 限制之前抛出（未处理的）Gas 超限异常。请注意，带有参数 `g >= 2^63-1` 的 [`SETGASLIMIT`](#instr-setgaslimit) 等同于 [`ACCEPT`](#instr-accept)。 | `26` |
| **`F80F`** | `COMMIT` | _`-`_ | 提交寄存器 `c4`（“持久数据”）和 `c5`（“操作”）的当前状态，以便即使后来抛出异常，当前执行也被视为“成功”，并保存了这些值。 | `26` |
### 11.2 伪随机数生成器原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F810`** | `RANDU256` | _`- x`_ | 生成一个新的伪随机的无符号 256 位 _整数_ `x`。算法如下: 如果 `r` 是旧的随机种子值，被视为一个 32 字节的数组（通过构造一个无符号 256 位整数的大端表示），则计算其 `sha512(r)`；这个哈希的前 32 字节被存储为新的随机种子值 `r'`，剩下的 32 字节作为下一个随机值 `x` 返回。 | `26+\|c7\|+\|c1_1\|` |
| **`F811`** | `RAND` | _`y - z`_ | 在 `0...y-1`（或 `y...-1`, 如果 `y<0`）范围内生成一个新的伪随机整数 `z`。更确切地说，生成一个无符号随机值 `x`，如同在 `RAND256U` 中；然后计算 `z:=floor(x*y/2^256)`。<br/>等同于 [`RANDU256`](#instr-randu256) [`256 MULRSHIFT`](#instr-mulrshift-var). | `26+\|c7\|+\|c1_1\|` |
| **`F814`** | `SETRAND` | _`x - `_ | 将随机种子设置为无符号 256 位 _整数_ `x`。 | `26+\|c7\|+\|c1_1\|` |
| **`F815`** | `ADDRAND`<br/>`RANDOMIZE` | _`x - `_ | 将无符号 256 位 _整数_ `x` 混入随机种子 `r` 中，通过将随机种子设为两个 32 字节字符串的连结的 `Sha`，第一个字符串以旧种子 `r` 的大端表示，第二个字符串以 `x` 的大端表示。 | `26` |
### 11.3 配置原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F82i`** | `[i] GETPARAM` | _` - x`_ | 从提供于 `c7` 的 _元组_ 中返回第 `i` 个参数，对于 `0 <= i <= 15`。等同于 [`c7 PUSHCTR`](#instr-pushctr) [`FIRST`](#instr-first) [`[i] INDEX`](#instr-index).<br/>如果这些内部操作之一失败，则抛出相应的类型检查或范围检查异常。 | `26` |
| **`F823`** | `NOW` | _` - x`_ | 返回当前 Unix 时间作为一个 _整数_。如果从 `c7` 开始无法恢复请求的值，则抛出类型检查或范围检查异常。<br/>等同于 [`3 GETPARAM`](#instr-getparam). | `26` |
| **`F824`** | `BLOCKLT` | _` - x`_ | 返回当前区块的开始逻辑时间。<br/>等同于 [`4 GETPARAM`](#instr-getparam). | `26` |
| **`F825`** | `LTIME` | _` - x`_ | 返回当前交易的逻辑时间。<br/>等同于 [`5 GETPARAM`](#instr-getparam). | `26` |
| **`F826`** | `RANDSEED` | _` - x`_ | 以无符号 256 位 _整数_ 的形式返回当前的随机种子。<br/>等同于 [`6 GETPARAM`](#instr-getparam). | `26` |
| **`F827`** | `BALANCE` | _` - t`_ | 以 _元组_ 形式返回智能合约剩余的余额，_元组_ 包含一个 _整数_（剩余的Gram余额，以nanograms为单位）和一个 _可能的cell_（以 32 位键表示的“额外代币”的余额字典）。<br/>等同于 [`7 GETPARAM`](#instr-getparam).<br/>请注意，如 [`SENDRAWMSG`](#instr-sendrawmsg) 等 `RAW` 原语不会更新此字段。 | `26` |
| **`F828`** | `MYADDR` | _` - s`_ | 以 _分片_ 形式返回当前智能合约的内部地址，包含一个 `MsgAddressInt`。如果必要，可以使用诸如 [`PARSEMSGADDR`](#instr-parsemsgaddr) 或 [`REWRITESTDADDR`](#instr-rewritestdaddr) 之类的原语进一步解析它。<br/>等同于 [`8 GETPARAM`](#instr-getparam). | `26` |
| **`F829`** | `CONFIGROOT` | _` - D`_ | 以 _可能的cell_ `D` 形式返回当前全局配置字典。等同于 `9 GETPARAM `。 | `26` |
| **`F830`** | `CONFIGDICT` | _` - D 32`_ | 返回全局配置字典及其键长（32）。<br/>等同于 [`CONFIGROOT`](#instr-configroot) [`32 PUSHINT`](#instr-pushint-4). | `26` |
| **`F832`** | `CONFIGPARAM` | _`i - c -1 或 0`_ | 以 _cell_ `c` 的形式返回整数索引 `i` 的全局配置参数的值，以及指示成功的标志位。<br/>等同于 [`CONFIGDICT`](#instr-configdict) [`DICTIGETREF`](#instr-dictigetref). |  |
| **`F833`** | `CONFIGOPTPARAM` | _`i - c^?`_ | 以 _可能的cell_ `c^?` 的形式返回整数索引 `i` 的全局配置参数的值。<br/>等同于 [`CONFIGDICT`](#instr-configdict) [`DICTIGETOPTREF`](#instr-dictigetoptref). |  |
### 11.4 全局变量原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F840`** | `GETGLOBVAR` | _`k - x`_ | 返回第 `k` 个全局变量，对于 `0 <= k < 255`。<br/>相当于 [`c7 PUSHCTR`](#instr-pushctr) [`SWAP`](#instr-swap) [`INDEXVARQ`](#instr-indexvarq)。 | `26` |
| **`F85_k`** | `[k] GETGLOB` | _` - x`_ | 返回第 `k` 个全局变量，对于 `1 <= k <= 31`。<br/>相当于 [`c7 PUSHCTR`](#instr-pushctr) [`[k] INDEXQ`](#instr-indexq)。 | `26` |
| **`F860`** | `SETGLOBVAR` | _`x k - `_ | 将 `x` 分配给第 `k` 个全局变量，对于 `0 <= k < 255`。<br/>相当于 [`c7 PUSHCTR`](#instr-pushctr) [`ROTREV`](#instr-rotrev) [`SETINDEXVARQ`](#instr-setindexvarq) [`c7 POPCTR`](#instr-popctr)。 | `26+\|c7’\|` |
| **`F87_k`** | `[k] SETGLOB` | _`x - `_ | 将 `x` 分配给第 `k` 个全局变量，对于 `1 <= k <= 31`。<br/>相当于 [`c7 PUSHCTR`](#instr-pushctr) [`SWAP`](#instr-swap) [`k SETINDEXQ`](#instr-setindexq) [`c7 POPCTR`](#instr-popctr)。 | `26+\|c7’\|` |
### 11.5 哈希和密码学原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F900`** | `HASHCU` | _`c - x`_ | 计算 _cell_ `c` 的表示哈希，并将其作为 256 位无符号整数 `x` 返回。用于对由cell树表示的任意实体进行签名和检查签名。 | `26` |
| **`F901`** | `HASHSU` | _`s - x`_ | 计算 _分片_ `s` 的哈希，并将其作为 256 位无符号整数 `x` 返回。结果与如果创建了一个仅包含 `s` 的数据和引用的普通cell并通过 [`HASHCU`](#instr-hashcu) 计算其哈希相同。 | `526` |
| **`F902`** | `SHA256U` | _`s - x`_ | 对 _分片_ `s` 的数据位计算 `Sha`。如果 `s` 的位长度不能被八整除，抛出一个cell下溢异常。哈希值作为 256 位无符号整数 `x` 返回。 | `26` |
| **`F910`** | `CHKSIGNU` | _`h s k - ?`_ | 使用公钥 `k`（也用一个 256 位无符号整数表示）检查哈希 `h`（通常作为某些数据的哈希，为一个 256 位无符号整数）的 Ed25519 签名 `s`。<br/>签名 `s` 必须是至少包含 512 位数据的 _分片_；仅使用前 512 位。结果为 `-1` 则签名有效，否则为 `0`。<br/>请注意，[`CHKSIGNU`](#instr-chksignu) 相当于 [`ROT`](#instr-rot) [`NEWC`](#instr-newc) [`256 STU`](#instr-stu) [`ENDC`](#instr-endc) [`ROTREV`](#instr-rotrev) [`CHKSIGNS`](#instr-chksigns)，即，相当于用第一个参数 `d` 设置为包含 `h` 的 256 位 _分片_ 的 [`CHKSIGNS`](#instr-chksigns)。因此，如果 `h` 是作为某些数据的哈希计算的，这些数据会被 _两次_ 哈希，第二次哈希发生在 [`CHKSIGNS`](#instr-chksigns) 内部。 | `26` |
| **`F911`** | `CHKSIGNS` | _`d s k - ?`_ | 检查 `s` 是否是使用公钥 `k` 对 _分片_ `d` 的数据部分的有效 Ed25519 签名，类似于 [`CHKSIGNU`](#instr-chksignu)。如果 _分片_ `d` 的位长度不能被八整除，抛出一个cell下溢异常。Ed25519 签名的验证是标准的，使用 `Sha` 将 `d` 缩减为实际签名的 256 位数字。 | `26` |
### 11.6 其他原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`F940`** | `CDATASIZEQ` | _`c n - x y z -1 或 0`_ | 递归计算以 _cell_ `c` 为根的 dag 中不同cell `x`、数据位 `y` 和cell引用 `z` 的计数，有效地返回考虑等价cell标识时该 dag 使用的总存储量。`x`、`y` 和 `z` 的值通过该 dag 的深度优先遍历来计算，使用访问过的cell哈希表来防止已访问cell的重复访问。访问的cell总数 `x` 不能超过非负 _整数_ `n`；否则，在访问第 `(n+1)` 个cell之前计算被中断，并返回零表示失败。如果 `c` 为 _空_，则返回 `x=y=z=0`。 |  |
| **`F941`** | `CDATASIZE` | _`c n - x y z`_ | [`CDATASIZEQ`](#instr-cdatasizeq) 的非静默版本，失败时抛出cell溢出异常（8）。 |  |
| **`F942`** | `SDATASIZEQ` | _`s n - x y z -1 或 0`_ | 类似于 [`CDATASIZEQ`](#instr-cdatasizeq)，但接受一个 _分片_ `s` 而非 _cell_。返回的 `x` 值不包括包含切片 `s` 本身的cell；然而，`s` 的数据位和cell引用在 `y` 和 `z` 中被计算在内。 |  |
| **`F943`** | `SDATASIZE` | _`s n - x y z`_ | [`SDATASIZEQ`](#instr-sdatasizeq) 的非静默版本，失败时抛出cell溢出异常（8）。 |  |
### 11.7 代币操作原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`FA00`** | `LDGRAMS`<br/>`LDVARUINT16` | _`s - x s'`_ | 从 _分片_ `s` 中加载（反序列化）一个 `Gram` 或 `VarUInteger 16` 数量，并以 _整数_ `x` 形式返回数量及 `s` 的剩余部分 `s'`。`x` 的预期序列化格式包括一个 4 位无符号大端整数 `l`，随后是 `x` 的一个 `8l` 位无符号大端表示。<br/>其效果大致等同于 [`4 LDU`](#instr-ldu) [`SWAP`](#instr-swap) [`3 LSHIFT#`](#instr-lshift) [`LDUX`](#instr-ldux)。 | `26` |
| **`FA01`** | `LDVARINT16` | _`s - x s'`_ | 与 [`LDVARUINT16`](#instr-ldgrams) 相似，但加载一个 _有符号_ _整数_ `x`。<br/>大致等同于 [`4 LDU`](#instr-ldu) [`SWAP`](#instr-swap) [`3 LSHIFT#`](#instr-lshift) [`LDIX`](#instr-ldix)。 | `26` |
| **`FA02`** | `STGRAMS`<br/>`STVARUINT16` | _`b x - b'`_ | 将范围为 `0...2^120-1` 内的 _整数_ `x` 存储（序列化）到 _构建器_ `b` 中，并返回 _构建器_ `b'`的结果。`x` 的序列化格式包括一个 4 位无符号大端整数 `l`，这是满足 `x<2^(8l)` 的最小的 `l>=0` 整数，随后是 `x` 的一个 `8l` 位无符号大端表示。如果 `x` 不在支持的范围内，则抛出范围检查异常。 | `26` |
| **`FA03`** | `STVARINT16` | _`b x - b'`_ | 类似于 [`STVARUINT16`](#instr-stgrams)，但序列化一个范围为 `-2^119...2^119-1` 的 _有符号_ _整数_ `x`。 | `26` |
### 11.8 消息和地址操作原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`FA40`** | `LDMSGADDR` | _`s - s' s''`_ | 从 _分片_ `s` 中加载唯一有效的 `MsgAddress` 前缀，并将该前缀 `s'` 和 `s` 的剩余部分 `s''` 作为分片返回。 | `26` |
| **`FA41`** | `LDMSGADDRQ` | _`s - s' s'' -1 或 s 0`_ | [`LDMSGADDR`](#instr-ldmsgaddr) 的静默版本：成功时额外推送 `-1`；失败时推送原始 `s` 和零。 | `26` |
| **`FA42`** | `PARSEMSGADDR` | _`s - t`_ | 将包含有效 `MsgAddress` 的 _分片_ `s` 分解为一个具有此 `MsgAddress` 独立字段的 _元组_ `t`。如果 `s` 不是有效的 `MsgAddress`，则抛出cell反序列化异常。 | `26` |
| **`FA43`** | `PARSEMSGADDRQ` | _`s - t -1 或 0`_ | [`PARSEMSGADDR`](#instr-parsemsgaddr) 的静默版本：错误时返回零而不是抛出异常。 | `26` |
| **`FA44`** | `REWRITESTDADDR` | _`s - x y`_ | 解析包含有效 `MsgAddressInt`（通常是 `msg_addr_std`）的 _分片_ `s`，应用从 `anycast`（如果存在）到地址的相同长度前缀的重写，并以整数形式返回工作链 `x` 和 256 位地址 `y`。如果地址不是 256 位的，或者如果 `s` 不是有效的 `MsgAddressInt` 序列化，则抛出cell反序列化异常。 | `26` |
| **`FA45`** | `REWRITESTDADDRQ` | _`s - x y -1 或 0`_ | 原语 [`REWRITESTDADDR`](#instr-rewritestdaddr) 的静默版本。 | `26` |
| **`FA46`** | `REWRITEVARADDR` | _`s - x s'`_ | [`REWRITESTDADDR`](#instr-rewritestdaddr) 的变体，即使地址不是完全为 256 位长（由 `msg_addr_var` 表示），也返回（重写的）地址作为 _分片_ `s`。 | `26` |
| **`FA47`** | `REWRITEVARADDRQ` | _`s - x s' -1 或 0`_ | 原语 [`REWRITEVARADDR`](#instr-rewritevaraddr) 的静默版本。 | `26` |
### 11.9 出站消息和输出操作原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`FB00`** | `SENDRAWMSG` | _`c x - `_ | 发送包含在 _cell_ `c` 中的原始消息，其中应包含正确序列化的对象 `Message X`，唯一的例外是源地址允许有虚拟值 `addr_none`（将自动替换为当前智能合约地址），且 `ihr_fee`、`fwd_fee`、`created_lt` 和 `created_at` 字段可以有任意值（在当前交易的操作阶段将被正确值重写）。整数参数 `x` 包含标志位。当前 `x=0` 用于普通消息；`x=128` 用于携带当前智能合约所有剩余余额的消息（而非消息最初指示的值）；`x=64` 用于携带除初始指示的新消息值外，入站消息的所有剩余值的消息（如果未设置位 0，则此金额中扣除 gas 费用）；`x'=x+1` 表示发送者想要单独支付转账费用；`x'=x+2` 表示在操作阶段处理此消息时发生的任何错误都应被忽略。最后，`x'=x+32` 意味着如果当前账户的最终余额为零，则必须销毁该账户。这个标志位通常与 `+128` 一起使用。 | `526` |
| **`FB02`** | `RAWRESERVE` | _`x y - `_ | 创建一个输出操作，该操作将从账户的剩余余额中准确预留 `x` nanograms（如果 `y=0`），最多 `x` nanograms（如果 `y=2`），或除 `x` nanograms外的所有nanograms（如果 `y=1` 或 `y=3`）。这大致相当于创建一个携带 `x` nanograms（或 `b-x` nanograms，其中 `b` 是剩余余额）到自己的出站消息，以便后续输出操作无法花费超过剩余金额的资金。`y` 中的位 `+2` 表明，如果无法预留指定金额，外部操作不会失败；相反，将预留所有剩余余额。`y` 中的位 `+8` 表示在执行任何进一步操作之前 `x:=-x`。`y` 中的位 `+4` 表示在执行任何其他检查和操作之前，`x` 会增加当前帐户（在计算阶段之前）的原始余额，包括所有额外货币。当前 `x` 必须是非负整数，且 `y` 必须在 `0...15` 范围内。 | `526` |
| **`FB03`** | `RAWRESERVEX` | _`x D y - `_ | 类似于 [`RAWRESERVE`](#instr-rawreserve)，但也接受一个代表额外代币的字典 `D`（由 _cell_ 或 _空_ 表示）。这种方式可以预留Grams以外的货币。 | `526` |
| **`FB04`** | `SETCODE` | _`c - `_ | 创建一个输出操作，该操作将此智能合约代码更改为由 _cell_ `c` 给出的代码。请注意，此更改仅在当前智能合约运行成功终止后生效。 | `526` |
| **`FB06`** | `SETLIBCODE` | _`c x - `_ | 创建一个输出操作，用于修改此智能合约库的集合，通过添加或移除在 _cell_ `c` 中给定代码的库。如果 `x=0`，若库先前存在于集合中，则实际上会被移除（如果不存在，则此操作无效）。如果 `x=1`，则库被作为私有库添加；如果 `x=2`，则库被作为公共库添加（如果当前智能合约位于主链中，则变得对所有智能合约可用）；如果库之前已存在于集合中，则其公共/私有状态将根据 `x` 改变。另外，`16` 可以加到 `x` 上，以在失败时启用弹回交易。`x` 的值除了 `0...2 (+16 可能)` 之外都是无效的。 | `526` |
| **`FB07`** | `CHANGELIB` | _`h x - `_ | 类似于 [`SETLIBCODE`](#instr-setlibcode)，创建一个输出操作，但它接受库的哈希而非库代码，哈希以无符号 256 位整数 `h` 的形式给出。如果 `x!=0` 且该智能合约的库集合中不存在哈希值为 `h` 的库，此输出操作将失败。 | `526` |

## 12 调试原语
以 `FE` 开头的操作码保留给调试原语使用。这些原语具有已知的固定操作长度，并且作为（多字节）[`NOP`](#instr-nop) 操作行为。

然而，当在启用调试模式的 TVM 实例中调用时，这些原语可以产生特定输出到 TVM 实例的文本调试日志中，不影响 TVM 状态。

[`DEBUG`](#instr-debug) 和 [`DEBUGSTR`](#instr-debugstr) 是两个调试原语，它们涵盖了所有以 `FE` 开头的操作码。当调试启用时，这里列出的其他原语具有其指定的效果。当调试禁用时，它们表现为 [`NOP`](#instr-nop)。

| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`FEnn`** | `{nn} DEBUG` | _`-`_ | `0 <= nn < 240` | `26` |
| **`FEFnssss`** | `{string} DEBUGSTR`<br/>`{string} {x} DEBUGSTRI` | _`-`_ | `0 <= n < 16`。`ssss` 的长度为 `n+1` 字节。<br/>`{string}` 是一个[字符串字面量](https://github.com/Piterden/TON-docs/blob/master/Fift.%20A%20Brief%20Introduction.md#user-content-29-string-literals)。<br/>[`DEBUGSTR`](#instr-debugstr): `ssss` 是给定的字符串。<br/>[`DEBUGSTRI`](#instr-debugstr): `ssss` 是由一个字节的整数 `0 <= x <= 255` 加上给定字符串组成。| `26` |
| **`FE00`** | `DUMPSTK` | _`-`_ | 转储堆栈（最多顶部 255 个值）并显示总堆栈深度。 | `26` |
| **`FE2i`** | `s[i] DUMP` | _`-`_ | 转储 `s[i]`。| `26` |

## 13 代码页原语
| xxxxxxx<br/>操作码 | xxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Fift 语法 | xxxxxxxxxxxxxxxxx<br/>堆栈 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>描述 | xxxx<br/>Gas |
|:-|:-|:-|:-|:-|
| **`FFnn`** | `[nn] SETCP` | _`-`_ | 选择 TVM 代码页 `0 <= nn < 240`。如果不支持代码页，则抛出无效的操作码异常。| `26` |
| **`FF00`** | `SETCP0` | _`-`_ | 选择本文档描述的 TVM（测试）代码页零。| `26` |
| **`FFFz`** | `[z-16] SETCP` | _`-`_ | 选择 TVM 代码页 `z-16`，适用于 `1 <= z <= 15`。负代码页 `-13...-1` 保留用于验证其他代码页中 TVM 运行所需的限制性 TVM 版本。负代码页 `-14` 保留用于实验性代码页，不一定在不同 TVM 实现之间兼容，并且应在 TVM 的生产版本中禁用。 | `26` |
| **`FFF0`** | `SETCPX` | _`c - `_ | 选择通过栈顶传入的代码页 `c`，`-2^15 <= c < 2^15`。 | `26` |

## 参阅

- [TVM 概览](/learn/tvm-instructions/tvm-overview)
- [TVM 指令](/learn/tvm-instructions/instructions)
- [TON TVM](https://ton.org/tvm.pdf) TVM 概念（可能包含过时信息）