import Feedback from '@site/src/components/Feedback';

# Tolk vs FunC: in detail

A huge list is below. Will anyone have enough patience to read it up to the end?..

:::tip コンパクト版があります
こちら:  [Tolk vs FunC: 簡潔版](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)
:::

<h3 className="cmp-func-tolk-header">
  ✅ 従来のコメント :)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{';; comment'}</code></td>
    <td><code>{'// comment'}</code></td>
  </tr>
  <tr>
    <td><code>{'{- multiline comment -}'}</code></td>
    <td><code>{'/* multiline comment */'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ Structures <code>{'struct A { ... }'}</code>
</h3>

In FunC, almost any character can be a part of the identifier.
For example, `2+2` (without a space) is an identifier.
You can even declare a variable with such a name.

In Tolk, spaces are not mandatory. `2+2` is 4, as expected. `3+~x` is `3 + (~ x)`, and so on.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'return 2+2;  ;; undefined function `2+2`'}</code></td>
    <td><code>{'return 2+2;  // 4'}</code></td>
  </tr>
  </tbody>
</table>

More precisely, an identifier can start from <code style={{display: 'inline-block'}}>{'[a-zA-Z$_]'}</code>
and be continued with <code style={{display: 'inline-block'}}>{'[a-zA-Z0-9$_]'}</code>. Note that `?`, `:`, and others are not valid symbols, and `found?` and `op::increase` are invalid identifiers.

Note, that `cell`, `slice`, etc. are valid identifiers: `var cell = ...` or even `var cell: cell = ...` is okay. (like in TypeScript, `number` is a valid identifier)

You can use backticks to surround an identifier, and then it can contain any symbols (similar to Kotlin and some other languages). This potential usage is to allow keywords to be used as identifiers in case of code generation by a scheme, for example.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'const op::increase = 0x1234;'}</code></td>
    <td><code>{'const OP_INCREASE = 0x1234;'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: ';; even 2%&!2 is valid<br>int 2+2 = 5;'}}></6></td>
    <td><code dangerouslySetInnerHTML={{__html: '// don\'t do like this :)<br>var \`2+2\` = 5;'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ デフォルトでは無効で、コンパイラーはユーザー関数呼び出し
</h3> をドロップしません。

FunC has an `impure` function specifier. When absent, a function is treated as pure. If its result is unused, its call is deleted by the compiler.

Though this behavior is documented, it is very unexpected to newcomers.
For instance, various functions that don't return anything (throw an exception on mismatch, for example)
are silently deleted. This situation is spoilt by FunC not checking and validating the function body,
allowing impure operations inside pure functions.

Tolk では、すべての関数はデフォルトでは不純です。 アノテーションで純粋な関数をマークすることができます。
そして、不純な操作は本体内で禁止されています (例外、グローバル変更、非純粋な関数の呼び出しなど)。 You can mark a function pure with annotation,
and then impure operations are forbidden in its body (exceptions, globals modification, calling non-pure functions, etc.).

<h3 className="cmp-func-tolk-header">
  ✅ #include → import.
厳密なインポート
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'cell parse_data(slice cs) { }'}</code></td>
    <td><code>{'fun parse_data(cs: slice): cell { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell, int) load_storage() { }'}</code></td>
    <td><code>{'fun load_storage(): (cell, int) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'() main() { ... }'}</code></td>
    <td><code>{'fun main() { ... }'}</code></td>
  </tr>
  </tbody>
</table>

変数の種類 — 右側にも:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'slice cs = ...;'}</code></td>
    <td><code>{'var cs: slice = ...;'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell c, int n) = parse_data(cs);'}</code></td>
    <td><code>{'var (c: cell, n: int) = parse_data(cs);'}</code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

「インライン」などの修飾子 — 注釈付き:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>int f(cell s) inline {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline<br>fun f(s: cell): int {'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() load_data() impure inline_ref {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline_ref<br>fun load_data() {'}}></code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`forall` — こちら：

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'forall X -> tuple cons(X head, tuple tail)'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'fun cons&amp;amp;lt;X&amp;amp;gt;(head: X, tail: tuple): tuple'}}></code></td>
  </tr>
  </tbody>
</table>

`asm` 実装 — FunC のように、適切に整列されていますが、より良いように見えます。

```tolk
@pure
fun third<X>(t: tuple): X
    asm "THIRD";

@pure
fun iDictDeleteGet(dict: cell, keyLen: int, index: int): (cell, slice, int)
    asm(index dict keyLen) "DICTIDELGET NULLSWAPIFNOT";

@pure
fun mulDivFloor(x: int, y: int, z: int): int
    builtin;
```

There is also a `@deprecated` attribute, not affecting compilation, but for a human and IDE.

<h3 className="cmp-func-tolk-header">
  ✅ `method_id`
</h3>

In FunC, `method_id` (without arguments) declared a get method. In Tolk, you use a straightforward syntax:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int seqno() method_id { ... }'}</code></td>
    <td><code>{'get seqno(): int { ... }'}</code></td>
  </tr>
  </tbody>
</table>

`get methodName()` と `get functive methodName()` の両方が受け付けられます。

`method_id(xxx)` の場合（実際は一般的ではないが有効）は、属性があります。

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() after_code_upgrade(cont old_code) impure method_id(1666)'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@method_id(1666)<br>fun afterCodeUpgrade(oldCode: continuation)'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ パラメータの型を宣言することは必須です (ローカルでは省略可能ですが)
</h3>

```tolk
// not allowed
fun do_smth(c, n)
// types are mandatory
fun do_smth(c: cell, n: int)
```

If parameter types are mandatory, the return type is not (it's often obvious or verbose). If omitted, it's auto-inferred:

```tolk
fun x() { ... }  // auto infer from return statements
```

ローカル変数の場合、型も任意です。

```tolk
var i = 10;                      // ok, int
var b = beginCell();             // ok, builder
var (i, b) = (10, beginCell());  // ok, two variables, int and builder

// types can be specified manually, of course:
var b: builder = beginCell();
var (i: int, b: builder) = (10, beginCell());
```

Defaults for parameters are supported:

```tolk
fun increment(x: int, by: int = 1) {
    return x + by
}
```

<h3 className="cmp-func-tolk-header">
  ✅ 同じスコープ
</h3> で変数を再宣言できません。

```tolk
var a = 10;
...
var a = 20;  // error, correct is just `a = 20`
if (1) {
    var a = 30;  // it's okay, it's another scope
}
```

結果として、部分的な再割り当ては許可されていません:

```tolk
var a = 10;
...
var (a, b) = (20, 30);  // error, releclaration of a
```

Note, that it's not a problem for `loadUint()` and other methods. なお、`loadUint()`やその他のメソッドでは問題ありません。 FunC では変更されたオブジェクトを返したので、パターンは `var (cs, int value) = cs です。 oad_int(32)はかなり一般的でした。Tolkでは、このようなメソッドはオブジェクトを変更します: `var value = cs.loadInt(32)\`。したがって、再宣言は必要とされることはありません。 In Tolk, such methods mutate an object: `var value = cs.loadInt(32)\`, so redeclaration is unlikely to be needed.

```tolk
fun send(msg: cell) {
    var msg = ...;  // error, redeclaration of msg

    // solution 1: intruduce a new variable
    var msgWrapped = ...;
    // solution 2: use `redef`, though not recommended
    var msg redef = ...;
```

<h3 className="cmp-func-tolk-header">
  ✅ String postfixes removed, compile-time functions introduced
</h3>

Tolk removes the old FunC-style string postfixes (`"..."c`, etc.) in favor of a **more transparent and more flexible approach**.

<table className="cmp-func-tolk-table">
    <thead>
    <tr>
        <th>FunC</th>
        <th>Tolk</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><code>{'"..."c'}</code></td>
        <td><code>{'stringCrc32("...")'}</code></td>
    </tr>
    <tr>
        <td>—</td>
        <td><code>{'stringCrc16("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."H'}</code></td>
        <td><code>{'stringSha256("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."h'}</code></td>
        <td><code>{'stringSha256_32("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."a'}</code></td>
        <td><code>{'stringAddressToSlice("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."s'}</code></td>
        <td><code>{'stringHexToSlice("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."u'}</code></td>
        <td><code>{'stringToBase256("...")'}</code></td>
    </tr>
    </tbody>
</table>

These functions:

- compile-time only
- for constant strings only
- can be used in constant initialization

```tolk
// type will be `slice`
const BASIC_ADDR = stringAddressToSlice("EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF");

// return type will be `int`
fun minihashDemo() {
    return stringSha256_32("transfer(slice, int)");
}
```

The naming highlights that these functions have arrived from string postfixes and operate on string values.
Remember that at runtime, there are no strings, only slices.

<h3 className="cmp-func-tolk-header">
  ✅ Trailing comma support
</h3>

Tolk now supports trailing commas in the following contexts:

- tensors
- tuples
- function calls
- function parameters

```tolk
var items = (
    totalSupply,
    verifiedCode,
    validatorsList,
);
```

Note that `(5)` is not a tensor. It's just the integer `5` in parentheses.
With a trailing comma `(5,)` it's still `(5)`.

<h3 className="cmp-func-tolk-header">
  ✅ Optional semicolon for the last statement in a block
</h3>

In Tolk, you can omit the semicolon after the final statement in a block.
While semicolons are still required between statements, the trailing semicolon on the last statement is now optional.

```tolk
fun f(...) {
	doSomething();
	return result   // <-- valid without semicolon
}

// or
if (smth) {
	return 1
} else {
	return 2
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Function `ton("...")` for human-readable amounts of Toncoins
</h3>

<table className="cmp-func-tolk-table">
    <thead>
    <tr>
        <th>FunC</th>
        <th>Tolk</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><code>{'int cost = 50000000;'}</code></td>
        <td><code>{'val cost = ton("0.05");'}</code></td>
    </tr>
    <tr>
        <td><code>{'const ONE_TON = 1000000000;'}</code></td>
        <td><code>{'const ONE_TON = ton("1");'}</code></td>
    </tr>
    </tbody>
</table>

The function `ton()` only accepts constant values (e.g., `ton(some_var)` is invalid).
Its type is `coins` (not `int`!), although it's still a regular `int` from the TVM point of view.
Arithmetic over `coins` degrade to `int` (for example, `cost << 1` is valid, `cost + ton("0.02")` also).

<h3 className="cmp-func-tolk-header">
  ✅ Changes in the type system
</h3>

FunC の型システムは Hindley-Milner に基づいています。これは関数型言語の一般的なアプローチであり、型は統合を通じて使用法から推論されます。 This is a common approach for functional languages, where types are inferred from usage through unification.

In Tolk v0.7, the type system is rewritten from scratch.
In order to add booleans, fixed-width integers, nullability, structures, and generics, we must have a static type system (like TypeScript or Rust).
Because Hindley-Milner will clash with structure methods, struggle with proper generics, and become entirely impractical for union types (despite claims that it was _designed for union types_).

以下のタイプがあります。

- `int`, `bool`, `cell`, `slice`, `builder`, untyped `tuple`
- 型付きタプル `[T1, T2, ...]`
- tensor `(T1, T2, ...)`
- callables `(TArgs) -> TResult`
- nullable types `T?`, compile-time null safety
- union types `T1 | T2 | ...`, handled with pattern matching
- `coins` and function `ton("0.05")`
- `int32`, `uint64`, and other fixed-width integers (just int at TVM) [details](https://github.com/ton-blockchain/ton/pull/1559)
- `bytesN` and `bitsN`, similar to `intN` (backed by slices at TVM)
- `address` (internal/external/none, still a slice at TVM)
- `void` (`unit` という名前の方が正規ですが、`void` の方が信頼性が高くなります)
- `self` で、チェーン可能なメソッドを作成します。実際には型ではなく、関数の戻り値の型の代わりに発生することができます。
- `never` (an always-throwing function returns `never`, for example; an "impossible type" is also `never`)
- structures and generics

型システムは次の規則に従います。

- 変数の型は手動で指定することも、宣言から推測することもでき、宣言後に変更されることはありません。
- 関数パラメータは厳密に型指定する必要があります。
- 関数の戻り値の型が指定されていない場合、TypeScript と同様の return ステートメントから推論されます。再帰 (直接的または間接的) の場合、戻り値の型をどこかで明示的に宣言する必要があります。
- 汎用関数がサポートされています。

<h3 className="cmp-func-tolk-header">
  ✅ 型の不一致に関する明確で読みやすいエラーメッセージ
</h3>

FunC では、Hindley-Milner のせいで、型不一致エラーを理解するのが非常に困難です。

```
error: previous function return type (int, int)
cannot be unified with implicit end-of-block return type (int, ()):
cannot unify type () with int
```

Tolk では、人間が判読できるようになります。

```
1) can not assign `(int, slice)` to variable of type `(int, int)`
2) can not call method for `builder` with object of type `int`
3) can not use `builder` as a boolean condition
4) missing `return`
...
```

<h3 className="cmp-func-tolk-header">
  ✅ <code>bool</code> 型、<code>boolVar を int</code> としてキャスト
</h3>

内部では、**`bool` は TVM レベルでは依然として -1 および 0** ですが、型システムの観点からは、`bool` と `int` は異なります。

比較演算子 `== / >= /...` は `bool` を返します。論理演算子 `&& ||` は `bool` を返します。定数 `true` と `false` は `bool` 型です。
多くの stdlib 関数は、「int」ではなく「bool」を返すようになりました (実行時に -1 と 0 が返されます)。 Logical operators `&& ||` return `bool`. Constants `true` and `false` have the `bool` type.
Lots of stdlib functions now return `bool`, not `int` (having -1 and 0 at runtime):

```tolk
var valid = isSignatureValid(...);    // bool
var end = cs.isEnd();                 // bool
```

Operator `!x` supports both `int` and `bool`. Condition of `if` and similar accepts both `int` (!= 0) and `bool`.
演算子 `!x` は `int` と `bool` の両方をサポートします。 `if` などの条件は、`int` (!= 0) と `bool` の両方を受け入れます。
論理 `&&` と `||` は、`bool` と `int` の両方を受け入れ、`a` と `b` が整数 (!= 0) である `a && b` のような構造との互換性を保ちます。

算術演算子は整数に制限されており、ブール値にはビット単位および論理演算子のみが許可されます。

```tolk
valid && end;    // ok
valid & end;     // ok, bitwise & | ^ also work if both are bools
if (!end)        // ok

if (~end)        // error, use !end
valid + end;     // error
8 & valid;       // error, int & bool not allowed
```

Note, that logical operators `&& ||` (missed in FunC) use IF/ELSE asm representation always.
In the future, for optimization, they could be automatically replaced by `& |` when it's safe (example: `a > 0 && a < 10`).
To manually optimize gas consumption, you can still use `& |` (allowed for bools), but remember, that they are not short-circuit.

**`bool` は、`as` 演算子を介して `int` にキャストできます**:

```tolk
var i = boolValue as int;  // -1 / 0
```

There are no runtime transformations. 実行時の変換はありません。 `bool` は TVM レベルで -1/0 であることが保証されているため、これは型のみのキャストです。
しかし一般に、そのようなキャストが必要な場合は、おそらく何か間違ったことをしているでしょう (トリッキーなビットごとの最適化を行っている場合を除く)。
But generally, if you need such a cast, probably you're doing something wrong (unless you're doing a tricky bitwise optimization).

<h3 className="cmp-func-tolk-header">
  ✅ <code>f&amp;amp;lt;int&amp;amp;gt;(...)</code> のような汎用関数とインスタンス化
</h3>

Tolk では、適切に作成された汎用関数が導入されています。その構文は主流言語を思い出させます。 Their syntax reminds mainstream languages:

```tolk
fun replaceNulls<T1, T2>(tensor: (T1?, T2?), v1IfNull: T1, v2IfNull: T2): (T1, T2) {
    var (a, b) = tensor;
    return (a == null ? v1IfNull : a, b == null ? v2IfNull : b);
}
```

汎用パラメータ「T」は複雑なものである可能性があります。

```tolk
fun duplicate<T>(value: T): (T, T) {
    var copy: T = value;
    return (value, copy);
}

duplicate(1);         // duplicate<int>
duplicate([1, cs]);   // duplicate<[int, slice]>
duplicate((1, 2));    // duplicate<(int, int)>
```

あるいは関数でも機能します:

```tolk
fun callAnyFn<TObj, TResult>(f: TObj -> TResult, arg: TObj) {
    return f(arg);
}

fun callAnyFn2<TObj, TCallback>(f: TCallback, arg: TObj) {
    return f(arg);
}
```

Note that while generic `T` is mostly detected from arguments, there are no such obvious corner cases when `T` does not depend on arguments:

```tolk
fun tupleLast<T>(t: tuple): T
    asm "LAST";

var last = tupleLast(t);    // error, can not deduce T
```

これを有効にするには、「T」を外部で指定する必要があります。

```tolk
var last: int = tupleLast(t);       // ok, T=int
var last = tupleLast<int>(t);       // ok, T=int
var last = tupleLast(t) as int;     // ok, T=int

someF(tupleLast(t));       // ok, T=(paremeter's declared type)
return tupleLast(t);       // ok if function specifies return type
```

Also note that `T` for asm functions must occupy one stack slot, whereas for a user-defined function, `T` could be of any shape. Otherwise, asm body is unable to handle it properly.

<h3 className="cmp-func-tolk-header">
  ✅ recv_internal / recv_external
</h3>

```tolk
fun onInternalMessage
fun onExternalMessage
fun onTickTock
fun onSplitPrepare
fun onSplitInstall
```

すべてのパラメータタイプとその注文名は同じ名前に変更されます。名前だけが変更されます。「楽しいmain」も利用できます。 `fun main` is also available.

<h3 className="cmp-func-tolk-header">
  ✅ #include → import. Strict imports
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'#include "another.fc";'}</code></td>
    <td><code>{'import "another.tolk"'}</code></td>
  </tr>
  </tbody>
</table>

In Tolk, you can not use a symbol from `a.tolk` without importing this file. In other words, "import what you use".

All stdlib functions are available out of the box. Downloading stdlib and \\`#include "stdlib.fc" is unnecessary. See below about embedded stdlib.

There is still a global scope of naming. If `f` is declared in two different files, it's an error. We "import" a whole file with no per-file visibility, and the `export` keyword is now supported but probably will be in the future.

<h3 className="cmp-func-tolk-header">
  ✅ #pragma → コンパイラー・オプション
</h3>

FunCでは、 `allow-post-modifications` のような"実験的な"機能がプラグマによってオンになっていました。 cファイル (いくつかのファイルが含まれている場合に問題が発生しますが、そうでない場合もあります) 確かに、それはファイルのプラグマではなく、コンパイルオプションです。 Indeed, it's not a pragma for a file, it's a compilation option.

In Tolk, all pragmas were removed. `allow-post-modification` and `compute-asm-ltr` were merged into Tolk sources (as if they were always on in FunC). Instead of pragmas, there is now an ability to pass experimental options.

今のところ、 `remove-unused-functions` という実験的なオプションが導入されています。これには出力をフィフトするための未使用のシンボルが含まれていません。

`#pragma version xxx` was replaced by `tolk xxx` (no >=, just a strict version). It's good practice to annotate the compiler version you are using. If it doesn't match, Tolk will show a warning.

```tolk
tolk 0.12
```

<h3 className="cmp-func-tolk-header">
  ✅ Late symbols resolving. AST representation
</h3>

In FunC, like in С, you can not access a function declared below:

```func
int b() { a(); }   ;; error
int a() { ... }    ;; since it's declared below
```

To avoid an error, a programmer should first create a forward declaration. The reason is that symbol resolution is performed right during parsing.

Tolk compiler separates these two steps. At first, it does parsing, and then it does symbol resolving. Hence, a snippet above would not be erroneous.

It sounds simple, but internally, it's a very huge job. To make this available, I've introduced an intermediate AST representation, which was completely missed in FunC. That's an essential point for future modifications and performing semantic code analysis.

<h3 className="cmp-func-tolk-header">
  ✅ `null` keyword
</h3>

null 値を作成し、null の変数をチェックするのはとてもきれいになりました。

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'a = null()'}</code></td>
    <td><code>{'a = null'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (null?(a))'}</code></td>
    <td><code>{'if (a == null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ null?(b))'}</code></td>
    <td><code>{'if (b != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ cell_null?(c))'}</code></td>
    <td><code>{'if (c != null)'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `throw` と `assert` キーワード
</h3>

Tolk dramatically simplifies working with exceptions.

FunC が `throw()`、`throw_if()`、`throw_arg_if()`、`throw_arg_if()`、そしてそれ以外の場合、Tolk は `throw` と `assert` の二つのプリミティブを持っています。

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'throw(excNo)'}</code></td>
    <td><code>{'throw excNo'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_arg(arg, excNo)'}</code></td>
    <td><code>{'throw (excNo, arg)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_unless(excNo, condition)'}</code></td>
    <td><code>{'assert(condition, excNo)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_if(excNo, condition)'}</code></td>
    <td><code>{'assert(!condition, excNo)'}</code></td>
  </tr>
  </tbody>
</table>

論理的ではないので、`!condition` は可能です。以下を参照してください。

`assert(condition, excNo)`の長い(verbose)構文があります。

```tolk
assert(condition) throw excNo;
// with a possibility to include arg to throw
```

また、Tolk は `catch` 引数を交換します: `catch (excatchNo, arg)` です。どちらもオプションです(argはおそらく空です)。

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'try { } catch (_, _) { }'}</code></td>
    <td><code>{'try { } catch { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (_, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (arg, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo, arg) { }'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `do ... until` → `do ... while`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'do { ... } until (~ condition);'}</code></td>
    <td><code>{'do { ... } while (condition);'}</code></td>
  </tr>
  <tr>
    <td><code>{'do { ... } until (condition);'}</code></td>
    <td><code>{'do { ... } while (!condition);'}</code></td>
  </tr>
  </tbody>
</table>

論理的ではないので、`!condition` は可能です。以下を参照してください。

<h3 className="cmp-func-tolk-header">
  ✅ 演算子の優先順位が C++ / JavaScript
</h3> と同一になりました。

In FunC, such code `if (slices_equal() & status == 1)` is parsed as `if( (slices_equal()&status) == 1 )`. This approach is a reason for various errors in real-world contracts.

In Tolk, `&` has a lower priority, which is identical to C++ and JavaScript.

Moreover, Tolk fires errors on potentially wrong operators' usage to eliminate such errors:

```tolk
if (flags & 0xFF != 0)
```

はコンパイルエラーにつながります(gcc/clangと同様):

```
& has lower precedence than ==, probably this code won't work as you expected.  Use parenthesis: either (... & ...) to evaluate it first, or (... == ...) to suppress this error.
```

Hence, you should rewrite the code:

```tolk
// either to evaluate it first (our case)
if ((flags & 0xFF) != 0)
// or to emphasize the behavior (not our case here)
if (flags & (0xFF != 0))
```

ビットシフト演算子のよくある間違いに対する診断も追加しました。`a << 8 + 1`は`a << 9`と同じで、おそらく予想外のことでしょう。

```
int result = a << 8 + low_mask;

error: << has lower precedence than +, probably this code won't work as you expected.  Use parenthesis: either (... << ...) to evaluate it first, or (... + ...) to suppress this error.
```

演算子 `~% ^% /% ~/= ^/= ~%= ^%= ~>= ^>= ^>=` はもう存在しません。

<h3 className="cmp-func-tolk-header">
  ✅ 不変数、`val`
</h3>

Kotlinのように、変更不可能な場合は`var`、不変の場合は`val`、オプションで型を追加します。FunCには`val`のアナログはありません。 FunC has no analogue of `val`.

```tolk
val flags = msgBody.loadMessageFlags();
flags &= 1;         // error, modifying an immutable variable

val cs: slice = c.beginParse();
cs.loadInt(32);     // error, since loadInt() mutates an object
cs.preloadInt(32);  // ok, it's a read-only method
```

関数のパラメータは変更可能ですが、値でコピーされるため、引数と呼ばれるものは変更されません。FunCと同じように明確にしましょう。 Exactly like in FunC, just to clarify.

```tolk
fun some(x: int) {
    x += 1;
}

val origX = 0;
some(origX);      // origX remains 0

fun processOpIncrease(msgBody: slice) {
    val flags = msgBody.loadInt(32);
    ...
}

processOpIncrease(msgBody);  // by value, not modified
```

Tolk では、関数は `mutate` パラメータを宣言することができます。これは、FunC `~` チルダ関数の一般化です。 It's a generalization of FunC `~` tilda functions, read below.

<h3 className="cmp-func-tolk-header">
  ✅ Deprecated command-line options removed
</h3>

Command-line flags `-A`, `-P`, and others were removed. Default behavior

```
/path/to/tolk {inputFile}
```

is more than enough. は十分です。バージョンを印刷して終了するには、`-v`を使用します。使用可能なコマンドラインフラグはすべて`-h`を使用します。 Use `-h` for all available command-line flags.

1つの入力ファイルのみが渡され、他のファイルは`import`'edにする必要があります。

<h3 className="cmp-func-tolk-header">
  ✅ stdlib 関数は ~~verbose~~ クリアな名前、camelCase style
</h3>

All names in the standard library were reconsidered. Now, functions are called using longer but clear names.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'cur_lt()<br>car(l)<br>get_balance().pair_first()<br>raw_reserve(count)<br>dict~idict_add?(...)<br>dict~udict::delete_get_max()<br>t~tpush(triple(x, y, z))<br>s.slice_bits()<br>~dump(x)<br>...'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'blockchain.logicalTime()<br>listGetHead(l)<br>contract.getOriginalBalance()<br>reserveToncoinsOnBalance(count)<br>dict.iDictSetIfNotExists(...)<br>dict.uDictDeleteLastAndGet()<br>t.push([x, y, z])<br>s.remainingBitsCount()<br>debug.print(x)<br>...'}}></code></td>
  </tr>
  </tbody>
</table>

以前の "stdlib.fc" 複数のファイルに分割されました: common.tolk, tvm-dicts.tolk, その他.

[Tolk vs FunC: スタンダードライブラリ](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib) で続けましょう。

<h3 className="cmp-func-tolk-header">
  ✅ stdlib is now embedded, not downloaded from GitHub
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <ol style={{margin: 0}}>
        <li>Download stdlib.fc from GitHub</li>
        <li>Save into your project</li>
        <li>`#include "stdlib.fc";`</li>
        <li>Use standard functions</li>
      </ol>
    </td>
    <td>
      <ol style={{margin: 0}}>
        <li>Use standard functions</li>
      </ol>
    </td>
  </tr>
  </tbody>
</table>

In Tolk, stdlib a part of distribution. Tolkでは、stdlibは分布の一部です。 標準ライブラリは切り離せません。なぜなら、3つの"言語、コンパイラ、stdlib"を一緒に保つことがリリースサイクルを維持する唯一の正しい方法だからです。

It works in such a way. Tolk コンパイラは、標準ライブラリを見つける方法を知っています。 ユーザが apt パッケージをインストールした場合、stdlib ソースもダウンロードされ、ハードディスク上に存在します。 コンパイラはそれらをシステムパスで特定します WASMラッパーを使用する場合は、料金所によって提供されます。 If a user has installed an apt package, stdlib sources were also downloaded and exist on a hard disk, so the compiler locates them by system paths. If a user uses a WASM wrapper, they are provided by tolk-js. And so on.

標準ライブラリは複数のファイルに分割されています: `common.tolk` (最も一般的な関数)、`gas-payments.tolk` (ガス料金を計算する)、`tvm-dicts。 olk`、その他。`common.tolk`の関数は常に使用できます（コンパイラが暗黙的にインポートします）。他のファイルは明示的にインポートする必要があります。 Functions from `common.tolk` are available always (a compiler implicitly imports it). Other files are needed to be explicitly imported:

```tolk
import "@stdlib/tvm-dicts"   // ".tolk" optional

...
var dict = createEmptyDict();
dict.iDictSet(...);
```

「使用するものをインポート」というルールに注意してください。これは、`@stdlib/...`ファイルにも適用されます(「common.tolk」のみを除く)。

JetBrains IDEプラグインはstdlibフォルダを自動的に検出し、入力中に必要なインポートを挿入します。

<h3 className="cmp-func-tolk-header">
  ✅ 論理演算子 `&& |`, 論理的ではない `!`
</h3>

In FunC, there are only bitwise operators `~ & | ^`. FunC では、ビット単位の演算子は `~ & | ^` しかありません。 開発者は最初のステップを行い、「わかりません、論理的ではありません、私は同じ方法でビットワイズを使用します」と考えます。オペレータの動作はまったく異なるため、多くの場合、エラーが発生します。

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>`a & b`</th>
    <th>`a && b`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>sometimes, identical:</td></tr>
  <tr>
    <td><code>{'0 & X = 0'}</code></td>
    <td><code>{'0 & X = 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'-1 & X = -1'}</code></td>
    <td><code>{'-1 & X = -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>but generally, not:</td></tr>
  <tr>
    <td><code>{'1 & 2 = 0'}</code></td>
    <td><code>{'1 && 2 = -1 (true)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>`~ found`</th>
    <th>`!found`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>sometimes, identical:</td></tr>
  <tr>
    <td><code>{'true (-1) → false (0)'}</code></td>
    <td><code>{'-1 → 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'false (0) → true (-1)'}</code></td>
    <td><code>{'0 → -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>but generally, not:</td></tr>
  <tr>
    <td><code>{'1 → -2'}</code></td>
    <td><code>{'1 → 0 (false)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition & f()</code></th>
    <th><code>condition && f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> is called always</td>
    <td><code className="inline">f()</code> is called only if <code className="inline">condition</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition | f()</code></th>
    <th><code>condition || f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> is called always</td>
    <td><code className="inline">f()</code> is called only if <code className="inline">condition</code> is false</td>
  </tr>
  </tbody>
</table>

Tolk supports logical operators. They behave exactly as you get used to (right column). For now, `&&` and `||` sometimes produce not optimal Fift code, but in the future, Tolk compiler will become smarter in this case. It's negligible, just use them like in other languages.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'if (~ found?)'}</code></td>
    <td><code>{'if (!found)'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'if (~ found?) {<br>    if (cs~load_int(32) == 0) {<br>        ...<br>    }<br>}'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'if (!found && cs.loadInt(32) == 0) {<br>    ...<br>}'}}></code></td>
  </tr>
  <tr>
    <td><code>{'ifnot (cell_null?(signatures))'}</code></td>
    <td><code>{'if (signatures != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'elseifnot (eq_checksum)'}</code></td>
    <td><code>{'else if (!eqChecksum)'}</6></td>
  </tr>
  </tbody>
</table>

Keywords `ifnot` and `elseifnot` were removed, since now we have logical not (for optimization, Tolk compiler generates `IFNOTJMP`, btw). The `elseif` keyword  was replaced by the traditional `else if`.

Remember that a boolean `true`, transformed `as int`, is -1, not 1. It's a TVM representation.

<h3 className="cmp-func-tolk-header">
  ✅ Indexed access `tensorVar.0` and `tupleVar.0`
</h3>

Use `tensorVar.{i}` to access i-th component of a tensor. Modifying it will change the tensor.

```tolk
var t = (5, someSlice, someBuilder);   // 3 stack slots
t.0         			// 5
t.0 = 10;   			// t is now (10, ...)
t.0 += 1;               // t is now (11, ...)
increment(mutate t.0);  // t is now (12, ...)
t.0.increment();        // t is now (13, ...)

t.1         // slice
t.100500    // compilation error
```

Use `tupleVar.{i}` to access i-th element of a tuple (does INDEX under the hood). Modifying it will change the tuple (does SETINDEX under the hood).

```tolk
var t = [5, someSlice, someBuilder];   // 1 tuple on a stack with 3 items
t.0                     // "0 INDEX", reads 5
t.0 = 10;               // "0 SETINDEX", t is now [10, ...]
t.0 += 1;               // also works: "0 INDEX" to read 10, "0 SETINDEX" to write 11
increment(mutate t.0);  // also, the same way
t.0.increment();        // also, the same way

t.1         // "1 INDEX", it's slice
t.100500    // compilation error
```

It also works for untyped tuples, though the compiler can't guarantee index correctness.

```tolk
var t = createEmptyTuple();
t.tuplePush(5);
t.0                     // will head 5
t.0 = 10                // t will be [10]
t.100500                // will fail at runtime
```

It works for nesting `var.{i}.{j}`. It works for nested tensor, nested tuples, tuples nested into tensors.
It works for `mutate`. It works for globals.

```tolk
t.1.2 = 10;    // "1 INDEX" + "2 SETINDEX" + "1 SETINDEX"
t.1.2 += 10;   // "1 INDEX" + "2 INDEX" + sum + "2 SETINDEX" + "1 SETINDEX"

globalTuple.1.2 += 10;  // "GETGLOB" + ... + "SETGLOB"
```

<h3 className="cmp-func-tolk-header">
  ✅ `2+2`は識別子ではなく4です。識別子は英数字
</h3>

In TVM, all **binary data** is just **a slice.** Same goes for addresses: while TL-B describes the entity `MsgAddress` (internal/external/none/var address),

and TVM assembler has instructions to load/validate addresses, nevertheless: at the low level, it's just a slice.
That's why in FunC's standard library `loadAddress` returned `slice`, and `storeAddress` accepted `slice`.

Tolk introduces the dedicated `address` type. It's still a TVM slice at runtime (internal/external/none),
but it differs from an **abstract slice** from the type system point of view:

1. Integrated with auto-serialization: compiler knows how to pack/unpack it (`LDMSGADDR` and `STSLICE`)
2. Comparable: operators `==` and `!=` work on addresses:

```tolk
if (senderAddress == msg.owner)
```

3. Introspectable: `address.isNone()`, `address.isInternal()`, `address.isExternal()`, `address.getWorkchain()` and `address.getWorkchainAndHash()` (valid for internal addresses)

Passing a slice instead leads to an error:

```tolk
var a: slice = s.loadAddress();  // error, can not assign `address` to `slice`
```

**Embedding a const address into a contract**

Use the built-in `address()` function, which accepts a standard address. In FunC, there was a postfix `"..."a` that returned a slice.

```tolk
address("EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5")
address("0:527964d55cfa6eb731f4bfc07e9d025098097ef8505519e853986279bd8400d8")
```

**Casting `slice` to `address` and vice versa**

If you have a raw slice, which is actually an address, you can cast it via `as` operator.
In practice, this can occur if you've composed an address with a builder, having manually written its binary representation:

```tolk
var b = beginCell()
       .storeUint(0b01)   // addr_extern
       ...;
var s = b.endCell().beginParse();
return s as address;   // `slice` as `address`
```

A reversed cast also is valid: `someAddr as slice` (why would you need it, is an open question, though).

**Different types of addresses**

According to a standard, there are different types of addresses. The most frequently used is a **standard address** — just and address of a smart contract, like `EQ...`. But also, there are **external** and **none** addresses. In a binary TL-B representation,

- `10` (**internal** prefix) + `0` (anycast, always 0) + workchain (8 bits) + hash (256 bits) — that's `EQ...`: it's 267 bits
- `01` (**external** prefix) + len (9 bits) + len bits — external addresses
- `00` (**none** prefix) — address **none**, 2 bits

The `address` type can hold any of these. Most often, it's an internal address. But the type system does not restrict it exactly: this can't be done without heavy runtime checks.

So, if `address` comes from an untrusted input, you should probably validate it:

```tolk
val newOwner = msg.nextOwnerAddress;
assert(newOwner.isInternal()) throw 403;
assert(newOwner.getWorkchain() == BASECHAIN) throw 403;
```

All in all, if you don't trust inputs — you should validate everything: numbers, payload, and addresses particularly.
But if an input comes from a trusted source (your own contract storage, for example) — of course, you can rely on its contents.
The compiler does not insert hidden instructions.
Just remember, that `address` in general can hold all valid types.

<h3 className="cmp-func-tolk-header">
  ✅ Type aliases <code>type NewName = &amp;amp;lt;existing type&amp;amp;gt;</code>
</h3>

Tolk supports type aliases, similar to TypeScript and Rust.
An alias creates a new name for an existing type but **remains interchangeable with it**.

```tolk
type UserId = int32;
type MaybeOwnerHash = bytes32?;

fun calcHash(id: UserId): MaybeOwnerHash { ... }

var id: UserId = 1;       // ok
var num: int = id;        // ok
var h = calcHash(id);
if (h != null) {
    h as slice;           // bytes32 as slice
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Nullable types `T?`, null safety, smart casts, operator `!`
</h3>

Tolk has nullable types: `int?`, `cell?`, and `T?` in general (even for tensors).
Non-nullable types, such as `int` and `cell`, can never hold null values.

The compiler enforces **null safety**: you cannot use nullable types without first checking for null.
Fortunately, these checks integrate smoothly and organically into the code thanks to smart casts.
Smart casts are purely a compile-time feature — they do not consume gas or extra stack space.

```tolk
var value = x > 0 ? 1 : null;  // int?

value + 5;               // error
s.storeInt(value);       // error

if (value != null) {
    value + 5;           // ok, smart cast
    s.storeInt(value);   // ok, smart cast
}
```

Remember that when a variable's type is not specified, it's auto-inferred from the assignment and never changes:

```tolk
var i = 0;
i = null;       // error, can't assign `null` to `int`
i = maybeInt;   // error, can't assign `int?` to `int`
```

Such a code will not work. You must **explicitly declare the variable as nullable**::

```tolk
// incorrect
var i = null;
if (...) {
    i = 0;     // error
}

// correct
var i: int? = null;
// or
var i = null as int?;
```

Smart casts (similar to TypeScript and Kotlin) make it easier to deal with nullable types, allowing code like this:

```tolk
if (lastCell != null) {
    // here lastCell is `cell`, not `cell?`
}
```

```tolk
if (lastCell == null || prevCell == null) {
    return;
}
// both lastCell and prevCell are `cell`
```

```tolk
var x: int? = ...;
if (x == null) {
    x = random();
}
// here x is `int`
```

```tolk
while (lastCell != null) {
    lastCell = lastCell.beginParse().loadMaybeRef();
}
// here lastCell is 100% null
```

```tolk
// t: (int, int)?
t.0                // error
t!.0               // ok
if (t.0 != null) {
    t.0            // ok
}
```

Note that smart casts don't work for globals; they only work for local vars.

Tolk has the `!` operator (non-null assertion, compile-time only), like `!` in TypeScript and `!!` in Kotlin.
If you are certain that a variable is not null,
this operator allows you to skip the compiler's check.

```tolk
fun doSmth(c: cell);

fun analyzeStorage(nCells: int, lastCell: cell?) {
    if (nCells) {           // then lastCell 100% not null
        doSmth(lastCell!);  // use ! for this fact
    }
}
```

In practice, you'll use this operator working with low-level dicts API.
Tolk will have a high-level `map<K,V>` in the future.
For now, working with dicts will require the `!` operator.

```tolk
// it returns either (slice, true) or (null, false)
@pure
fun dict.iDictGet(self, keyLen: int, key: int): (slice?, bool)
    asm(key self keyLen) "DICTIGET" "NULLSWAPIFNOT";

var (cs, exists) = myDict.iDictGet(...);
// if exists is true, cs is not null
if (exists) {
    cs!.loadInt(32);
}
```

You can also declare "always-throwing functions" that return `never`:

```tolk
fun alwaysThrows(): never {
    throw 123;
}

fun f(x: int) {
    if (x > 0) {
        return x;
    }
    alwaysThrows();
    // no `return` statement needed
}
```

The `never` type implicitly occurs when a condition can never happen:

```tolk
var v = 0;
// prints a warning
if (v == null) {
    // v is `never`
    v + 10;   // error, can not apply `+` `never` and `int`
}
// v is `int` again
```

If you encounter `never` in compilation errors, there is most likely a warning in the preceding code.

Non-atomic nullable are also allowed: `(int, int)?`, `(int?, int?)?`, or even `()?`. Then,
a special _value presence_ stack slot is implicitly added.
It holds `0` if a value is null, and not 0 (currently, -1) if not null:

```tolk
// t: (int, int)?
t = (1, 2);    // 1 2 -1
t = (3, 4);    // 3 4 -1
t = null;      // null null 0

// t: ()?
t = ();         // -1
t = null;       // 0
```

All in all, nullability is a significant step forward for type safety and reliability.
Nullable types eliminate runtime errors, enforcing correct handling of optional values.

<h3 className="cmp-func-tolk-header">
  ✅ Union types `T1 | T2 | ...`, operators `match`, `is`, `!is`
</h3>

Union types allow a variable to hold multiple possible types, similar to TypeScript.

```tolk
fun whatFor(a: bits8 | bits256): slice | UserId { ... }

var result = whatFor(...);  // slice | UserId
```

Nullable types `T?` are now formally `T | null`.
Union types have intersection properties. For instance, `B | C` can be passed/assigned to `A | B | C | D`.

The only way to work with unions from code is **pattern matching**:

```tolk
match (result) {
    slice  => { /* result is smart-casted to slice  */ }
    UserId => { /* result is smart-casted to UserId */ }
}
```

Example:

```tolk
match (result) {
    slice => {
        return result.loadInt(32);
    }
    UserId => {
        if (result < 0) {
            throw 123;
        }
        return loadUser(result).parentId;
    }
}
```

`match` must cover all union cases (should be _exhaustive_). It can also be **used as an expression**:

```tolk
type Pair2 = (int, int);
type Pair3 = (int, int, int);

fun getLast(tensor: Pair2 | Pair3) {
    return match (tensor) {
        Pair2 => tensor.1,
        Pair3 => tensor.2,
    }
}
```

Syntax details:

- commas are optional with {} but required for expressions
- a trailing comma is allowed
- semicolon is not required after `match` used as a statement
- for match-expressions, its arm can terminate, then its type is considered `never`:

```tolk
return match (msg) {
    ...
    CounterReset => throw 403,  // forbidden
}
```

Variable declaration inside `match` is allowed:

```tolk
match (val v = getPair2Or3()) {
    Pair2 => {
        // use v.0 and v.1
    }
    Pair3 => {
        // use v.0, v.1, and v.2
    }
}
```

<details>
<summary>How are union types represented on the stack, at the TVM level?</summary>

Internally, at the TVM level, they are stored as tagged unions, like enums in Rust:

- each type is assigned a unique type ID, which is stored alongside the value
- the union occupies N + 1 stack slots, where N is the maximum size of any type in the union
- a nullable type `T?` is just a union with null (type ID = 0); `int?` and other atomics still use 1 stack slot

```tolk
var v: int | slice;    // 2 stack slots: value and typeID
                       // - int:   (100, 0xF831)
                       // - slice: (CS{...}, 0x29BC)
match (v) {
    int =>     // IF TOP == 0xF831 { ... }
        // v.slot1 contains int, can be used in arithmetics
    slice =>   // ELSE { IF TOP == 0x29BC { ... } }
        // v.slot1 contains slice, can be used to loadInt()
}

fun complex(v: int | slice | (int, int)) {
    // Stack representation:
    // - int:        (null, 100, 0xF831)
    // - slice:      (null, CS{...}, 0x29BC)
    // - (int, int): (200, 300, 0xA119)
}

complex(v);   // passes (null, v.slot1, v.typeid)
complex(5);   // passes (null, 5, 0xF831)
```

</details>

Besides `match`, you can test a union type by `is`. Smart casts work as expected:

```tolk
fun f(v: cell | slice | builder) {
    if (v is cell) {
        v.cellHash();
    } else {
        // v is `slice | builder`
        if (v !is builder) { return; }
        // v is `slice`
        v.sliceHash();
    }
    // v is `cell | slice`
    if (v is int) {
        // v is `never`
        // a warning is also printed, condition is always false
    }
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Pattern matching for expressions (switch-like behavior)
</h3>

`match` can also be used for **constant expressions**, similar to `switch`:

```tolk
val nextValue = match (curValue) {
    1 => 0,
    0 => 1,
    else => -1
};
```

Rules:

- only constant expressions are allowed on the left-hand side (1, SOME_CONST, 2 + 3)
- branches can contain `return` and `throw`
- `else` is required for expression form but optional for statement form:

```tolk
// statement form
match (curValue) {
    1 => { nextValue = 0 }
    0 => { nextValue = 1 }
    -1 => throw NEGATIVE_NOT_ALLOWED
}

// expression form, else branch required
val nextValue = match (curValue) {
    ...
    else => <expression>
}
```

<h3 className="cmp-func-tolk-header">
  ✅ 新しい関数構文: `fun` キーワード、`@` 属性、右側の型 (TypeScript、Kotlin、Pythonなど)
</h3> }'}</code>
</h3>

Looks like TypeScript — but works in TVM!

```tolk
struct Point {
    x: int;
    y: int;
}

fun calcMaxCoord(p: Point) {
    return p.x > p.y ? p.x : p.y;
}

// declared like a JS object
var p: Point = { x: 10, y: 20 };
calcMaxCoord(p);

// called like a JS object
calcMaxCoord({ x: 10, y: 20 });

// works with shorthand syntax
fun createPoint(x: int, y: int): Point {
    return { x, y };
}
```

- a struct is just **a named tensor**
- `Point` is identical to `(int, int)` at the TVM level
- field access `p.x` works like accessing tensor elements `t.0`, for reading and writing

This means **no bytecode overhead** — you can replace unreadable tensors with clean, structured types.

Fields can be separated by `;` or `,` (both are valid, like in TypeScript). Trailing commas are allowed.

When creating a structure, you can specify `StructName { ... }` or simply `{ ... }` if the type is clear from the context (e.g., return type or assignment):

```tolk
var s: StoredInfo = { counterValue, ... };
var s: (int, StoredInfo) = (0, { counterValue, ... });

// also valid, but not preferred
var s = StoredInfo { counterValue, ... };
```

Default values for fields are supported:

```tolk
struct DefDemo {
    f1: int = 0;
    f2: int? = null;
    f3: (int, coins) = (0, ton("0.05"));
}

var d: DefDemo = {};         // ok
var d: DefDemo = { f2: 5 };  // ok
```

Structs can have methods as extension functions, read below.

<h3 className="cmp-func-tolk-header">
  ✅ Generic structs and aliases
</h3>

They exist only at the type level (no runtime cost).

```tolk
struct Container<T> {
    isAllowed: bool;
    element: T?;
}

struct Nothing {}

type Wrapper<T> = Nothing | Container<T>;
```

Example usage:

```tolk
fun checkElement(c: Container<T>) {
    return c.element != null;
}

var c: Container<int32> = { isAllowed: false, element: null };

var v: Wrapper<int> = Nothing {};
var v: Wrapper<int32> = Container { value: 0 };
```

Since it's a generic, you should specify type arguments when using it:

```tolk
fun getItem(c: Container)        // error, specify type arguments
fun getItem(c: Container<int>)   // ok
fun getItem<T>(c: Container<T>)  // ok

var c: Container = { ... }       // error, specify type arguments
var c: Container<int> = { ... }  // ok
```

When you declare a generic function, the compiler can automatically infer type arguments for a call:

```tolk
fun doSmth<T>(value: Container<T>) { ... }

doSmth({ item: 123 });         // T = int
doSmth({ item: cellOrNull });  // T = cell?
```

Demo: `Response<TResult, TError>`:

```tolk
struct Ok<TResult> { result: TResult; }
struct Err<TError> { err: TError; }

type Response<R, E> = Ok<R> | Err<E>;

fun tryLoadMore(slice: slice): Response<cell, int32> {
    return ...
        ? Ok { result: ... }
        : Err { err: ErrorCodes.NO_MORE_REFS };
}

match (val r = tryLoadMore(inMsg)) {
    Ok => { r.result }
    Err => { r.err }
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Methods: for any types, including structures
</h3>

Methods are declared as extension functions, similar to Kotlin.
A method can accept the first `self` parameter (then it's an instance method) or not accept it (then it's a static method).

```tolk
fun Point.getX(self) {
    return self.x
}

fun Point.create(x: int, y: int): Point {
    return { x, y }
}
```

Methods can be created **for any type**, including aliases, unions, and built-in types:

```tolk
fun int.isZero(self) {
    return self == 0;
}

type MyMessage = CounterIncrement | ...;

fun MyMessage.parse(self) { ... }
// this is identical to
// fun (CounterIncrement | ...).parse(self)
```

Methods perfectly work with `asm`, since `self` is just a regular variable:

```tolk
@pure
fun tuple.size(self): int
    asm "TLEN";
```

By default, **`self` is immutable**. It means that you can't modify it or call mutating methods.
To make `self` mutable, you should explicitly declare `mutate self`:

```tolk
fun Point.assignX(mutate self, x: int) {
    self.x = x;   // without mutate, an error "modifying immutable object"
}

fun builder.storeInt32(mutate self, v: int32): self {
    return self.storeInt(v, 32);
}
```

Methods for generic structs created seamlessly.
Note, that no extra `<T>` is required: while parsing the receiver type, compiler treats unknown symbols as generic arguments.

```tolk
struct Container<T> {
    item: T;
}

// compiler treats T (unknown symbol) as a generic parameter
fun Container<T>.getItem(self) {
    return self.item;
}

// and this is a specialization for integer containers
fun Container<int>.getItem(self) {
    ...
}
```

Another example:

```tolk
struct Pair<T1, T2> {
    first: T1;
    second: T2;
}

// both <T1,T2>, <A,B>, etc. work: any unknown symbols
fun Pair<A, B>.create(f: A, s: B): Pair<A, B> {
    return {
        first: f,
        second: s,
    }
}
```

Similarly, any unknown symbol (typically, `T`) can be used to make a method accepting anything:

```tolk
// any receiver
fun T.copy(self): T {
    return self;
}

// any nullable receiver
fun T?.isNull(self): bool {
    return self == null;
}
```

When you call `someObj.method()`, multiple methods with the same name may exist and theoretically be acceptable:

```tolk
fun T.copy(self) { ... }
fun int.copy(self) { ... }

someVar.copy();   // ???
```

So, the compiler performs matching to find as precise method as follows:

1. Search for exact type receiver like `int.copy` (most practical cases finish here)
2. Search for non-generic receivers that are acceptable (like `int32.copy` / `int?.copy`)
3. Search for generic receivers except `T` (like `Container<T>.copy`)
4. Search for `T` receivers (`T.copy`)

```tolk
fun int.copy(self) { ... }
fun T.copy(self) { ... }

6.copy()              // int.copy (rule 1)
(6 as int32).copy()   // int.copy (rule 2)
(6 as int32?).copy()  // T.copy with T=int? (rule 4)
```

```tolk
type MyMessage = CounterIncrement | CounterReset;
fun MyMessage.check() { ... }
fun CounterIncrement.check() { ... }

MyMessage{...}.check()         // first (rule 1)
CounterIncrement{...}.check()  // second (rule 1)
CounterReset{...}.check()      // first (rule 2)
```

In case of ambiguity, an error is printed:

```tolk
fun int?.doSmth(self) { ... }
fun int64.doSmth(self) { ... }

var v: int32;
v.doSmth();   // error: no exact match, but two possible acceptable receivers
```

You can assign a generic function to the variable, but you should explicitly specify types:

```tolk
fun genericFn<T>(v: T) { ... }
fun Container<T>.getItem(self) { ... }

var callable1 = genericFn<slice>;
var callable2 = Container<int32>.getItem;
callable2(someContainer32);   // pass it as self
```

<h3 className="cmp-func-tolk-header">
  ✅ チルダの `~` メソッドはありません。`mutate` キーワードは代わりに
</h3>

この変更は非常に大きく、別のページで説明されています: [Tolk 可変性](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability)。

<h3 className="cmp-func-tolk-header">
  ✅ 後期記号の解像度。AST 表現
</h3>

Having any struct, you can unpack in from a cell or pack and object to a cell:

```tolk
struct Point {
    x: int8;
    y: int8;
}

var value: Point = { x: 10, y: 20 };

// makes a cell containing "0A14"
var c = value.toCell();
// back to { x: 10, y: 20 }
var p = Point.fromCell(c);
```

Continue reading on a separate page: [Auto-packing to/from cells](/v3/documentation/smart-contracts/tolk/tolk-vs-func/pack-to-from-cells).

<hr />

<h3>フリーダイヤル対ファンCガス消費</h3>

:::tip The same or slightly less
If you transform FunC code line-by-line (for example, using a [converter](https://github.com/ton-blockchain/convert-func-to-tolk)),
you'll have the same results or even a bit better.
:::

Since Tolk is a fork of FunC, part of its core remains unchanged — particularly the stack manipulation logic.
Yes, Tolk is a completely different language, with its own syntax and semantics,
but its low-level internal representation is exactly the same as FunC's.
As a result, the syntax has no impact on gas consumption.
In fact, it's even slightly lower, since the strict type system
gives the compiler more room for optimizations.

However, once Tolk v1.0 is released, it will be significantly more efficient.
Auto-serialized structures, automatic message construction, and other features will be
noticeably cheaper than manual work with builders and slices — almost always.

<Feedback />
