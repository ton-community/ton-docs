import Feedback from '@site/src/components/Feedback';

# Сравнение Tolk и FunC: подробно

Ниже очень большой список. У кого-нибудь хватит терпения дочитать его до конца?..

:::tip Есть краткая версия
Здесь: [Сравнение Tolk и FunC: коротко](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)
:::

<h3 className="cmp-func-tolk-header">
  ✅ Классические комментарии :)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{';; комментарий'}</code></td>
    <td><code>{'// комментарий'}</code></td>
  </tr>
  <tr>
    <td><code>{'{- многострочный комментарий -}'}</code></td>
    <td><code>{'/* многострочный комментарий */'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
✅ `2+2` — это 4, а не идентификатор. Идентификаторы могут быть только буквенно-цифровыми
</h3>

В FunC почти любой символ может быть частью идентификатора.
Например, `2+2` (без пробела) — это идентификатор.
Вы даже можете объявить переменную с таким именем.

В Tolk пробелы не обязательны. `2+2` — это 4, как и ожидалось. `3+~x` это `3 + (~ x)` и так далее.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'return 2+2;  ;; неопределенная функция `2+2`'}</code></td>
    <td><code>{'return 2+2;  // 4'}</code></td>
  </tr>
  </tbody>
</table>

Точнее, идентификатор может начинаться с <code style={{display: 'inline-block'}}>{'[a-zA-Z$_]'}</code>
и продолжиться с <code style={{display: 'inline-block'}}>{'[a-zA-Z0-9$_]'}</code>. Обратите внимание, что `?`, `:` и другие не являются допустимыми символами, `found?` и `op::increase` не являются допустимыми идентификаторами.

Note, that `cell`, `slice`, etc. are valid identifiers: `var cell = ...` or even `var cell: cell = ...` is okay. (like in TypeScript, `number` is a valid identifier)

Вы можете использовать обратные кавычки, чтобы окружить идентификатор, и тогда он может содержать любые символы (аналогично Kotlin и некоторым другим языкам). Его потенциальное применение — разрешить использовать ключевые слова в качестве идентификаторов, например, в случае генерации кода по схеме.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'const op::increase = 0x1234;'}</code></td>
    <td><code>{'const OP_INCREASE = 0x1234;'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: ';; even 2%&!2 is valid<br>int 2+2 = 5;'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '// don\'t do like this :)<br>var \`2+2\` = 5;'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ По умолчанию нечеткий, компилятор не будет отбрасывать вызовы пользовательских функций
</h3>

FunC имеет спецификатор функции `impure`. При его отсутствии функция рассматривается как чистая. Если ее результат не используется, ее вызов был удален компилятором.

Хотя такое поведение документировано, оно очень неожиданно для новичков.
Например, различные функции, которые ничего не возвращают (например, выдают исключение при несовпадении), молча удаляются. Эту ситуацию портит тот факт, что FunC не проверяет и не валидирует тело функции,
разрешая нечеткие операции внутри чистых функций.

В Tolk все функции по умолчанию являются нечистыми. Вы можете пометить функцию как чистую с помощью аннотации,
и тогда в ее теле будут запрещены нечистые операции (исключения, изменение глобальных параметров, вызов нечистых функций и т. д.).

<h3 className="cmp-func-tolk-header">
  ✅ Новый синтаксис функций: ключевое слово `fun`, атрибуты `@`, типы справа (как в TypeScript, Kotlin, Python и т. д.)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'cell parse_data(slice cs) { }'}</code></td>
    <td><code>{'fun parse_data(cs: slice): cell { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell, int) load_storage() { }'}</code></td>
    <td><code>{'fun load_storage(): (cell, int) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'() main() { ... }'}</code></td>
    <td><code>{'fun main() { ... }'}</code></td>
  </tr>
  </tbody>
</table>

Типы переменных — также справа:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'slice cs = ...;'}</code></td>
    <td><code>{'var cs: slice = ...;'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell c, int n) = parse_data(cs);'}</code></td>
    <td><code>{'var (c: cell, n: int) = parse_data(cs);'}</code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

Модификаторы `inline` и другие — с аннотациями:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>int f(cell s) inline {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline<br>fun f(s: cell): int {'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() load_data() impure inline_ref {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline_ref<br>fun load_data() {'}}></code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`forall` — таким образом:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'forall X -> tuple cons(X head, tuple tail)'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'fun cons&amp;amp;lt;X&amp;amp;gt;(head: X, tail: tuple): tuple'}}></code></td>
  </tr>
  </tbody>
</table>

реализация `asm` — как в FunC, но при правильном выравнивании выглядит красивее:

```tolk
@pure
fun third<X>(t: tuple): X
    asm "THIRD";

@pure
fun iDictDeleteGet(dict: cell, keyLen: int, index: int): (cell, slice, int)
    asm(index dict keyLen) "DICTIDELGET NULLSWAPIFNOT";

@pure
fun mulDivFloor(x: int, y: int, z: int): int
    builtin;
```

Также есть атрибут `@deprecated`, не влияющий на компиляцию, но для человека и IDE.

<h3 className="cmp-func-tolk-header">
  ✅ `get` вместо `method_id`
</h3>

В FunC `method_id` (без аргументов) фактически объявляет get-метод. В Tolk используется простой синтаксис:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int seqno() method_id { ... }'}</code></td>
    <td><code>{'get seqno(): int { ... }'}</code></td>
  </tr>
  </tbody>
</table>

Допустимы как `get methodName()`, так и `get fun methodName()`.

Для `method_id(xxx)` (на практике встречается редко, но допустимо) есть атрибут:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() after_code_upgrade(cont old_code) impure method_id(1666)'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@method_id(1666)<br>fun afterCodeUpgrade(oldCode: continuation)'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
✅ Важно объявить типы параметров (хотя необязательно для локальных переменных)
</h3>

```tolk
// not allowed
fun do_smth(c, n)
// types are mandatory
fun do_smth(c: cell, n: int)
```

Если типы параметров обязательны, возвращаемый тип не является обязательным (это часто очевидно из-за многословности). Если он опущен, он выводится автоматически:

```tolk
fun x() { ... }  // auto infer from return statements
```

Для локальных переменных типы также необязательны:

```tolk
var i = 10;                      // ok, int
var b = beginCell();             // ok, builder
var (i, b) = (10, beginCell());  // ok, two variables, int and builder

// types can be specified manually, of course:
var b: builder = beginCell();
var (i: int, b: builder) = (10, beginCell());
```

Defaults for parameters are supported:

```tolk
fun increment(x: int, by: int = 1) {
    return x + by
}
```

<h3 className="cmp-func-tolk-header">
✅ Переменные не могут быть повторно объявлены в той же области
</h3>

```tolk
var a = 10;
...
var a = 20;  // error, correct is just `a = 20`
if (1) {
    var a = 30;  // it's okay, it's another scope
}
```

Как следствие, частичное переназначение не допускается:

```tolk
var a = 10;
...
var (a, b) = (20, 30);  // error, releclaration of a
```

Обратите внимание, что это не проблема для `loadUint()` и других методов. В FunC они возвращали измененный объект, поэтому шаблон `var (cs, int value) = cs.load_int(32)` был довольно распространен. В Tolk такие методы изменяют объект: `var value = cs.loadInt(32)`, поэтому повторное объявление вряд ли понадобится.

```tolk
fun send(msg: cell) {
    var msg = ...;  // error, redeclaration of msg

    // solution 1: intruduce a new variable
    var msgWrapped = ...;
    // solution 2: use `redef`, though not recommended
    var msg redef = ...;
```

В FunC были функции "forall":

Tolk removes the old FunC-style string postfixes (`"..."c`, etc.) in favor of a **more transparent and more flexible approach**.

TLDR

These functions:

- compile-time only
- for constant strings only
- can be used in constant initialization

```tolk
// type will be `address`
const BASIC_ADDR = address("EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF");

// return type will be `int`
fun minihashDemo() {
    return stringSha256_32("transfer(slice, int)");
}
```

The naming highlights that these functions have arrived from string postfixes and operate on string values.
Remember that at runtime, there are no strings, only slices.

<h3 className="cmp-func-tolk-header">
  ✅ Trailing comma support
</h3>

Tolk now supports trailing commas in the following contexts:

- tensors
- tuples
- function calls
- Пользовательские функции также могут быть универсальными:

```tolk
var items = (
    totalSupply,
    verifiedCode,
    validatorsList,
);
```

Note that `(5)` is not a tensor. It's just the integer `5` in parentheses.
With a trailing comma `(5,)` it's still `(5)`.

<h3 className="cmp-func-tolk-header">
  ✅ Optional semicolon for the last statement in a block
</h3>

In Tolk, you can omit the semicolon after the final statement in a block.
While semicolons are still required between statements, the trailing semicolon on the last statement is now optional.

```tolk
fun f(...) {
	doSomething();
	return result   // <-- valid without semicolon
}

// or
if (smth) {
	return 1
} else {
	return 2
}
```

Также обратите внимание, что `T` для функций asm должен занимать 1 слот стека (иначе тело asm не сможет обработать его должным образом), тогда как для пользовательской функции `T` может иметь любую форму.

fun replaceLast<T>(mutate self: tuple, value: T) {
    val size = self.tupleSize();
    self.tupleSetAt(value, size - 1);
}

The function `ton()` only accepts constant values (e.g., `ton(some_var)` is invalid).
Its type is `coins` (not `int`!), although it's still a regular `int` from the TVM point of view.
Arithmetic over `coins` degrade to `int` (for example, `cost << 1` is valid, `cost + ton("0.02")` also).

<h3 className="cmp-func-tolk-header">
✅ Изменения в системе типов
</h3>

Система типов FunC основана на Хиндли-Милнере. Это распространенный подход для функциональных языков, где типы выводятся из использования посредством унификации.

В Tolk v0.7 система типов переписана с нуля.
Чтобы добавить логические значения, целые числа фиксированной ширины, допустимость значений NULL, структуры и обобщения, нам нужна статическая система типов (например, TypeScript или Rust).
Поскольку Хиндли-Милнер будет конфликтовать с методами структур, бороться с надлежащими обобщениями и станет совершенно непрактичным для типов объединений (несмотря на заявления, что он был "разработан для типов объединений").

У нас есть следующие типы:

- `int`, `bool`, `cell`, `slice`, `builder`, нетипизированный `tuple`
- типизированный кортеж `[T1, T2, ...]`
- тензор `(T1, T2, ...)`
- вызываемые `fun(TArgs) -> TResult`
- nullable types `T?`, compile-time null safety
- Когда вызывается `f<T>`, `T` обнаруживается (в большинстве случаев) по предоставленным аргументам:
- `coins` and function `ton("0.05")`
- `int32`, `uint64`, and other fixed-width integers (just int at TVM) [details](https://github.com/ton-blockchain/ton/pull/1559)
- `bytesN` and `bitsN`, similar to `intN` (backed by slices at TVM)
- `address` (internal/external/none, still a slice at TVM)
- `void` (каноничнее называть `unit`, но `void` надежнее)
- `self`, для создания цепочечных методов, описанных ниже; на самом деле это не тип, он может встречаться только вместо возвращаемого типа функции
- `never` (an always-throwing function returns `never`, for example; an _impossible type_ is also `never`)
- structures and generics

Система типов подчиняется следующим правилам:

- типы переменных могут быть указаны вручную или выведены из объявлений и никогда не изменяются после объявления
- параметры функции должны быть строго типизированы
- возвращаемые типы функции, если не указаны, выводятся из операторов return, аналогично TypeScript; в случае рекурсии (прямой или косвенной) возвращаемый тип должен быть явно объявлен где-то
- поддерживаются универсальные функции

<h3 className="cmp-func-tolk-header">
  ✅ Понятные и читаемые сообщения об ошибках при несоответствии типов
</h3>

В FunC из-за Хиндли-Милнера ошибки несоответствия типов очень трудно понять:

```
error: previous function return type (int, int)
cannot be unified with implicit end-of-block return type (int, ()):
cannot unify type () with int
```

В языке Tolk они удобочитаемы для человека:

```
1) can not assign `(int, slice)` to variable of type `(int, int)`
2) can not call method for `builder` with object of type `int`
3) can not use `builder` as a boolean condition
4) missing `return`
...
```

<h3 className="cmp-func-tolk-header">
  ✅ Тип <code>bool</code>, приводящий <code>boolVar к int</code>
</h3>

Внутри себя **`bool` по-прежнему -1 и 0 на уровне TVM**, но с точки зрения системы типов `bool` и `int` теперь различны.

Операторы сравнения `== / >= /...` возвращают `bool`. Логические операторы `&& ||` возвращают `bool`. Константы `true` и `false` имеют тип `bool`.
Многие функции stdlib теперь возвращают `bool`, а не `int` (имея -1 и 0 во время выполнения):

```tolk
var valid = isSignatureValid(...);    // bool
var end = cs.isEndOfSlice();          // bool
```

Оператор `!x` поддерживает как `int`, так и `bool`. Условие `if` и подобные принимает как `int` (!= 0), так и `bool`.
Логические `&&` и `||` принимают как `bool`, так и `int`, сохраняя совместимость с такими конструкциями, как `a && b`, где `a` и `b` являются целыми числами (!= 0).

Арифметические операторы ограничены целыми числами, для bool разрешены только побитовые и логические:

```tolk
valid && end;    // ok
valid & end;     // ok, bitwise & | ^ also work if both are bools
if (!end)        // ok

if (~end)        // error, use !end
valid + end;     // error
8 & valid;       // error, int & bool not allowed
```

Обратите внимание, что логические операторы `&& ||` (отсутствуют в FunC) всегда используют представление asm IF/ELSE.
В будущем для оптимизации их можно будет автоматически заменить на `& |`, когда это безопасно (например: `a > 0 && a < 10`).
Чтобы вручную оптимизировать потребление газа, вы по-прежнему можете использовать `& |` (разрешено для bool), но помните, что они не являются сокращенными.

**`bool` можно привести к `int` с помощью оператора `as`**:

```tolk
var i = boolValue as int;  // -1 / 0
```

Нет никаких преобразований во время выполнения. `bool` гарантированно равен -1/0 на уровне TVM, поэтому это приведение только к типу.
Но, как правило, если вам нужно такое приведение, вероятно, вы делаете что-то неправильно (если только вы не делаете сложную побитовую оптимизацию).

<h3 className="cmp-func-tolk-header">
  ✅ Универсальные функции и экземпляры, такие как <code>f&amp;amp;lt;int&amp;amp;gt;(...)</code>
</h3>

Tolk представляет правильно сделанные универсальные функции. Их синтаксис напоминает основные языки:

```tolk
fun replaceNulls<T1, T2>(tensor: (T1, T2), v1IfNull: T1, v2IfNull: T2): (T1, T2) {
    var (a, b) = tensor;
    return (a == null ? v1IfNull : a, b == null ? v2IfNull : b);
}
```

Общий параметр `T` может быть чем-то сложным.

```tolk
fun duplicate<T>(value: T): (T, T) {
    var copy: T = value;
    return (value, copy);
}

duplicate(1);         // duplicate<int>
duplicate([1, cs]);   // duplicate<[int, slice]>
duplicate((1, 2));    // duplicate<(int, int)>
```

Или даже функции, это тоже работает:

```tolk
fun callAnyFn<TObj, TResult>(f: fun(TObj) -> TResult, arg: TObj) {
    return f(arg);
}

fun callAnyFn2<TObj, TCallback>(f: TCallback, arg: TObj) {
    return f(arg);
}
```

Обратите внимание, что хотя общие `T` в основном определяются по аргументам, есть не столь очевидные крайние случаи, когда `T` не зависит от аргументов:

```tolk
fun tupleLast<T>(self: tuple): T
    asm "LAST";

var last = t.tupleLast();    // error, can not deduce T
```

Чтобы сделать это допустимым, `T` должно быть указано извне:

```tolk
var last: int = t.tupleLast();       // ok, T=int
var last = t.tupleLast<int>();       // ok, T=int
var last = t.tupleLast() as int;     // ok, T=int

someF(t.tupleLast());       // ok, T=(paremeter's declared type)
return t.tupleLast();       // ok if function specifies return type
```

Also note that `T` for asm functions must occupy one stack slot, whereas for a user-defined function, `T` could be of any shape. Otherwise, asm body is unable to handle it properly.

<h3 className="cmp-func-tolk-header">
  ✅ Другое наименование для recv_internal / recv_external
</h3>

```tolk
fun onInternalMessage
fun onExternalMessage
fun onTickTock
fun onSplitPrepare
fun onSplitInstall
```

Все типы параметров и их порядок переименования остаются прежними, меняется только наименование. Также доступен `fun main`.

<h3 className="cmp-func-tolk-header">
  ✅ #include → import. Строгий импорт
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'#include "another.fc";'}</code></td>
    <td><code>{'import "another.tolk"'}</code></td>
  </tr>
  </tbody>
</table>

В Tolk вы не можете использовать символ из `a.tolk` без импорта этого файла. Другими словами, "импортируйте то, что используете".

Все функции stdlib доступны из коробки, загрузка stdlib и `#include "stdlib.fc"` не требуется. Downloading stdlib and `#include "stdlib.fc"` is unnecessary. См. ниже о встроенной stdlib.

По-прежнему существует глобальная область именования. Если `f` объявлено в двух разных файлах, это ошибка. Мы "мпортируем" целый файл, видимость по каждому файлу отсутствует, а ключевое слово `export` теперь поддерживается, но, вероятно, будет поддерживаться в будущем.

<h3 className="cmp-func-tolk-header">
  ✅ #pragma → параметры компилятора
</h3>

В FunC "экспериментальные" функции, такие как `allow-post-modifications`, включались прагмой в файлах .fc (что приводило к проблемам, когда некоторые файлы ее содержали, а некоторые нет). На самом деле, это не прагма для файла, а параметр компиляции.

В Tolk все прагмы были удалены. `allow-post-modification` и `compute-asm-ltr` были объединены в исходники Tolk (как будто они всегда были включены в FunC). Вместо прагм теперь есть возможность передавать экспериментальные параметры.

На данный момент введена одна экспериментальная опция — `remove-unused-functions`, которая не включает неиспользуемые символы в вывод Fift.

`#pragma version xxx` была заменена на `tolk xxx` (без >=, просто строгая версия). Хорошей практикой является указание используемой версии компилятора. Если она не совпадает, Tolk выведет предупреждение.

```tolk
tolk 0.6
```

<h3 className="cmp-func-tolk-header">
  ✅ Позднее разрешение символов. Представление AST
</h3>

В FunC (как и в С) вы не можете получить доступ к функции, объявленной ниже:

```func
int b() { a(); }   ;; error
int a() { ... }    ;; since it's declared below
```

Чтобы избежать ошибки, программист должен сначала создать предварительное объявление. Причина в том, что разрешение символов выполняется прямо во время разбора.

Компилятор Tolk разделяет эти два шага. Сначала он выполняет разбор, а затем разрешение символов. Поэтому фрагмент выше не будет ошибочным.

Звучит просто, но внутренне это очень большая работа. Чтобы сделать это доступным, я ввел промежуточное представление AST, полностью отсутствующее в FunC. Это существенный момент будущих модификаций и выполнения семантического анализа кода.

<h3 className="cmp-func-tolk-header">
  ✅ ключевое слово `null`
</h3>

Создание значений null и проверка переменных на null теперь выглядит очень красиво.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'a = null()'}</code></td>
    <td><code>{'a = null'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (null?(a))'}</code></td>
    <td><code>{'if (a == null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ null?(b))'}</code></td>
    <td><code>{'if (b != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ cell_null?(c))'}</code></td>
    <td><code>{'if (c != null)'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ ключевые слова `throw` и `assert`
</h3>

Tolk значительно упрощает работу с исключениями.

Если в FunC есть `throw()`, `throw_if()`, `throw_arg_if()` и то же самое для unless, то в Tolk есть только два примитива: `throw` и `assert`.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'throw(excNo)'}</code></td>
    <td><code>{'throw excNo'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_arg(arg, excNo)'}</code></td>
    <td><code>{'throw (excNo, arg)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_unless(excNo, condition)'}</code></td>
    <td><code>{'assert(condition, excNo)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_if(excNo, condition)'}</code></td>
    <td><code>{'assert(!condition, excNo)'}</code></td>
  </tr>
  </tbody>
</table>

Обратите внимание, что `!condition` возможно, так как доступно логическое НЕ, см. ниже.

Существует длинный (многословный) синтаксис `assert(condition, excNo)`:

```tolk
assert(condition) throw excNo;
// with possibility to include arg to throw
```

Кроме того, Tolk меняет местами аргументы `catch`: это `catch (excNo, arg)`, оба необязательны (так как arg, скорее всего, пуст).

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'try { } catch (_, _) { }'}</code></td>
    <td><code>{'try { } catch { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (_, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (arg, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo, arg) { }'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `do ... until` → `do ... while`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'do { ... } until (~ condition);'}</code></td>
    <td><code>{'do { ... } while (condition);'}</code></td>
  </tr>
  <tr>
    <td><code>{'do { ... } until (condition);'}</code></td>
    <td><code>{'do { ... } while (!condition);'}</code></td>
  </tr>
  </tbody>
</table>

Обратите внимание, что `!condition` возможно, так как доступно логическое НЕ, см. ниже.

<h3 className="cmp-func-tolk-header">
  ✅ Приоритет операторов стал идентичен C++ / JavaScript
</h3>

В FunC такой код `if (slices_equal() & status == 1)` анализируется как `if( (slices_equal()&status) == 1 )`. Это является причиной различных ошибок в реальных контрактах.

В Tolk `&` имеет более низкий приоритет, идентичный C++ и JavaScript.

Более того, Tolk выдает ошибки при потенциально неправильном использовании операторов, чтобы полностью исключить такие ошибки:

```tolk
if (flags & 0xFF != 0)
```

приведет к ошибке компиляции (похоже на gcc/clang):

```
& has lower precedence than ==, probably this code won't work as you expected.  Use parenthesis: either (... & ...) to evaluate it first, or (... == ...) to suppress this error.
```

Следовательно, код следует переписать:

```tolk
// either to evaluate it first (our case)
if ((flags & 0xFF) != 0)
// or to emphasize the behavior (not our case here)
if (flags & (0xFF != 0))
```

Я также добавил диагностику для распространенной ошибки в операторах сдвига битов: `a << 8 + 1` эквивалентно `a << 9`, вероятно, неожиданно.

```
int result = a << 8 + low_mask;

error: << has lower precedence than +, probably this code won't work as you expected.  Use parenthesis: either (... << ...) to evaluate it first, or (... + ...) to suppress this error.
```

Операторы `~% ^% /% ~/= ^/= ~%= ^%= ~>>= ^>>=` больше не существуют.

<h3 className="cmp-func-tolk-header">
  ✅ Неизменяемые переменные, объявленные через `val`
</h3>

Как в Kotlin: `var` для изменяемых, `val` для неизменяемых, необязательно с указанием типа. В FunC нет аналога `val`.

```tolk
val flags = msgBody.loadMessageFlags();
flags &= 1;         // error, modifying an immutable variable

val cs: slice = c.beginParse();
cs.loadInt(32);     // error, since loadInt() mutates an object
cs.preloadInt(32);  // ok, it's a read-only method
```

Параметры функции изменяемы, но поскольку они копируются по значению, вызываемые аргументы не изменяются. Точно так же, как в FunC, просто для ясности.

```tolk
fun some(x: int) {
    x += 1;
}

val origX = 0;
some(origX);      // origX remains 0

fun processOpIncrease(msgBody: slice) {
    val flags = msgBody.loadInt(32);
    ...
}

processOpIncrease(msgBody);  // by value, not modified
```

В Tolk функция может объявлять параметры `mutate`. Это обобщение функций тильды FunC `~`, читайте ниже.

<h3 className="cmp-func-tolk-header">
  ✅ Удалены устаревшие параметры командной строки
</h3>

Флаги командной строки `-A`, `-P` и другие были удалены. Поведение по умолчанию

```
/path/to/tolk {inputFile}
```

более чем достаточно. Используйте `-v` для печати версии и выхода. Используйте `-h` для всех доступных флагов командной строки.

Можно передать только один входной файл, другие следует `import`.

<h3 className="cmp-func-tolk-header">
  ✅ функции stdlib переименованы в ~~verbose~~ понятные имена, стиль camelCase
</h3>

Все наименования в стандартной библиотеке были пересмотрены. Теперь функции именуются с использованием более длинных, но понятных имен.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'cur_lt()<br>car(l)<br>get_balance().pair_first()<br>raw_reserve(count)<br>dict~idict_add?(...)<br>dict~udict::delete_get_max()<br>t~tpush(triple(x, y, z))<br>s.slice_bits()<br>~dump(x)<br>...'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'getLogicalTime()<br>listGetHead(l)<br>getMyOriginalBalance()<br>reserveToncoinsOnBalance(count)<br>dict.iDictSetIfNotExists(...)<br>dict.uDictDeleteLastAndGet()<br>t.tuplePush([x, y, z])<br>s.getRemainingBitsCount()<br>debugPrint(x)<br>...'}}></code></td>
  </tr>
  </tbody>
</table>

Бывший "stdlib.fc" был разделен на несколько файлов: common.tolk, tvm-dicts.tolk и другие.

Продолжение здесь: [Tolk vs FunC: стандартная библиотека](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).

<h3 className="cmp-func-tolk-header">
  ✅ Логические операторы `&& ||`, логические не `!`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <ol style={{margin: 0}}>
        <li>Загрузить stdlib.fc с GitHub</li>
        <li>Сохранить в свой проект</li>
        <li>`#include "stdlib.fc";`</li>
        <li>Использовать стандартные функции</li>
      </ol>
    </td>
    <td>
      <ol style={{margin: 0}}>
        <li>Использовать стандартные функции</li>
      </ol>
    </td>
  </tr>
  </tbody>
</table>

В Tolk stdlib — часть дистрибутива. Стандартная библиотека неотделима, поскольку сохранение тройки "язык, компилятор, stdlib" вместе — единственный правильный способ поддерживать цикл выпуска.

Это работает таким образом. Компилятор Tolk знает, как найти стандартную библиотеку. Если пользователь установил пакет apt, исходники stdlib также были загружены и существуют на жестком диске, поэтому компилятор находит их по системным путям. Если пользователь использует оболочку WASM, они предоставляются tolk-js. И так далее.

Стандартная библиотека разделена на несколько файлов: `common.tolk` (наиболее распространенные функции), `gas-payments.tolk` (расчет платы за газ), `tvm-dicts.tolk` и другие. Функции из `common.tolk` доступны всегда (компилятор неявно импортирует их). Другие файлы необходимо импортировать явно:

```tolk
import "@stdlib/tvm-dicts"   // ".tolk" optional

...
var dict = createEmptyDict();
dict.iDictSet(...);
```

Помните правило "импортируйте то, что используете", оно также применяется к файлам `@stdlib/...` (за исключением "common.tolk").

Плагин JetBrains IDE автоматически обнаруживает папку stdlib и вставляет необходимые импорты по мере ввода текста.

В будущем компилятор Tolk станет достаточно умным, чтобы переупорядочивать аргументы, ориентируясь на меньшее количество манипуляций со стеком,
но все еще избегая проблемы перемешивания.

В FunC есть только побитовые операторы `~ & | ^`. Разработчики, делающие первые шаги, думая "ладно, никаких логических, я буду использовать побитовые таким же образом", часто делают ошибки, так как поведение операторов совершенно иное:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>`a & b`</th>
    <th>`a && b`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>иногда, идентичны:</td></tr>
  <tr>
    <td><code>{'0 & X = 0'}</code></td>
    <td><code>{'0 & X = 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'-1 & X = -1'}</code></td>
    <td><code>{'-1 & X = -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>но обычно нет:</td></tr>
  <tr>
    <td><code>{'1 & 2 = 0'}</code></td>
    <td><code>{'1 && 2 = -1 (true)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>`~ found`</th>
    <th>`!found`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>иногда, идентичны:</td></tr>
  <tr>
    <td><code>{'true (-1) → false (0)'}</code></td>
    <td><code>{'-1 → 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'false (0) → true (-1)'}</code></td>
    <td><code>{'0 → -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>но обычно нет:</td></tr>
  <tr>
    <td><code>{'1 → -2'}</code></td>
    <td><code>{'1 → 0 (false)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>условие & f()</code></th>
    <th><code>условие && f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> вызывается всегда</td>
    <td><code className="inline">f()</code> вызывается только при выполнении <code className="inline">условия</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>условие | f()</code></th>
    <th><code>условие || f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> вызывается всегда</td>
    <td><code className="inline">f()</code> вызывается только если <code className="inline">условие</code> ложно</td>
  </tr>
  </tbody>
</table>

Tolk поддерживает логические операторы. Они ведут себя так же, как вы привыкли (правый столбец). На данный момент `&&` и `||` иногда создают неоптимальный код Fift, но в будущем компилятор Tolk станет умнее в этом случае. Это незначительно, просто используйте их, как в других языках.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'if (~ found?)'}</code></td>
    <td><code>{'if (!found)'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'if (~ found?) {<br>    if (cs~load_int(32) == 0) {<br>        ...<br>    }<br>}'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'if (!found && cs.loadInt(32) == 0) {<br>    ...<br>}'}}></code></td>
  </tr>
  <tr>
    <td><code>{'ifnot (cell_null?(signatures))'}</code></td>
    <td><code>{'if (signatures != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'elseifnot (eq_checksum)'}</code></td>
    <td><code>{'else if (!eqChecksum)'}</code></td>
  </tr>
  </tbody>
</table>

Ключевые слова `ifnot` и `elseifnot` были удалены, так как теперь у нас есть логическое НЕ (для оптимизации, Компилятор Tolk генерирует `IFNOTJMP`, кстати). Ключевое слово `elseif` было заменено на традиционное `else if`.

Помните, что логическое `true`, преобразованное `как int`, равно -1, а не 1. Это представление TVM.

forall X -> tuple tpush(tuple t, X value) asm "TPUSH";

Use `tensorVar.{i}` to access i-th component of a tensor. Modifying it will change the tensor.

```tolk
var t = (5, someSlice, someBuilder);   // 3 stack slots
t.0         			// 5
t.0 = 10;   			// t is now (10, ...)
t.0 += 1;               // t is now (11, ...)
increment(mutate t.0);  // t is now (12, ...)
t.0.increment();        // t is now (13, ...)

t.1         // slice
t.100500    // compilation error
```

Use `tupleVar.{i}` to access i-th element of a tuple (does INDEX under the hood). Modifying it will change the tuple (does SETINDEX under the hood).

```tolk
var t = [5, someSlice, someBuilder];   // 1 tuple on a stack with 3 items
t.0                     // "0 INDEX", reads 5
t.0 = 10;               // "0 SETINDEX", t is now [10, ...]
t.0 += 1;               // also works: "0 INDEX" to read 10, "0 SETINDEX" to write 11
increment(mutate t.0);  // also, the same way
t.0.increment();        // also, the same way

t.1         // "1 INDEX", it's slice
t.100500    // compilation error
```

It also works for untyped tuples, though the compiler can't guarantee index correctness.

```tolk
var t = createEmptyTuple();
t.tuplePush(5);
t.0                     // will head 5
t.0 = 10                // t will be [10]
t.100500                // will fail at runtime
```

It works for nesting `var.{i}.{j}`. It works for nested tensor, nested tuples, tuples nested into tensors.
It works for `mutate`. It works for globals.

```tolk
t.1.2 = 10;    // "1 INDEX" + "2 SETINDEX" + "1 SETINDEX"
t.1.2 += 10;   // "1 INDEX" + "2 INDEX" + sum + "2 SETINDEX" + "1 SETINDEX"

globalTuple.1.2 += 10;  // "GETGLOB" + ... + "SETGLOB"
```

<h3 className="cmp-func-tolk-header">
  ✅ Type `address`
</h3>

In TVM, all **binary data** is just **a slice.** Same goes for addresses: while TL-B describes the entity `MsgAddress` (internal/external/none/var address),

and TVM assembler has instructions to load/validate addresses, nevertheless: at the low level, it's just a slice.
That's why in FunC's standard library `loadAddress` returned `slice`, and `storeAddress` accepted `slice`.

Tolk introduces the dedicated `address` type. It's still a TVM slice at runtime (internal/external/none),
but it differs from an **abstract slice** from the type system point of view:

1. Integrated with auto-serialization: compiler knows how to pack/unpack it (`LDMSGADDR` and `STSLICE`)
2. Comparable: operators `==` and `!=` work on addresses:

```tolk
if (senderAddress == msg.owner)
```

3. Introspectable: `address.isNone()`, `address.isInternal()`, `address.isExternal()`, `address.getWorkchain()` and `address.getWorkchainAndHash()` (valid for internal addresses)

Passing a slice instead leads to an error:

```tolk
var a: slice = s.loadAddress();  // error, can not assign `address` to `slice`
```

**Embedding a const address into a contract**

Use the built-in `address()` function, which accepts a standard address. In FunC, there was a postfix `"..."a` that returned a slice.

```tolk
address("EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5")
address("0:527964d55cfa6eb731f4bfc07e9d025098097ef8505519e853986279bd8400d8")
```

**Casting `slice` to `address` and vice versa**

If you have a raw slice, which is actually an address, you can cast it via `as` operator.
In practice, this can occur if you've composed an address with a builder, having manually written its binary representation:

```tolk
var b = beginCell()
       .storeUint(0b01)   // addr_extern
       ...;
var s = b.endCell().beginParse();
return s as address;   // `slice` as `address`
```

A reversed cast also is valid: `someAddr as slice` (why would you need it, is an open question, though).

**Different types of addresses**

According to a standard, there are different types of addresses. The most frequently used is a **standard address** — just and address of a smart contract, like `EQ...`. But also, there are **external** and **none** addresses. In a binary TL-B representation,

- `10` (**internal** prefix) + `0` (anycast, always 0) + workchain (8 bits) + hash (256 bits) — that's `EQ...`: it's 267 bits
- `01` (**external** prefix) + len (9 bits) + len bits — external addresses
- `00` (**none** prefix) — address **none**, 2 bits

The `address` type can hold any of these. Most often, it's an internal address. But the type system does not restrict it exactly: this can't be done without heavy runtime checks.

So, if `address` comes from an untrusted input, you should probably validate it:

```tolk
val newOwner = msg.nextOwnerAddress;
assert(newOwner.isInternal()) throw 403;
assert(newOwner.getWorkchain() == BASECHAIN) throw 403;
```

All in all, if you don't trust inputs — you should validate everything: numbers, payload, and addresses particularly.
But if an input comes from a trusted source (your own contract storage, for example) — of course, you can rely on its contents.
The compiler does not insert hidden instructions.
Just remember, that `address` in general can hold all valid types.

<h3 className="cmp-func-tolk-header">
  ✅ stdlib теперь встроен, а не загружается с GitHub
</h3>

Tolk supports type aliases, similar to TypeScript and Rust.
An alias creates a new name for an existing type but **remains interchangeable with it**.

```tolk
type UserId = int32;
type MaybeOwnerHash = bytes32?;

fun calcHash(id: UserId): MaybeOwnerHash { ... }

var id: UserId = 1;       // ok
var num: int = id;        // ok
var h = calcHash(id);
if (h != null) {
    h as slice;           // bytes32 as slice
}
```

t.tuplePush(1);     // detected T=int
t.tuplePush(cs);    // detected T=slice
t.tuplePush(null);  // error, need to specify "null of what type"

Tolk has nullable types: `int?`, `cell?`, and `T?` in general (even for tensors).
Non-nullable types, such as `int` and `cell`, can never hold null values.

The compiler enforces **null safety**: you cannot use nullable types without first checking for null.
Fortunately, these checks integrate smoothly and organically into the code thanks to smart casts.
Smart casts are purely a compile-time feature — they do not consume gas or extra stack space.

```tolk
var value = x > 0 ? 1 : null;  // int?

value + 5;               // error
s.storeInt(value);       // error

if (value != null) {
    value + 5;           // ok, smart cast
    s.storeInt(value);   // ok, smart cast
}
```

Remember that when a variable's type is not specified, it's auto-inferred from the assignment and never changes:

```tolk
Также поддерживается синтаксис `f<int>(...)`:
```

Such a code will not work. You must **explicitly declare the variable as nullable**::

```tolk
// incorrect
var i = null;
if (...) {
    i = 0;     // error
}

// correct
var i: int? = null;
// or
var i = null as int?;
```

Smart casts (similar to TypeScript and Kotlin) make it easier to deal with nullable types, allowing code like this:

```tolk
if (lastCell != null) {
    // here lastCell is `cell`, not `cell?`
}
```

```tolk
if (lastCell == null || prevCell == null) {
    return;
}
// both lastCell and prevCell are `cell`
```

```tolk
var x: int? = ...;
if (x == null) {
    x = random();
}
// here x is `int`
```

```tolk
while (lastCell != null) {
    lastCell = lastCell.beginParse().loadMaybeRef();
}
// here lastCell is 100% null
```

```tolk
t.tuplePush<int>(1);     // ok
t.tuplePush<int>(cs);    // error, can not pass slice to int
t.tuplePush<int>(null);  // ok, null is "null of type int"
```

Note that smart casts don't work for globals; they only work for local vars.

Tolk has the `!` operator (non-null assertion, compile-time only), like `!` in TypeScript and `!!` in Kotlin.
If you are certain that a variable is not null,
this operator allows you to skip the compiler's check.

```tolk
fun doSmth(c: cell);

fun analyzeStorage(nCells: int, lastCell: cell?) {
    if (nCells) {           // then lastCell 100% not null
        doSmth(lastCell!);  // use ! for this fact
    }
}
```

In practice, you'll use this operator working with low-level dicts API.
Tolk will have a high-level `map<K,V>` in the future.
For now, working with dicts will require the `!` operator.

```tolk
// it returns either (slice, true) or (null, false)
@pure
fun dict.iDictGet(self, keyLen: int, key: int): (slice?, bool)
    asm(key self keyLen) "DICTIGET" "NULLSWAPIFNOT";

var (cs, exists) = myDict.iDictGet(...);
// if exists is true, cs is not null
if (exists) {
    cs!.loadInt(32);
}
```

You can also declare **always-throwing functions** that return `never`:

```tolk
fun alwaysThrows(): never {
    throw 123;
}

fun f(x: int) {
    if (x > 0) {
        return x;
    }
    alwaysThrows();
    // no `return` statement needed
}
```

The `never` type implicitly occurs when a condition can never happen:

```tolk
var v = 0;
// prints a warning
if (v == null) {
    // v is `never`
    v + 10;   // error, can not apply `+` `never` and `int`
}
// v is `int` again
```

If you encounter `never` in compilation errors, there is most likely a warning in the preceding code.

Non-atomic nullable are also allowed: `(int, int)?`, `(int?, int?)?`, or even `()?`. Then,
a special _value presence_ stack slot is implicitly added.
It holds `0` if a value is null, and not 0 (currently, -1) if not null:

```tolk
// t: (int, int)?
t = (1, 2);    // 1 2 -1
t = (3, 4);    // 3 4 -1
t = null;      // null null 0

// t: ()?
t = ();         // -1
t = null;       // 0
```

All in all, nullability is a significant step forward for type safety and reliability.
Nullable types eliminate runtime errors, enforcing correct handling of optional values.

some_asm_function(f1(), f2());

Union types allow a variable to hold multiple possible types, similar to TypeScript.

```tolk
fun whatFor(a: bits8 | bits256): slice | UserId { ... }

var result = whatFor(...);  // slice | UserId
```

Nullable types `T?` are now formally `T | null`.
Union types have intersection properties. For instance, `B | C` can be passed/assigned to `A | B | C | D`.

The only way to work with unions from code is **pattern matching**:

```tolk
match (result) {
    slice  => { /* result is smart-casted to slice  */ }
    UserId => { /* result is smart-casted to UserId */ }
}
```

Example:

```tolk
match (result) {
    slice => {
        return result.loadInt(32);
    }
    UserId => {
        if (result < 0) {
            throw 123;
        }
        return loadUser(result).parentId;
    }
}
```

`match` must cover all union cases (should be _exhaustive_). It can also be **used as an expression**:

```tolk
type Pair2 = (int, int);
type Pair3 = (int, int, int);

fun getLast(tensor: Pair2 | Pair3) {
    return match (tensor) {
        Pair2 => tensor.1,
        Pair3 => tensor.2,
    }
}
```

Syntax details:

- commas are optional with {} but required for expressions
- a trailing comma is allowed
- semicolon is not required after `match` used as a statement
- for match-expressions, its arm can terminate, then its type is considered `never`:

```tolk
return match (msg) {
    ...
    CounterReset => throw 403,  // forbidden
}
```

Variable declaration inside `match` is allowed:

```tolk
match (val v = getPair2Or3()) {
    Pair2 => {
        // use v.0 and v.1
    }
    Pair3 => {
        // use v.0, v.1, and v.2
    }
}
```

<details>
<summary>How are union types represented on the stack, at the TVM level?</summary>

Internally, at the TVM level, they are stored as tagged unions, like enums in Rust:

- each type is assigned a unique type ID, which is stored alongside the value
- the union occupies N + 1 stack slots, where N is the maximum size of any type in the union
- a nullable type `T?` is just a union with null (type ID = 0); `int?` and other atomics still use 1 stack slot

```tolk
var v: int | slice;    // 2 stack slots: value and typeID
                       // - int:   (100, 0xF831)
                       // - slice: (CS{...}, 0x29BC)
match (v) {
    int =>     // IF TOP == 0xF831 { ... }
        // v.slot1 contains int, can be used in arithmetics
    slice =>   // ELSE { IF TOP == 0x29BC { ... } }
        // v.slot1 contains slice, can be used to loadInt()
}

fun complex(v: int | slice | (int, int)) {
    // Stack representation:
    // - int:        (null, 100, 0xF831)
    // - slice:      (null, CS{...}, 0x29BC)
    // - (int, int): (200, 300, 0xA119)
}

complex(v);   // passes (null, v.slot1, v.typeid)
complex(5);   // passes (null, 5, 0xF831)
```

</details>

Besides `match`, you can test a union type by `is`. Smart casts work as expected:

```tolk
fun f(v: cell | slice | builder) {
    if (v is cell) {
        v.cellHash();
    } else {
        // v is `slice | builder`
        if (v !is builder) { return; }
        // v is `slice`
        v.sliceHash();
    }
    // v is `cell | slice`
    if (v is int) {
        // v is `never`
        // a warning is also printed, condition is always false
    }
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Pattern matching for expressions (switch-like behavior)
</h3>

`match` can also be used for **constant expressions**, similar to `switch`:

```tolk
val nextValue = match (curValue) {
    1 => 0,
    0 => 1,
    else => -1
};
```

Rules:

- only constant expressions are allowed on the left-hand side (1, SOME_CONST, 2 + 3)
- branches can contain `return` and `throw`
- `else` is required for expression form but optional for statement form:

```tolk
// statement form
match (curValue) {
    1 => { nextValue = 0 }
    0 => { nextValue = 1 }
    -1 => throw NEGATIVE_NOT_ALLOWED
}

// expression form, else branch required
val nextValue = match (curValue) {
    ...
    else => <expression>
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Structures <code>{'struct A { ... }'}</code>
</h3>

Looks like TypeScript — but works in TVM!

```tolk
struct Point {
    x: int;
    y: int;
}

fun calcMaxCoord(p: Point) {
    return p.x > p.y ? p.x : p.y;
}

// declared like a JS object
var p: Point = { x: 10, y: 20 };
calcMaxCoord(p);

// called like a JS object
calcMaxCoord({ x: 10, y: 20 });

// works with shorthand syntax
fun createPoint(x: int, y: int): Point {
    return { x, y };
}
```

- a struct is just **a named tensor**
- `Point` is identical to `(int, int)` at the TVM level
- field access `p.x` works like accessing tensor elements `t.0`, for reading and writing

This means **no bytecode overhead** — you can replace unreadable tensors with clean, structured types.

Fields can be separated by `;` or `,` (both are valid, like in TypeScript). Trailing commas are allowed.

When creating a structure, you can specify `StructName { ... }` or simply `{ ... }` if the type is clear from the context (e.g., return type or assignment):

```tolk
var s: StoredInfo = { counterValue, ... };
var s: (int, StoredInfo) = (0, { counterValue, ... });

// also valid, but not preferred
var s = StoredInfo { counterValue, ... };
```

Default values for fields are supported:

```tolk
struct DefDemo {
    f1: int = 0;
    f2: int? = null;
    f3: (int, coins) = (0, ton("0.05"));
}

var d: DefDemo = {};         // ok
var d: DefDemo = { f2: 5 };  // ok
```

Structs can have methods as extension functions, read below.

Может быть несколько общих параметров:

They exist only at the type level (no runtime cost).

```tolk
struct Container<T> {
    isAllowed: bool;
    element: T?;
}

struct Nothing {}

type Wrapper<T> = Nothing | Container<T>;
```

Example usage:

```tolk
fun checkElement(c: Container<T>) {
    return c.element != null;
}

var c: Container<int32> = { isAllowed: false, element: null };

var v: Wrapper<int> = Nothing {};
var v: Wrapper<int32> = Container { value: 0 };
```

Since it's a generic, you should specify type arguments when using it:

```tolk
fun getItem(c: Container)        // error, specify type arguments
fun getItem(c: Container<int>)   // ok
fun getItem<T>(c: Container<T>)  // ok

var c: Container = { ... }       // error, specify type arguments
var c: Container<int> = { ... }  // ok
```

Компилятор FunC может неожиданно перетасовать аргументы при вызове функции сборки:

```tolk
fun doSmth<T>(value: Container<T>) { ... }

doSmth({ item: 123 });         // T = int
doSmth({ item: cellOrNull });  // T = cell?
```

Demo: `Response<TResult, TError>`:

```tolk
struct Ok<TResult> { result: TResult; }
struct Err<TError> { err: TError; }

type Response<R, E> = Ok<R> | Err<E>;

fun tryLoadMore(slice: slice): Response<cell, int32> {
    return ...
        ? Ok { result: ... }
        : Err { err: ErrorCodes.NO_MORE_REFS };
}

match (val r = tryLoadMore(inMsg)) {
    Ok => { r.result }
    Err => { r.err }
}
```

В будущем, когда будут реализованы структуры и универсальные структуры, вся мощь универсальных функций вступит в игру.

Methods are declared as extension functions, similar to Kotlin.
A method can accept the first `self` parameter (then it's an instance method) or not accept it (then it's a static method).

```tolk
fun Point.getX(self) {
    return self.x
}

fun Point.create(x: int, y: int): Point {
    return { x, y }
}
```

Methods can be created **for any type**, including aliases, unions, and built-in types:

```tolk
fun int.isZero(self) {
    return self == 0;
}

type MyMessage = CounterIncrement | ...;

fun MyMessage.parse(self) { ... }
// this is identical to
// fun (CounterIncrement | ...).parse(self)
```

Methods perfectly work with `asm`, since `self` is just a regular variable:

```tolk
fun tuplePush<T>(mutate self: tuple, value: T): void
    asm "TPUSH";
```

By default, **`self` is immutable**. It means that you can't modify it or call mutating methods.
To make `self` mutable, you should explicitly declare `mutate self`:

```tolk
fun Point.assignX(mutate self, x: int) {
    self.x = x;   // without mutate, an error "modifying immutable object"
}

fun builder.storeInt32(mutate self, v: int32): self {
    return self.storeInt(v, 32);
}
```

Methods for generic structs created seamlessly.
Note, that no extra `<T>` is required: while parsing the receiver type, compiler treats unknown symbols as generic arguments.

```tolk
struct Container<T> {
    item: T;
}

// compiler treats T (unknown symbol) as a generic parameter
fun Container<T>.getItem(self) {
    return self.item;
}

// and this is a specialization for integer containers
fun Container<int>.getItem(self) {
    ...
}
```

Another example:

```tolk
struct Pair<T1, T2> {
    first: T1;
    second: T2;
}

// both <T1,T2>, <A,B>, etc. work: any unknown symbols
fun Pair<A, B>.create(f: A, s: B): Pair<A, B> {
    return {
        first: f,
        second: s,
    }
}
```

Similarly, any unknown symbol (typically, `T`) can be used to make a method accepting anything:

```tolk
// any receiver
fun T.copy(self): T {
    return self;
}

// any nullable receiver
fun T?.isNull(self): bool {
    return self == null;
}
```

When you call `someObj.method()`, multiple methods with the same name may exist and theoretically be acceptable:

```tolk
fun T.copy(self) { ... }
fun int.copy(self) { ... }

someVar.copy();   // ???
```

So, the compiler performs matching to find as precise method as follows:

1. Search for exact type receiver like `int.copy` (most practical cases finish here)
2. Search for non-generic receivers that are acceptable (like `int32.copy` / `int?.copy`)
3. Search for generic receivers except `T` (like `Container<T>.copy`)
4. Search for `T` receivers (`T.copy`)

```tolk
fun int.copy(self) { ... }
fun T.copy(self) { ... }

6.copy()              // int.copy (rule 1)
(6 as int32).copy()   // int.copy (rule 2)
(6 as int32?).copy()  // T.copy with T=int? (rule 4)
```

```tolk
type MyMessage = CounterIncrement | CounterReset;
fun MyMessage.check() { ... }
fun CounterIncrement.check() { ... }

MyMessage{...}.check()         // first (rule 1)
CounterIncrement{...}.check()  // second (rule 1)
CounterReset{...}.check()      // first (rule 2)
```

In case of ambiguity, an error is printed:

```tolk
fun int?.doSmth(self) { ... }
fun int64.doSmth(self) { ... }

var v: int32;
v.doSmth();   // error: no exact match, but two possible acceptable receivers
```

You can assign a generic function to the variable, but you should explicitly specify types:

```tolk
fun genericFn<T>(v: T) { ... }
fun Container<T>.getItem(self) { ... }

var callable1 = genericFn<slice>;
var callable2 = Container<int32>.getItem;
callable2(someContainer32);   // pass it as self
```

<h3 className="cmp-func-tolk-header">
  ✅ Никаких методов тильды `~`, вместо них ключевое слово `mutate`
</h3>

Это изменение настолько велико, что описано на отдельной странице: [Изменчивость Tolk](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability).

<h3 className="cmp-func-tolk-header">
  ✅ Auto-packing to/from cells/builders/slices
</h3>

Having any struct, you can unpack in from a cell or pack and object to a cell:

```tolk
struct Point {
    x: int8;
    y: int8;
}

var value: Point = { x: 10, y: 20 };

// makes a cell containing "0A14"
var c = value.toCell();
// back to { x: 10, y: 20 }
var p = Point.fromCell(c);
```

Continue reading on a separate page: [Auto-packing to/from cells](/v3/documentation/smart-contracts/tolk/tolk-vs-func/pack-to-from-cells).

<h3 className="cmp-func-tolk-header">
  ✅ Universal createMessage: avoid manual cells composition
</h3>

No more manual `beginCell().storeUint(...).storeRef(...)` boilerplate. Just describe the message in a literal, and let the compiler do the rest.

```tolk
val reply = createMessage({
    bounce: false,
    value: ton("0.05"),
    dest: senderAddress,
    body: RequestedInfo { ... }
});
reply.send(SEND_MODE_REGULAR);
```

Continue reading on a separate page: [Universal createMessage](/v3/documentation/smart-contracts/tolk/tolk-vs-func/create-message).

<hr />

<h3>Сравнение потребления газа в Tolk и FunC</h3>

:::tip The same or slightly less
If you transform FunC code line-by-line (for example, using a [converter](https://github.com/ton-blockchain/convert-func-to-tolk)),
you'll have the same results or even a bit better.
:::

Since Tolk is a fork of FunC, part of its core remains unchanged — particularly the stack manipulation logic.
Yes, Tolk is a completely different language, with its own syntax and semantics,
but its low-level internal representation is exactly the same as FunC's.
As a result, the syntax has no impact on gas consumption.
In fact, it's even slightly lower, since the strict type system
gives the compiler more room for optimizations.

However, once Tolk v1.0 is released, it will be significantly more efficient.
Auto-serialized structures, automatic message construction, and other features will be
noticeably cheaper than manual work with builders and slices — almost always.

<Feedback />
