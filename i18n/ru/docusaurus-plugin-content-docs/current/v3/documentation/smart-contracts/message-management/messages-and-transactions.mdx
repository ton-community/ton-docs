import ConceptImage from '@site/src/components/conceptImage';
import ThemedImage from '@theme/ThemedImage';

# Сообщения и транзакции

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

TON – это асинхронный блокчейн со сложной структурой, которая сильно отличается от других блокчейнов. В связи с этим у новых разработчиков часто возникают вопросы о низкоуровневом устройстве в TON. В этой статье мы рассмотрим один из таких вопросов, связанный с доставкой сообщений.

## Что такое сообщение?

Сообщение – это пакет данных, которым обмениваются участники (пользователи, приложения или смарт-контракты). Обычно оно содержит информацию, указывающую получателю, какое действие следует выполнить, например, обновить хранилище или отправить новое сообщение.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_1.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_1_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Работа с таким типом обмена данными напоминает запуск спутника в космос. Хотя мы точно знаем, какое сообщение мы создали, после запуска необходимо наблюдение, чтобы определить результат.

## Что такое транзакция?

Транзакция в TON состоит из следующего:

- входящее сообщение – инициирует запуск контракта (существуют специальные способы запуска)
- действия контракта, вызванные входящим сообщением, например, обновление хранилища контракта (необязательно)
- исходящие сообщения – создаются и отправляются другим участникам (необязательно).

> Технически контракт может быть запущен с помощью специальных функций, таких как [Tick-Tock](/v3/documentation/data-formats/tlb/transaction-layout#tick-tock), но эта функция чаще используется для внутренних контрактов ядра TON Blockchain.
>
> Не каждая транзакция приводит к созданию исходящих сообщений или обновлению хранилища контракта – это зависит от действий, заложенных в коде контракта.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_2.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_2_dark.png?raw=true',
  }}
/>
<br></br>

В асинхронной системе вы не можете получить ответ от целевого смарт-контракта в пределах той же транзакции. Обработка вызова контракта может занять несколько блоков, в зависимости от длины маршрута между источником и местом назначения.

Достижение парадигмы бесконечного шардинга требует полной параллелизации, гарантирующей, что каждая транзакция будет выполняться независимо от других. Поэтому вместо транзакций, которые затрагивают и изменяют состояние многих контрактов одновременно, каждая транзакция в TON выполняется только на одном смарт-контракте, а смарт-контракты обмениваются данными посредством сообщений. Таким образом, смарт-контракты могут взаимодействовать друг с другом только путем вызова их функций с помощью специальных сообщений и последующего получения на них ответа с помощью других сообщений.

Достижение парадигмы бесконечного шардинга требует полной параллелизации, гарантирующей, что каждая транзакция будет выполняться независимо от других. Поэтому вместо транзакций, которые затрагивают и изменяют состояние многих контрактов одновременно, каждая транзакция в TON выполняется только на одном смарт-контракте, а смарт-контракты обмениваются данными посредством сообщений. Таким образом, смарт-контракты могут взаимодействовать друг с другом только путем вызова их функций с помощью специальных сообщений и последующего получения на них ответа с помощью других сообщений.

:::info
Более подробное и точное описание на странице [Transaction Layout](/v3/documentation/data-formats/tlb/transaction-layout).
:::

### Результат транзакции

Существует [код завершения TVM](/v3/documentation/tvm/tvm-exit-codes) для транзакции, которая находилсь в фазе вычисления, и если значение данного кода не равно `0` или `1`, то произошла ошибка.
Также [фаза вычислений TVM может быть пропущена](/v3/documentation/tvm/tvm-overview#compute-phase-skipped), например, из-за отсутствия средств или статуса состояния.

:::info для toncenter api v3
Для определения успешности транзакции следует использовать `tx.description.action.success` && `tx.description.compute_ph.success`:
:::

```json
"transactions": [
    {
      "description": {
        . . . . . . . .
        "action": {
          "valid": true,
          "success": true,
         . . . . . . . .
          },
. . . . . . . .
        "destroyed": false,
        "compute_ph": {
          "mode": 0,
          "type": "vm",
          "success": true,
```

Транзакция может иметь один из трех результатов:

- Success, exit code: `0` или `1` – успешно
- Fail, `aborted: true` – неуспешно, прервано без выполнения
- Fail, [exit code](/v3/documentation/tvm/tvm-exit-codes), `aborted: true` – неуспешно, прервано.

:::info для toncenter api v3
`aborted: true` является полем из Toncenter API, а не полем вывода транзакции
:::

## Что такое логическое время?

Строго гарантируется, что транзакция, являющаяся результатом сообщения, будет иметь _lt_ больше, чем _lt_ сообщения. Аналогично _lt_ сообщения, отправленного в некоторой транзакции, строго больше, чем _lt_ транзакции, которая его вызвала. Сообщения, отправленные с одного аккаунта и транзакции, произошедшие на одном аккаунте, также строго упорядочены.

Строго гарантируется, что транзакция, являющаяся результатом сообщения, будет иметь _lt_ больше, чем _lt_ сообщения. Аналогично _lt_ сообщения, отправленного в некоторой транзакции, строго больше, чем _lt_ транзакции, которая его вызвала. Сообщения, отправленные с одного аккаунта и транзакции, произошедшие на одном аккаунте, также строго упорядочены.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_3.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_3_dark.png?raw=true',
  }}
/>
<br></br>

Благодаря _lt_ мы всегда знаем порядок транзакций, полученных и отправленных сообщений для каждого аккаунта.

Более того, если аккаунт _A_ отправил два сообщения аккаунту _B_, гарантируется, что сообщение с меньшим _lt_ будет обработано раньше:

Если `msg1_lt < msg2_lt` => `tx1_lt < tx2_lt`.

Если `msg1_lt < msg2_lt` => `tx1_lt < tx2_lt`.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_5.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_5_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Для каждого блока мы можем определить _lt_-диапазон, который начинается с первой транзакции и заканчивается _lt_ последнего события в блоке (сообщения или транзакции). Блоки упорядочены так же, как и другие события в TON, поэтому если один блок зависит от другого, он имеет более высокое _lt_. Дочерний блок в шарде имеет более высокое _lt_, чем его родитель. _lt_ мастерчейн-блока выше, чем _lts_ каждого вложенного шард-блока, поскольку мастер-блок зависит от вложенных шард-блоков. Каждый шард-блок содержит упорядоченную ссылку на последний мастер-блок (на момент создания шард-блока), поэтому _lt_ шард-блока выше, чем _lt_ мастер-блока на который они ссылаются.

Для каждого блока мы можем определить _lt_-диапазон, который начинается с первой транзакции и заканчивается _lt_ последнего события в блоке (сообщения или транзакции). Блоки упорядочены так же, как и другие события в TON, поэтому если один блок зависит от другого, он имеет более высокое _lt_. Дочерний блок в шарде имеет более высокое _lt_, чем его родитель. _lt_ мастерчейн-блока выше, чем _lts_ каждого вложенного шард-блока, поскольку мастер-блок зависит от вложенных шард-блоков. Каждый шард-блок содержит упорядоченную ссылку на последний мастер-блок (на момент создания шард-блока), поэтому _lt_ шард-блока выше, чем _lt_ мастер-блока на который они ссылаются.

## Доставка сообщений

К счастью, TON работает таким образом, что любое внутреннее сообщение будет обязательно получено целевым аккаунтом. Сообщение не может потеряться где-то между источником и получателем. С внешними сообщениями дело обстоит немного иначе, поскольку их принятие в блок происходит по усмотрению валидатора. Однако, как только сообщение будет принято в очередь входящих сообщений, оно будет доставлено.

### Порядок доставки

Предположим, что существует два контракта – _A_ и _B_. _A_ получает внешнее сообщение, которое запускает отправку двух внутренних сообщений контракту _B_, назовем их сообщения _1_ и _2_. В этом простом случае мы можем на 100% быть уверены, что сообщение _1_ будет обработано _B_ раньше, чем _2_ поскольку оно имеет меньшее _lt_.

Предположим, что существует два контракта – _A_ и _B_. _A_ получает внешнее сообщение, которое запускает отправку двух внутренних сообщений контракту _B_, назовем их сообщения _1_ и _2_. В этом простом случае мы можем на 100% быть уверены, что сообщение _1_ будет обработано _B_ раньше, чем _2_ поскольку оно имеет меньшее _lt_.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-1.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-1-dark.png?raw=true',
  }}
/>
</div>
<br></br>

Это простой случай, когда у нас только два контракта. Как наша система работает в более сложных случаях?

### Несколько смарт-контрактов

Для большей наглядности предположим, что наши контракты отправляют обратно сообщения `msg1'` и `msg2'` после `msg1` и `msg2`, выполненных контрактами `B` и `C`. В результате `tx2'` и `tx1'` будет применено к контракту `A`.
Есть две возможные трассировки для этих транзакций,

Для большей наглядности предположим, что наши контракты отправляют обратно сообщения `msg1'` и `msg2'` после `msg1` и `msg2`, выполненных контрактами `B` и `C`. В результате `tx2'` и `tx1'` будет применено к контракту `A`.
Есть две возможные трассировки для этих транзакций,

1. Первый возможный порядок – `tx1'_lt < tx2'_lt`:

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_6.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_6_dark.png?raw=true',
  }}
/>
</div>
<br></br>

2. Второй возможный порядок – `tx2'_lt < tx1'_lt`:

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_7.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_7_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Тоже самое происходит и в обратном случае, когда два контракта _B_ и _C_ отправляют сообщение одному контракту _A_. Даже если сообщение `B -> A` было отправлено раньше, чем `C -> A`, мы не можем знать какое из них будет доставлено первым. Маршрут `B -> A` может потребовать большего количества переходов по цепочке шардов.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-3.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-3_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Возможных сценариев взаимодействия смарт-контрактов может быть множество и в любом сценарии с более чем 2 контрактами порядок доставки сообщений может быть произвольным. Единственная гарантия заключается в том, что сообщения от любого контракта _A_ к любому контракту _B_ будут обрабатываться в порядке их логического времени. Некоторые примеры приведены ниже.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-5.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-5_dark.png?raw=true',
  }}
/>
</div>
<br></br>

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-6.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-6-dark.png?raw=true',
  }}
/>
</div>
<br></br>

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-6.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-6-dark.png?raw=true',
  }}
/>
</div>
<br></br>

## Заключение

Асинхронная структура блокчейна TON создает трудности с гарантией доставки сообщений. Логическое время помогает установить порядок событий и транзакций, но не гарантирует порядок доставки сообщений между несколькими смарт-контрактами из-за различий маршрутов в цепочках шардов. Несмотря на эти сложности, TON обеспечивает внутреннюю доставку сообщений, поддерживая надежность сети. Разработчики должны адаптироваться к этим нюансам, чтобы использовать весь потенциал TON для создания инновационных децентрализованных приложений.
