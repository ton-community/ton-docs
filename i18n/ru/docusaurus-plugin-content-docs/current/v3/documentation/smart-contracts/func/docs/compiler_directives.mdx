import Feedback from '@site/src/components/Feedback';

# Директивы компилятора

Это ключевые слова, которые начинаются с `#` и предписывают компилятору выполнить некоторые действия, проверки или изменить параметры.

Эти директивы можно использовать только на самом внешнем уровне (не внутри определения какой-либо функции).

## #include

Директива `#include` позволяет включить другой файл исходного кода FunC, который будет проанализирован вместо include.

**Syntax:**

```func
#include "filename.fc";
```

Files are automatically checked for multiple inclusions. By default, the compiler will ignore redundant inclusions if the same file is included more than once. A warning will be issued if the verbosity level is 2 or higher.

Если во время анализа включенного файла происходит ошибка, дополнительно выводится стек включений с расположением
каждого включенного файла в цепочке.

## #pragma

Директива `#pragma` используется для предоставления компилятору дополнительной информации, выходящей за рамки того, что передает сам язык.

### #pragma version

Pragma Version используется для принудительного применения определенной версии компилятора FunC при компиляции файла.

Версия указывается в формате semver, то есть *a.b.c*, где *a* — основная версия, *b* — дополнительная, а *c* — патч.

* *a* is the major version;
* *b* is the minor version;
* *c* is the patch version.

**Supported comparison operators**

Developers can specify version constraints using the following operators:

* *a.b.c* или *=a.b.c* — требует именно *a.b.c* версию компилятора
* *>a.b.c* — требует, чтобы версия компилятора была выше *a.b.c*,
  * *>=a.b.c* — требует, чтобы версия компилятора была выше или равна *a.b.c*
* *<a.b.c* — требует, чтобы версия компилятора была ниже *a.b.c*,
  * *<=a.b.c* — требует, чтобы версия компилятора была ниже или равна *a.b.c*
* *^a.b.c* — требует, чтобы основная версия компилятора была равна части `a`, а второстепенная — не ниже части `b`,
  * *^a.b* — требует, чтобы основная версия компилятора была равна части *a*, а второстепенная — не ниже части *b*
  * *^a* — требует, чтобы основная версия компилятора была не ниже части *a*

For comparison operators (*=*, *>*, *>=*, *<*, *<=*) , omitted parts default to zero.
For example:

* *>a.b* совпадает с *>a.b.0* (и поэтому НЕ соответствует версии *a.b.0*)
* *<=a* совпадает с *<=a.0.0* (и поэтому НЕ соответствует версии *a.0.1*)
* *^a.b.0* **НЕ** совпадает с *^a.b*

**Examples:**

* Например, *^a.1.2* совпадает с *a.1.3* но не *a.2.3* или *a.1.0*, однако *^a.1* соответствует им всем.
* *^a.1* matches all of them.

Эту директиву можно использовать несколько раз; версия компилятора должна удовлетворять всем предоставленным условиям.

### #pragma not-version

The syntax of `#pragma not-version` is identical to `#pragma version`, but it fails if the specified condition is met.

This directive is applicable for blocking specific compiler versions known to have issues.

### #pragma allow-post-modification

*funC v0.4.1*

По умолчанию запрещено использовать переменную до ее изменения в том же выражении.

For example, the following code **will not compile**:

```func
(x, y) = (ds, ds~load_uint(8))
```

However, this version is **valid**:

```func
(x, y) = (ds~load_uint(8), ds)
```

To override this restriction, use `#pragma allow-post-modification`. This allows variables to be modified after usage in mass assignments and function calls while sub-expressions are still computed **left to right**.

In the following example, `x` will contain the initial value of `ds`:

```func
#pragma allow-post-modification
(x, y) = (ds, ds~load_bits(8)); 
```

Here, in `f(ds, ds~load_bits(8));`:

* The first argument of `f` will contain the initial value of `ds`.
* The second argument will contain the 8-bit-modified value of `ds`.

`#pragma allow-post-modification` работает только для кода после директивы.

### #pragma compute-asm-ltr

*funC v0.4.1*

`asm` declarations can override the order of argument evaluation. For example, in the following expression:

```func
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref())
```

The execution order is:

1. `load_ref()`
2. `load_uint(256)`
3. `load_dict()`
4. `load_uint(8)`

This happens due to the corresponding `asm` declaration:

```func
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
```

Here, the `asm(value index dict key_len)` notation dictates a reordering of arguments.

To ensure strict left-to-right computation order, use `#pragma compute-asm-ltr`. With this directive enabled, the same function call:

```func
#pragma compute-asm-ltr
...
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref());
```

will be evaluated in the following order:

1. `load_dict()`
2. `load_uint(8)`
3. `load_uint(256)`
4. `load_ref()`

All `asm` reordering will occur only after computation.

`#pragma compute-asm-ltr` работает только для кода после директивы.

**Note:** `#pragma compute-asm-ltr` applies only to the code after the directive in the file.

<Feedback />
