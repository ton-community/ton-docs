---
toc_min_heading_level: 2
toc_max_heading_level: 6
---

import Feedback from "@site/src/components/Feedback";

# Стандартная библиотека FunC

:::info
В этом разделе обсуждается библиотека [stdlib.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc) со стандартными функциями, используемыми в FunC.
:::

В настоящее время библиотека является просто оберткой для наиболее распространенного ассемблера команд TVM, которые не являются встроенными.
Описание каждой команды TVM, используемой в библиотеке, можно найти в разделе [документация TVM](/v3/documentation/tvm/tvm-overview).
Некоторые описания были взяты для этого документа.

Некоторые функции в файле закомментированы. Это означает, что они уже стали встроенными в целях оптимизации.
Однако сигнатура типа и семантика остаются прежними.

Обратите внимание, что некоторые менее распространенные команды не представлены в stdlib. Они также будут добавлены в будущем.

## Примитивы для манипулирования кортежами

Most function names and types in this section are self-explanatory.
См. [полиморфизм с forall](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall) для получения дополнительной информации о полиморфных функциях.

Обратите внимание, что в настоящее время значения атомарного типа `tuple` не могут быть преобразованы в составные типы кортежей (например, `[int, cell]`) и наоборот.

### Списки в стиле Lisp

Списки могут быть представлены как вложенные кортежи из 2 элементов. Пустой список традиционно представляется как значение TVM `null` (его можно получить, вызвав `null()`). Например, кортеж `(1, (2, (3, null)))` представляет список `[1, 2, 3]`. Элементы списка могут быть разных типов.

Lists in FunC are represented as nested two-element tuples. An empty list is conventionally represented by the TVM `null` value, which can be obtained using `null()`.
For example, the tuple `(1, (2, (3, null)))` corresponds to the list `[1, 2, 3]`. Lists in FunC can contain elements of different types.

#### cons

```func
forall X -> tuple cons(X head, tuple tail) asm "CONS";
```

Добавляет элемент в начало списка в стиле lisp.

#### uncons

```func
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";
```

Извлекает начало и конец списка в стиле lisp.

#### list_next

```func
forall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) "UNCONS";
```

Извлекает начало и конец списка в стиле lisp. Может использоваться как [(не)модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#methods-calls).

**Example**

```func
() foo(tuple xs) {
    (_, int x) = xs.list_next(); ;; get the first element, `_` means do not use tail list
    int y = xs~list_next(); ;; pop the first element
    int z = xs~list_next(); ;; pop the second element
}
```

#### car

```func
forall X -> X car(tuple list) asm "CAR";
```

Возвращает начало списка в стиле lisp.

#### cdr

```func
tuple cdr(tuple list) asm "CDR";
```

Возвращает конец списка в стиле lisp.

### Другие примитивы кортежа

#### empty_tuple

```func
tuple empty_tuple() asm "NIL";
```

Создает кортеж из 0 элементов.

#### tpush

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
```

Добавляет значение `x` к `Tuple t = (x1, ..., xn)`, но только если полученный `Tuple t' = (x1, ..., xn, x)` не длиннее 255 символов. В противном случае выдается исключение проверки типа.

#### single

```func
forall X -> [X] single(X x) asm "SINGLE";
```

Creates a tuple with a single element—singleton

#### unsingle

```func
forall X -> X unsingle([X] t) asm "UNSINGLE";
```

Распаковывает одиночку.

#### pair

```func
forall X, Y -> [X, Y] pair(X x, Y y) asm "PAIR";
```

Creates a two-element tuple (pair).

#### unpair

```func
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";
```

Unpacks a pair into two separate values.

#### triple

```func
forall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm "TRIPLE";
```

Создает тройку.

#### untriple

```func
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";
```

Unpacks a triple into three separate values.

#### tuple4

```func
forall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";
```

Создает кортеж из 4 элементов.

#### untuple4

```func
forall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm "4 UNTUPLE";
```

Распаковывает кортеж из 4 элементов.

_Tuple element access_

#### first

```func
forall X -> X first(tuple t) asm "FIRST";
```

Возвращает второй элемент кортежа.

#### second

```func
forall X -> X second(tuple t) asm "SECOND";
```

Возвращает третий элемент кортежа.

#### third

```func
forall X -> X third(tuple t) asm "THIRD";
```

Возвращает четвертый элемент кортежа.

#### fourth

```func
forall X -> X fourth(tuple t) asm "3 INDEX";
```

Возвращает первый элемент пары.

_Pair and triple element access_

#### pair_first

```func
forall X, Y -> X pair_first([X, Y] p) asm "FIRST";
```

Возвращает первый элемент кортежа.

#### pair_second

```func
forall X, Y -> Y pair_second([X, Y] p) asm "SECOND";
```

Возвращает второй элемент пары.

#### triple_first

```func
forall X, Y, Z -> X triple_first([X, Y, Z] p) asm "FIRST";
```

Возвращает первый элемент тройки.

#### triple_second

```func
forall X, Y, Z -> Y triple_second([X, Y, Z] p) asm "SECOND";
```

Возвращает второй элемент тройки.

#### triple_third

```func
forall X, Y, Z -> Z triple_third([X, Y, Z] p) asm "THIRD";
```

Возвращает третий элемент тройки.

## Примитивы, специфичные для домена

### Извлечение информации из c7

Некоторые полезные сведения о вызове смарт-контракта можно найти в [специальном регистре c7](/v3/documentation/tvm/tvm-overview#control-registers).
Эти примитивы служат для удобного извлечения данных.

#### now

```func
int now() asm "NOW";
```

Возвращает текущее время Unix как целое число

#### my_address

```func
slice my_address() asm "MYADDR";
```

Возвращает внутренний адрес текущего смарт-контракта как срез с `MsgAddressInt`. При необходимости его можно проанализировать далее с помощью примитивов, таких как `parse_std_addr`.

#### get_balance

```func
[int, cell] get_balance() asm "BALANCE";
```

Returns the smart contract's balance as a `tuple`:

- `int`: The remaining balance in nanotoncoins.
- Возвращает оставшийся баланс смарт-контракта в виде `tuple`, состоящего из `int` (оставшийся баланс в nanotoncoin) и `cell` (словарь с 32-битными ключами, представляющими баланс "дополнительных валют").

Поскольку это произойдет в фазе вычислений, баланс контракта будет включать входящее сообщение `value`, вычитать `storage_fee` и `import_fee`.

:::warning
Необработанные примитивы, такие как `send_raw_message`, не обновляют это поле.
:::

#### cur_lt

```func
int cur_lt() asm "LTIME";
```

Возвращает логическое время текущей транзакции.

#### block_lt

```func
int block_lt() asm "BLOCKLT";
```

Возвращает начальное логическое время текущего
блока.

#### config_param

```func
cell config_param(int x) asm "CONFIGOPTPARAM";
```

Возвращает значение глобального параметра конфигурации с целочисленным индексом `i` как `cell` или `null` значение.

#### my_code

```func
cell my_code() asm "MYCODE";
```

Retrieves the smart contract's code from `c7`.

:::warning
This function is not included in the standard library, but is often sought by developers.
You need to manually add initialization it to your contract system, with the `asm` word specified as shown in the snippet above.
:::

### Хэши

#### cell_hash

```func
int cell_hash(cell c) asm "HASHCU";
```

Вычисляет хэш представления `cell c` и возвращает его как 256-битное беззнаковое целое число `x`.
Полезно для подписи и проверки подписей произвольных сущностей, представленных деревом ячеек.

#### slice_hash

```func
int slice_hash(slice s) asm "HASHSU";
```

Вычисляет хэш `slice s` и возвращает его как 256-битное целое число без знака `x`.
Результат такой же, как если бы была создана обычная ячейка, содержащая только данные и ссылки из `s`, и ее хэш был вычислен `cell_hash`.

#### string_hash

```func
int string_hash(slice s) asm "SHA256U";
```

Вычисляет sha256 бит данных `slice s`.
Если длина бит `s` не делится на восемь, выдается исключение потери значимости ячейки.
Значение хэша возвращается как 256-битное целое число без знака `x`.

### Проверка подписи

#### check_signature

```func
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
```

Checks whether the given `signature` is a valid Ed25519 signature of the provided
`hash` using the specified `public key`. Проверяет `signature` Ed25519 для `hash` (256-битное беззнаковое целое число, обычно вычисляемое как хэш некоторых данных) с помощью `public_key` (также представленного 256-битным беззнаковым целым числом). Подпись должна содержать не менее 512 бит данных; используются только первые 512 бит.
Если подпись действительна, результат равен `-1`; в противном случае это `0`.

Обратите внимание, что `CHKSIGNU` создает 256-битный срез с хешем и вызывает `CHKSIGNS`.
То есть, если `hash` вычисляется как хеш некоторых данных, эти данные хешируются _дважды_, второе хеширование происходит внутри `CHKSIGNS`.

#### check_data_signature

```func
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";
```

Проверяет, является ли `signature` допустимой подписью Ed25519 части данных `slice data`, используя `public_key`, аналогично `check_signature`.
Если длина бит `data` не делится на восемь, выдается исключение переполнения ячейки.
Проверка подписей Ed25519 является стандартной, с использованием sha256 для сокращения `data` до 256-битного числа, которое фактически подписано.

### Вычисление размера boc

Приведенные ниже примитивы могут быть полезны для расчета платы за хранение предоставленных пользователем данных.

#### compute_data_size?

```func
(int, int, int, int) compute_data_size?(cell c, int max_cells) asm "CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Возвращает `(x, y, z, -1)` или `(null, null, null, 0)`. Рекурсивно вычисляет количество отдельных ячеек `x`, битов данных `y` и ссылок на ячейки `z` в DAG с корнем `cell c`, фактически возвращая общее хранилище, используемое этим DAG, с учетом идентификации равных ячеек. This provides the total storage used by the DAG while recognizing identical cells.

Возвращает глубину ячейки `c`.
Если у `c` нет ссылок, то возвращает `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `c`. Если `c` является `null` вместо ячейки, возвращается ноль.

#### slice_compute_data_size?

```func
(int, int, int, int) slice_compute_data_size?(slice s, int max_cells) asm "SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Аналогично `compute_data_size?`, но принимает `slice s` вместо `cell`. Возвращаемое значение `x` не учитывает ячейку, содержащую сам срез `s`; однако биты данных и ссылки на ячейки `s` учитываются в `y` и `z`.

#### compute_data_size

```func
(int, int, int) compute_data_size(cell c, int max_cells) impure asm "CDATASIZE";
```

Не тихая версия `compute_data_size?`, которая выдает исключение переполнения ячейки (8) при сбое.

#### slice_compute_data_size

```func
(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm "SDATASIZE";
```

Не тихая версия `slice_compute_data_size?`, которая выдает исключение переполнения ячейки (8) при сбое.

### Сохранение и загрузка постоянного хранилища

#### get_data

```func
cell get_data() asm "c4 PUSH";
```

Возвращает ячейку постоянного хранилища контракта. Позже ее можно проанализировать или изменить с помощью примитивов среза и конструктора.

#### set_data

```func
() set_data(cell c) impure asm "c4 POP";
```

Устанавливает ячейку `c` как постоянные данные контракта. Вы можете обновить постоянное хранилище контракта с помощью этого примитива.

### Примитивы продолжения

#### get_c3

```func
cont get_c3() impure asm "c3 PUSH";
```

Обычно `c3` имеет продолжение, инициализированное всем кодом контракта.
Оно используется для вызовов функций.
Примитив возвращает текущее значение `c3`.

#### set_c3

```func
() set_c3(cont c) impure asm "c3 POP";
```

Обновляет текущее значение `c3`. Обычно используется для обновления кода смарт-контракта во время выполнения. The current code and function call stack remain unchanged, but future function calls use the updated code.

#### bless

```func
cont bless(slice s) impure asm "BLESS";
```

Преобразует `slice s` в простое обычное продолжение `c` с `c.code = s`, пустым стеком и списком сохранения.

### Примитивы, связанные с газом

#### accept_message

```func
() accept_message() impure asm "ACCEPT";
```

Устанавливает текущий лимит газа `gl` на максимально допустимое значение `gm` и сбрасывает газовый кредит `gc` на ноль, уменьшая значение `gr` на `gc` в процессе.
At the same time, it deducts the previous gas credit `gc` from the remaining gas reserve `gr`.
Другими словами, текущий смарт-контракт соглашается купить немного газа, чтобы завершить текущую транзакцию.
Это действие требуется для обработки внешних сообщений, которые не несут никакой ценности (следовательно, нет газа).

Говорят, что примитив загружает некоторые данные, если он возвращает только данные (его можно использовать как [немодифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods)).

#### set_gas_limit

```func
() set_gas_limit(int limit) impure asm "SETGASLIMIT";
```

Устанавливает текущий лимит газа `gl` на минимальное значение `limit` и `gm` и сбрасывает газовый кредит `gc` на ноль.
It also resets the gas credit `gc` to zero. В этот момент, если количество потребленного газа (включая текущую инструкцию) превышает результирующее значение `gl`, перед установкой новых лимитов газа выдается (необработанное) исключение отсутствия газа.

Обратите внимание, что `set_gas_limit` с аргументом `limit ≥ 2^63 − 1` эквивалентно `accept_message`.

Для получения более подробной информации проверьте [accept_message effects](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects)

#### commit

```func
() commit() impure asm "COMMIT";
```

Фиксирует текущее состояние регистров `c4` ("постоянные данные") и `c5` ("действия"), так что текущее выполнение считается "успешным" с сохраненными значениями, даже если позже выдается исключение.

#### buy_gas

```func
() buy_gas(int gram) impure asm "BUYGAS";
```

:::caution
Код операции `BUYGAS` в настоящее время не реализован
:::

Вычисляет количество газа, которое можно купить за `gram` nanotoncoin, и устанавливает `gl` соответственно так же, как `set_gas_limit`.

### Примитивы действий

#### raw_reserve

```func
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
```

Создает выходное действие, которое зарезервирует ровно `amount` nanotoncoin (если `mode = 0`), максимум `amount` nanotoncoin (если `mode = 2`) или все, кроме `amount` nanotoncoin (если `mode = 1` или `mode = 3`) из оставшегося баланса на аккаунте.
The behavior depends on the `mode` parameter:

- If `mode = 0`, exactly the `amount` of nanotoncoins is reserved.
- If `mode = 2`, up to the `amount` of nanotoncoins is reserved.
- If `mode = 1` or `mode = 3`, all but the `amount` of nanotoncoins is reserved.

Это примерно эквивалентно созданию исходящего сообщения, переносящего `amount` nanotoncoin (или `b − amount` nanotoncoin, где `b` — оставшийся баланс) самому себе, так что последующие выходные действия не смогут потратить больше денег, чем остаток. This ensures that subsequent output actions cannot exceed the remaining funds.

**Mode Flags**

- **Bit +2** in `mode`: prevents failure if the specified `amount` cannot be reserved. Instead, the entire remaining balance is reserved.
- Бит +8 в `mode` означает `amount <- -amount` перед выполнением любых дальнейших действий.
- Бит +4 в `mode` означает, что `amount` увеличивается на исходный баланс текущего аккаунта (до фазы вычислений), включая все дополнительные валюты перед выполнением любых других проверок и действий.

**Constraints**

- The `amount` must be a non-negative integer.
- `mode` must be within the range `0..15`.

#### raw_reserve_extra

```func
() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm "RAWRESERVEX";
```

Похоже на `raw_reserve`, но также принимает словарь `extra_amount` (представленный `cell` или `null`) с дополнительными валютами.
Таким образом, можно зарезервировать валюты, отличные от Toncoin.

#### send_raw_message

```func
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
```

This function sends a raw message stored in `msg`. This message must contain a properly serialized `Message X` object, with a few exceptions.
The source address can have a dummy value `addr_none`, which the current smart contract address will automatically replace. The fields `ihr_fee`, `fwd_fee`, `created_lt`, and `created_at` can hold arbitrary values, as they will be updated with the correct ones during the action phase of the transaction. Целочисленный параметр `mode` содержит флаги.

В настоящее время существует 3 режима и 4 флага для сообщений.
Вы можете объединить один режим с несколькими (возможно, ни одним) флагами, чтобы получить требуемый `mode`.
Комбинация просто означает получение суммы их значений. Таблица с описаниями режимов и флагов приведена ниже.

| Режим  | Описание                                                                                                                                  |
| :----- | :---------------------------------------------------------------------------------------------------------------------------------------- |
| `0`    | Обычное сообщение                                                                                                                         |
| `64`   | Перенести всю оставшуюся стоимость входящего сообщения в дополнение к стоимости, изначально указанной в новом сообщении                   |
| `128`  | Перенести весь оставшийся баланс текущего смарт-контракта вместо стоимости, изначально указанной в сообщении                              |

| Флаг  | Описание                                                                                                                    |
| :---- | :-------------------------------------------------------------------------------------------------------------------------- |
| `+1`  | Оплатить комиссию за перевод отдельно от стоимости сообщения                                                                |
| `+2`  | Игнорировать некоторые ошибки, возникающие при обработке этого сообщения на этапе действия (см. примечание ниже)            |
| `+16` | В случае сбоя действия — возврат транзакции. Никакого эффекта, если используется `+2`.                                      |
| `+32` | Текущий аккаунт должен быть уничтожен, если его результирующий баланс равен нулю (часто используется с режимом 128)         |

:::info +2 флага

1. Недостаточно Toncoin:
   - Недостаточно стоимости для перевода с сообщением (вся стоимость входящего сообщения была израсходована).
   - Недостаточно средств для обработки сообщения.
   - Недостаточно стоимости, прикрепленной к сообщению, для оплаты комиссий за пересылку.
   - Недостаточно дополнительной валюты для отправки с сообщением.
   - Недостаточно средств для оплаты исходящего внешнего сообщения.
2. Сообщение слишком большое (проверьте [размер сообщения](/v3/documentation/smart-contracts/message-management/sending-messages#message-size) для получения дополнительной информации).
3. Сообщение имеет слишком большую глубину Меркла.

Однако он не игнорирует ошибки в следующих сценариях:

1. Сообщение имеет недопустимый формат.
2. Режим сообщения включает как 64, так и 128 модификаций.
3. Исходящее сообщение имеет недопустимые библиотеки в StateInit.
4. **Флаг +2** - важно во внешних сообщениях (например, на кошельках).
   :::

:::warning

1. **Флаг +16** - не использовать во внешних сообщениях (например, на кошельках), так как нет отправителя, который мог бы получить отклоненное сообщение.
2. **+2 flag** is important in external messages (e.g., to wallets).
   :::

Вы можете увидеть подробный пример [здесь](/v3/documentation/smart-contracts/message-management/sending-messages#example-with-use-cases).

#### set_code

```func
() set_code(cell new_code) impure asm "SETCODE";
```

Создает выходное действие, которое изменит этот код смарт-контракта на тот, который задан ячейкой `new_code`.
Обратите внимание, что это изменение вступит в силу только после успешного завершения текущего выполнения смарт-контракта.
(Ср. [set_c3](/v3/documentation/smart-contracts/func/docs/stdlib#set_c3))

### Примитивы генератора случайных чисел

Генератор псевдослучайных чисел использует случайное начальное число, беззнаковое 256-битное целое число и (иногда) другие данные, хранящиеся в [c7](/v3/documentation/tvm/tvm-overview#control-registers).
Начальное значение случайного начального числа перед выполнением смарт-контракта в блокчейне TON представляет собой хэш адреса смарт-контракта и глобального случайного начального числа блока. Если внутри блока есть несколько запусков одного и того же смарт-контракта, то все эти запуски будут иметь одинаковое случайное начальное число. Это можно исправить, например, запустив `randomize_lt` перед первым использованием генератора псевдослучайных чисел.

:::caution
Keep in mind that random numbers generated by the functions below can be predicted if you do not use additional tricks.

- [Генерация случайных чисел](/v3/guidelines/smart-contracts/security/random-number-generation)

:::

#### random

```func
int random() impure asm "RANDU256";
```

Генерирует новое псевдослучайное целое число без знака длиной 256 бит `x`. The process works as follows:

- Все перечисленные ниже примитивы сначала проверяют, достаточно ли места в `builder`, а затем диапазон сериализуемого значения.
- Compute `sha512(r)`.
- The first 32 bytes of the hash become the new seed `r'`.
- The remaining 32 bytes are returned as the new random value `x`.

#### rand

```func
int rand(int range) impure asm "RAND";
```

Генерирует новое псевдослучайное целое число `z` в диапазоне `0..range−1` (или `range..−1`, если `range < 0`). Точнее, генерируется случайное значение `x` без знака, как в `random`; затем `z := x * range / 2^256` вычисляется.

Produces a pseudo-random integer `z` within the range `0..range−1` (or `range..−1` if `range < 0`).

- First, an unsigned random value `x` is generated using `random()`.
- Then, `z := x * range / 2^256` is calculated.

#### get_seed

```func
int get_seed() impure asm "RANDSEED";
```

Возвращает текущее случайное начальное число как беззнаковое 256-битное целое число.

#### set_seed

```func
int set_seed(int seed) impure asm "SETRAND";
```

Устанавливает случайное начальное число как беззнаковое 256-битное `seed`.

#### randomize

```func
() randomize(int x) impure asm "ADDRAND";
```

Смешивает беззнаковое 256-битное целое число `x` со случайным начальным числом `r`, устанавливая для случайного начального значения значение sha256 для объединения двух 32-байтовых строк: первая с представлением старого начального значения числа `r`, а вторая с представлением значения в порядке возрастания `x`.

Если не указано иное, примитивы загрузки и предзагрузки считывают данные из префикса фрагмента.

- `r` is the previous seed, represented as a 32-byte big-endian array.
- `x` is also converted into a 32-byte big-endian array.
  T- he new seed is the SHA-256 hash of their concatenation.

#### randomize_lt

```func
() randomize_lt() impure asm "LTIME" "ADDRAND";
```

Эквивалентно `randomize(cur_lt());`.

### Примитивы манипуляции адресами

Примитивы манипуляции адресами, перечисленные ниже, сериализуют и десериализуют значения в соответствии со следующей схемой TL-B.

```func
addr_none$00 = MsgAddressExt;

addr_extern$01 len:(## 8) external_address:(bits len)
             = MsgAddressExt;

anycast_info$_ depth:(#<= 30) { depth >= 1 }
  rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
  workchain_id:int8 address:bits256 = MsgAddressInt;

addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
  workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
```

- `addr_none` представлен как `t = (0)`, т. е. кортеж, содержащий ровно одно целое число, равное нулю
- `addr_extern` представлен как `t = (1, s)`, где срез `s` содержит
  поле `external_address`. Другими словами, `t` - это пара (кортеж, состоящий из двух записей), содержащая целое число, равное единице, и срез `s`
- `addr_std` представлен как `t = (2, u, x, s)`, где `u` - это либо `null` (если `anycast` отсутствует), либо срез `s'`, содержащий `rewrite_pfx` (если `anycast` присутствует). Далее, целое число `x` является `workchain_id`, а срез `s` содержит адрес
- `addr_var` представлено как `t = (3, u, x, s)`, где `u`, `x` и `s` имеют то же значение, что и для `addr_std`

Десериализованный `MsgAddress` представлен кортежем `t` следующим образом:

- `addr_none` is represented as `t = (0)`, a single-element tuple where the integer is zero.
- `addr_extern` is represented as `t = (1, s)`, where `s` is a slice containing `external_address`. In other words, `t` is a pair with the first element being `1` and the second being `s`.
- Внешнее сообщение не является обычным или включает флаг +16 или +32 или оба
  :::
  - `u` is `null` if `anycast` is absent or a slice `s'` containing `rewrite_pfx` if `anycast` is present.
  - `x` is the `workchain_id`.
  - `s` is a slice containing the address.
- Аналоги конструктора

#### load_msg_addr

```func
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
```

Загружает из `slice s` единственный префикс, который является допустимым `MsgAddress`, и возвращает как этот префикс `s'`, так и остаток `s''` от `s` в виде срезов.

#### parse_addr

```func
tuple parse_addr(slice s) asm "PARSEMSGADDR";
```

Раскладывает `slice s`, содержащий допустимый `MsgAddress`, на `tuple t` с отдельными полями этого `MsgAddress`. Если `s` не является допустимым `MsgAddress`, выдается исключение десериализации ячейки.

#### parse_std_addr

```func
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";
```

Анализирует срез `s`, содержащий допустимый `MsgAddressInt` (обычно `msg_addr_std`), применяет перезапись из `anycast` (если присутствует) к префиксу адреса той же длины и возвращает как воркчейн, так и 256-битный адрес в виде целых чисел. Если адрес не 256-битный или если `s` не является допустимой сериализацией `MsgAddressInt`, выдает исключение `deserialization` ячейки.

#### parse_var_addr

```func
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";
```

Вариант `parse_std_addr`, который возвращает (переписанный) адрес как срез `s`, даже если его длина не точно 256 бит (представлено `msg_addr_var`).

## Примитивы отладки

Примитивы отладки можно использовать для проверки состояния различных переменных во время выполнения тестов или консольных скриптов.

#### ~dump

```func
forall X -> () ~dump(X value) impure asm "s0 DUMP";
```

Выводит значение. Несколько значений можно вывести как кортеж, например `~dump([v1, v2, v3])`.

#### ~strdump

```func
() ~strdump(slice str) impure asm "STRDUMP";
```

Выводит строку. Длина бит параметра среза должна делиться на 8.

#### dump_stack

```func
() dump_stack() impure asm "DUMPSTK";
```

Выводит стек (максимум 255 верхних значений) и показывает общую глубину стека.

## Примитивы среза

A primitive _loads_ data when it returns both the extracted data and the remainder of the slice.
It can be used as a [modifying method](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods).
A primitive _preloads_ data when it returns only the extracted data, leaving the original slice unchanged. Его можно использовать как [немодифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods).
Unless specified otherwise, loading and preloading primitives read data from the beginning of the slice.

#### begin_parse

```func
slice begin_parse(cell c) asm "CTOS";
```

Преобразует `cell` в `slice`. The input `c` must be either an ordinary or exotic cell.
See [TVM.pdf](https://ton.org/tvm.pdf), 3.1.2. If `c` is exotic, it is automatically converted into an ordinary cell `c'`
before being transformed into a `slice`.

#### end_parse

```func
() end_parse(slice s) impure asm "ENDS";
```

Проверяет, является ли `s` пустым. Если нет, выдает исключение.

#### load_ref

```func
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
```

Загружает первую ссылку из среза.

#### preload_ref

```func
cell preload_ref(slice s) asm "PLDREF";
```

Предварительно загружает первую ссылку из среза.

#### load_int

```func
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
```

Загружает знаковое `len`-битное целое число из среза.

#### load_uint

```func
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
```

Загружает беззнаковое `len`-битное целое число из среза.

#### preload_int

```func
;; int preload_int(slice s, int len) asm "PLDIX";
```

Предварительно загружает знаковое `len`-битное целое число из среза.

#### preload_uint

```func
;; int preload_uint(slice s, int len) asm "PLDUX";
```

Предварительно загружает беззнаковое `len`-битное целое число из среза.

#### load_bits

```func
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
```

Загружает первые `0 ≤ len ≤ 1023` бит из среза `s` в отдельный срез `s''`.

#### preload_bits

```func
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";
```

Предварительно загружает первые `0 ≤ len ≤ 1023` бит из slice `s` в отдельный slice `s''`.

#### load_coins

```func
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
```

Загружает сериализованное количество Toncoin (любое беззнаковое целое число до `2^120 - 1`).

#### skip_bits

```func
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
```

Возвращает все, кроме первых `0 ≤ len ≤ 1023` бит `s`.

#### first_bits

```func
slice first_bits(slice s, int len) asm "SDCUTFIRST";
```

Возвращает первые `0 ≤ len ≤ 1023` бит `s`.

#### skip_last_bits

```func
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";
```

Возвращает все, кроме последних `0 ≤ len ≤ 1023` бит `s`.

#### slice_last

```func
slice slice_last(slice s, int len) asm "SDCUTLAST";
```

Возвращает последние `0 ≤ len ≤ 1023` бит `s`.

#### load_dict

```func
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";
```

Загружает словарь `D` из среза `s`. Может применяться к словарям или к значениям произвольных типов `Maybe ^Y` (возвращает `null`, если используется конструктор `nothing`).

#### preload_dict

```func
cell preload_dict(slice s) asm "PLDDICT";
```

Предварительно загружает словарь `D` из среза `s`.

#### skip_dict

```func
slice skip_dict(slice s) asm "SKIPDICT";
```

Загружает словарь как `load_dict`, но возвращает только остаток среза.

### Примитивы размера среза

#### slice_refs

```func
int slice_refs(slice s) asm "SREFS";
```

Возвращает количество ссылок в срезе `s`.

#### slice_bits

```func
int slice_bits(slice s) asm "SBITS";
```

Возвращает количество бит данных в срезе `s`.

#### slice_bits_refs

```func
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
```

Возвращает как количество бит данных, так и количество ссылок в `s`.

#### slice_empty?

```func
int slice_empty?(slice s) asm "SEMPTY";
```

Проверяет, является ли срез `s` пустым (т. е. не содержит бит данных и ссылок на ячейки).

#### slice_data_empty?

```func
int slice_data_empty?(slice s) asm "SDEMPTY";
```

Проверяет, нет ли в срезе `s` битов данных.

#### slice_refs_empty?

```func
int slice_refs_empty?(slice s) asm "SREMPTY";
```

Проверяет, нет ли в срезе `s` ссылок.

#### slice_depth

```func
int slice_depth(slice s) asm "SDEPTH";
```

Возвращает глубину среза `s`.
Если в `s` нет ссылок, то возвращается `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `s`.

## Builder primitives

Говорят, что примитив _сохраняет_ значение `x` в конструкторе `b`, если он возвращает измененную версию конструктора `b'` со значением `x`, сохраненным в конце. It can also be used as a [non-modifying method](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods).
Each of the following primitives first checks for enough space in the `builder` and then verifies the range of the serialized value.

#### begin_cell

```func
builder begin_cell() asm "NEWC";
```

Создает новый пустой `builder`.

#### end_cell

```func
cell end_cell(builder b) asm "ENDC";
```

Преобразует `builder` в обычную `cell`.

#### store_ref

```func
builder store_ref(builder b, cell c) asm(c b) "STREF";
```

Сохраняет ссылку на ячейку `c` в builder `b`.

#### store_uint

```func
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
```

Сохраняет беззнаковое `len`-битное целое `x` в `b` для `0 ≤ len ≤ 256`.

#### store_int

```func
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
```

Сохраняет знаковое `len`-битное целое `x` в `b` для `0 ≤ len ≤ 257`.

#### store_slice

```func
builder store_slice(builder b, slice s) asm "STSLICER";
```

Сохраняет срез `s` в builder `b`.

#### store_grams

```func
builder store_grams(builder b, int x) asm "STGRAMS";
```

#### store_coins

```func
builder store_coins(builder b, int x) asm "STGRAMS";
```

Сохраняет (сериализует) целое `x` в диапазоне `0..2^120 − 1` в builder `b`. The serialization consists of:

- Сериализация `x` состоит из 4-битного беззнакового целого числа с обратным порядком байтов `l`, которое является наименьшим целым числом `l ≥ 0`, таким образом, что `x < 2^8l`, за которым следует `8l`-битное беззнаковое представление `x` с обратным порядком байтов.
- An `8l`-bit unsigned big-endian representation of `x`.

Если `x` не принадлежит поддерживаемому диапазону, выдается исключение проверки диапазона.

Это наиболее распространенный способ хранения Toncoin.

#### store_dict

```func
builder store_dict(builder b, cell c) asm(c b) "STDICT";
```

Сохраняет словарь `D`, представленный ячейкой `c` или `null`, в builder `b`. Другими словами, сохраняет `1`-бит и ссылку на `c`, если `c` не является `null`, и `0`-бит в противном случае.

#### store_maybe_ref

```func
builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";
```

Эквивалентно `store_dict`.

### Примитивы размера конструктора

#### builder_refs

```func
int builder_refs(builder b) asm "BREFS";
```

Возвращает количество ссылок на ячейки, уже сохраненных в Builder `b`.

#### builder_bits

```func
int builder_bits(builder b) asm "BBITS";
```

Возвращает количество битов данных, уже сохраненных в Builder `b`.

#### builder_depth

```func
int builder_depth(builder b) asm "BDEPTH";
```

Возвращает глубину builder `b`. Если в `b` не сохранено ссылок на ячейки, то возвращает `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `b`. Otherwise, it returns `1` plus the maximum depth among the referenced cells.

## Cell primitives

#### cell_depth

```func
int cell_depth(cell c) asm "CDEPTH";
```

Returns the depth of the given `cell c`. If `c` has no references, the function returns `0`. Otherwise, it returns `1` plus the maximum depth among all cells referenced by `c`. Если `c` равно `null`, возвращается `x = y = z = 0`.

#### cell_null?

```func
int cell_null?(cell c) asm "ISNULL";
```

Проверяет, является ли `c` `null`. Обычно `null`-ячейка представляет собой пустой словарь. FunC также имеет встроенный полиморфный `null?`. [built-ins](/v3/documentation/smart-contracts/func/docs/builtins#other-primitives).)

## Примитивы словарей

:::caution
The dictionary primitives below are low-level and do not verify whether the cell structure matches the expected operation.
Using a dictionary operation on a "non-dictionary" cell results in **undefined behavior**. The same applies when using keys of different lengths or types, such as writing to a dictionary using an 8-bit signed key and a 7-bit unsigned key.

In most cases, this will cause an exception. However, in rare cases, it may lead to incorrect values being written or read. Developers should avoid such code.
:::

Как сказано в [TVM.pdf](https://ton.org/tvm.pdf):

> Словари допускают два различных представления в качестве значений стека TVM:
>
> 1. Срез `s` с сериализацией значения TL-B типа `HashmapE(n, X)`. Другими словами, `s` состоит либо из одного бита, равного нулю (если словарь пуст), либо из одного бита, равного единице, и ссылки на ячейку, содержащую корень двоичного дерева, т. е. сериализованное значение типа `Hashmap(n, X)`.
>
> 2. "Ячейка Maybe" `c^?`, т. е. значение, которое является либо ячейкой (содержащей сериализованное значение типа `Hashmap(n, X)`, как и раньше), либо `null` (соответствующее пустому словарю, см. [нулевые значения](/v3/documentation/smart-contracts/func/docs/types#null-values)). When using this format, the dictionary is typically referred to as `D`.
>
> Большинство примитивов словаря, перечисленных ниже, принимают и возвращают словари во второй форме, что более удобно для работы со стеком. Однако сериализованные словари внутри более крупных объектов TL-B используют первое представление.

В FunC словари также представлены типом `cell` с неявным предположением, что это может быть значение `null`. Для словарей с разной длиной ключа или типом значения нет отдельных типов (в конце концов, это FunC, а не FunC++).

### Примечание по таксономии

A dictionary primitive interprets dictionary keys in one of three ways:

1. Unsigned `l`-bit integers (denoted by **u**);
2. Signed `l`-bit integers (denoted by **i**);
3. `l`-bit slices (**no prefix**).

The naming convention of dictionary primitives reflects these distinctions. For example:

- Например, `udict_set` — это функция установки по ключу для словарей с беззнаковыми целочисленными ключами; `idict_set` — это соответствующая функция для словарей с целочисленными ключами со знаком; `dict_set` — это функция для словарей с ключами срезов.
- Устанавливает значение, связанное с `index`, в `value` (если `value` равно `null`, то вместо этого удаляется ключ) и возвращает старое значение (или `null`, если значение отсутствовало).
- В заголовках используется пустой префикс.

In function titles, an **empty prefix** indicates slice keys.
Кроме того, некоторые примитивы имеют свои аналоги с префиксом `~`. Это позволяет использовать их как [модифицирующие методы](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods).

### Значения в словарях

Говорят, что примитив _загружает_ некоторые данные, если он возвращает данные и остаток среза (поэтому его также можно использовать как [модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods)).

1. As a **subslice** within an inner dictionary cell.
2. As a **reference** to a separate cell.

В первом случае нет гарантии, что значение, достаточно малое для размещения в ячейке, также поместится в словаре, поскольку часть пространства внутренней ячейки может быть уже занята частью соответствующего ключа.
This is because a segment of the corresponding key may already occupy part of the inner cell’s space.

Напротив, последний метод хранения менее эффективен с точки зрения использования газа.
Сохранение значения с использованием второго метода равносильно вставке среза без битов данных и единственной ссылкой на значение в первом методе.

#### dict_set

```func
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
```

Устанавливает значение, связанное с `key_len`-bit key `index` в словаре `dict`, в `value` (ячейки) и возвращает результирующий словарь.

#### dict_set_ref

```func
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
```

Аналогично `dict_set`, но со значением, заданным как ссылка на `value` ячейки.

#### dict_get?

```func
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
```

Ищет ключ `index` в словаре `dict`, который использует ключи бит `key_len`. В случае успеха он извлекает связанное значение как `slice` и возвращает значение флага `-1`, чтобы указать на **успех**. Если поиск не удался, он возвращает `(null, 0)​​`.

#### dict_get_ref?

```func
(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF";
(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF";
```

Аналогично `dict_get?`, но возвращает первую ссылку найденного значения.

#### dict_get_ref

```func
cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
```

Вариант `dict_get_ref?`, который возвращает `null` вместо значения, если ключ `index` отсутствует в словаре `dict`.

#### dict_set_get_ref

```func
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";
```

This function sets the value associated with the `index` to `value`. If the `value` is `null`, the key is deleted.
It then returns the old value or `null` if it wasn't present.

#### dict_delete?

```func
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
```

Удаляет `key_len`-битный ключ `index` из словаря `dict`. Если ключ присутствует, возвращает измененный словарь `dict'` и флаг успеха `−1`.
В противном случае возвращает исходный словарь `dict` и `0`.

#### dict_delete_get?

```func
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
```

Удаляет `key_len`-битный ключ `index` из словаря `dict`. Если ключ присутствует, возвращает измененный словарь `dict'`, исходное значение `x`, связанное с ключом k (представленное срезом), и флаг успеха `−1`. В противном случае возвращает `(dict, null, 0)`.

#### dict_add?

```func
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
```

Аналог `dict_set` с `add` устанавливает значение, связанное с ключом `index` в словаре `dict`, в `value`, но только если оно еще не присутствует в `D`. Возвращает либо измененную версию словаря и флаг `-1`, либо `(dict, 0)`.

#### dict_replace?

```func
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
```

Операция `replace`, похожая на `dict_set`, но которая устанавливает значение ключа `index` в словаре `dict` в `value`, только если ключ уже присутствовал в `dict`. Возвращает либо измененную версию словаря и флаг `-1`, либо `(dict, 0)`.

### Примитивы конструктора

Следующие примитивы принимают новое значение в качестве компоновщика вместо среза, что часто удобнее, если значение необходимо сериализовать из нескольких компонентов, вычисленных в стеке. Чистый эффект примерно эквивалентен преобразованию b в срез и выполнению соответствующего примитива, перечисленного выше.

#### dict_set_builder

```func
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
```

Похоже на `dict_set`, но принимает конструктор.

#### dict_add_builder?

```func
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
```

Похоже на `dict_add?`, но принимает конструктор.

#### dict_replace_builder?

```func
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
```

Аналогично `dict_replace?`, но принимает конструктор.

#### dict_delete_get_min

```func
(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` — это измененная версия `dict`, а `x` — это значение, связанное с `k`. Если словарь пуст, возвращает `(dict, null, null, 0)`.

Обратите внимание, что ключ, возвращаемый `idict_delete_get_min`, может отличаться от ключа, возвращаемого `dict_delete_get_min` и `udict_delete_get_min`.

#### dict_delete_get_max

```func
(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` — это измененная версия `dict`, а `x` — это значение, связанное с `k`. Если словарь пуст, возвращает `(dict, null, null, 0)`.

#### dict_get_min?

```func
(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, связанное значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_max?

```func
(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, связанное значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_min_ref?

```func
(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_min?` но возвращает единственную ссылку в значении в качестве ссылки.

#### dict_get_max_ref?

```func
(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_max?`, но возвращает единственную ссылку в значении в качестве ссылки.

#### dict_get_next?

```func
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
```

Finds the smallest key `k` in `dict` that is greater than the `pivot`. Вычисляет минимальное значение ключа `k` в словаре `dict`, которое больше, чем `pivot`; возвращает `k`, соответствующее значение и флаг, указывающий на успех. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_nexteq?

```func
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет минимальный ключ `k`, который больше или равен `pivot`.

#### dict_get_prev?

```func
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет максимальный ключ `k`, меньший, чем `pivot`.

#### dict_get_preveq?

```func
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_prev?`, но вычисляет максимальный ключ `k`, меньший или равный `pivot`.

#### new_dict

```func
cell new_dict() asm "NEWDICT";
```

Создает пустой словарь, который на самом деле является значением `null`. Особый случай `null()`.

#### dict_empty?

```func
int dict_empty?(cell c) asm "DICTEMPTY";
```

Проверяет, является ли словарь пустым. Эквивалентно `cell_null?`.

## Примитивы префиксных словарей

TVM также поддерживает словари с ключами нефиксированной длины, которые формируют префиксный код (т. е. нет ключа, который является префиксом другого ключа).
Узнайте больше о них в разделе [Инструкции TVM](/v3/documentation/tvm/tvm-overview).

#### pfxdict_get?

```func
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";
```

Ищет уникальный префикс среза `key`, присутствующий в словаре префиксного кода `dict`. Если он найден, префикс `s` возвращается как `s'`, а соответствующее значение (также срез) как `x`.

- `s'` is the matching prefix of `s`,
- `x` is the corresponding value (a slice),
- `s''` is the remaining part of `s`,
- `-1` indicates success.

If no matching prefix is found, returns `(null, null, s, 0)`, where `s` remains unchanged and `0` indicates failure.

#### pfxdict_set?

```func
(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";
```

Аналогично `dict_set`, но может завершиться ошибкой, если ключ является префиксом другого ключа, представленного в словаре. При успешном завершении возвращает флаг.

#### pfxdict_delete?

```func
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";
```

Аналогично `dict_delete?`.

## Специальные примитивы

#### null

```func
forall X -> X null() asm "PUSHNULL";
```

По типу TVM `Null`, FunC представляет отсутствие значения некоторого атомарного типа. Поэтому `null` может фактически иметь любой атомарный тип.

#### ~impure_touch

```func
forall X -> (X, ()) ~impure_touch(X x) impure asm "NOP";
```

Помечает переменную как используемую, чтобы код, который ее создал, не был удален, даже если он не является нечистым. (например, [нечистый спецификатор](/v3/documentation/smart-contracts/func/docs/functions#impure-specifier))

## Другие примитивы

#### мин

```func
int min(int x, int y) asm "MIN";
```

Вычисляет минимум из двух целых чисел `x` и `y`.

#### max

```func
int max(int x, int y) asm "MAX";
```

Вычисляет максимум из двух целых чисел `x` и `y`.

#### minmax

```func
(int, int) minmax(int x, int y) asm "MINMAX";
```

Сортирует два целых числа.

#### abs

```func
int abs(int x) asm "ABS";
```

Вычисляет абсолютное значение целого числа `x`.

<Feedback />
