# Типы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::info

Документация по FunC была изначально написана [@akifoq](https://github.com/akifoq).

:::

FunC имеет следующие встроенные типы.

## Атомарные типы

- `int` — тип 257-битных знаковых целых чисел. По умолчанию проверки переполнения включены и приводят к исключениям переполнения целых чисел.
- `cell` — тип ячеек TVM. Все постоянные данные в блокчейне TON хранятся в деревьях ячеек. Каждая ячейка имеет до 1023 бит произвольных данных и до четырех ссылок на другие ячейки. Ячейки служат памятью в стековых TVM.
- `slice` — тип срезов ячеек. Ячейку можно преобразовать в срез, а затем биты данных и ссылки на другие ячейки из ячейки можно получить, загрузив их из среза.
- `builder` — тип построителей ячеек. Биты данных и ссылки на другие ячейки могут храниться в конструкторе, а затем конструктор может быть завершен для новой ячейки.
- `tuple` - тип кортежей TVM. Кортеж - это упорядоченная коллекция, содержащая до 255 компонентов с произвольными типами значений, которые могут отличаться друг от друга.
- `cont` - тип продолжений TVM. Продолжения используются для управления ходом выполнения программы TVM. С точки зрения функциональности, это объект довольно низкого уровня, хотя, как это ни парадоксально, довольно общий.

Обратите внимание, что любой из типов выше занимает только одну запись в стеке TVM.

### Отсутствие логического типа

В FunC логические значения представлены как целые числа; `false` представлено как `0`, а `true` представлено как `-1` (257 единиц в двоичной записи). Логические операции выполняются как побитовые операции. При проверке условия каждое ненулевое целое число считается значением `true`.

### Нулевые значения

Значением `null` типа TVM `Null` FunC представляет отсутствие значения некоторого атомарного типа. Некоторые примитивы из стандартной библиотеки могут быть типизированы как возвращающие атомарный тип и фактически возвращающие `null` в некоторых случаях. Другие могут быть типизированы как исключающие значение атомарного типа, но также прекрасно работать со значениями `null`. Такое поведение явно указано в спецификации примитива. По умолчанию значения `null` запрещены и приводят к исключению во время выполнения.

Таким образом, атомарный тип `A` может быть неявно преобразован в тип `A^?`, также известный как `Maybe A` (проверка типов не зависит от такого преобразования).

## Тип отверстия

Функция поддерживает вывод типа. Типы `_` и `var` представляют собой "пробелы" в типах, которые позже могут быть заполнены каким-либо фактическим типом во время проверки типа. Например, `var x = 2;` - это определение переменной `x`, равной `2`. Средство проверки типов может сделать вывод, что `x` имеет тип `int`, потому что `2` имеет тип `int`, а левая и правая части присваивания должны иметь одинаковые типы.

## Составные типы

Типы могут быть объединены в более сложные.

### Функциональный тип

Типы формы `A -> B` представляют функции с указанным доменом и кодовой областью. Например, `int -> cell` — это тип функции, которая принимает один целочисленный аргумент и возвращает ячейку TVM.

Внутренне значения таких типов представлены как продолжения.

### Тензорные типы

Типы вида "(A, B, ...)" по сути представляют собой упорядоченные наборы значений типов "A", "B", "...", которые все вместе занимают более одной записи в стеке TVM.

Например, если функция `foo` имеет тип `int -> (int, int)`, это означает, что функция принимает одно целое число и возвращает пару из них.

Вызов этой функции может выглядеть как `(int a, int b) = foo(42);`. Внутри функция потребляет одну запись стека и оставляет две из них.

Обратите внимание, что с точки зрения низкого уровня значение `(2, (3, 9))` типа `(int, (int, int))` и значение `(2, 3, 9)` типа `(int, int, int)` представлены так же, как три записи стека `2`, `3` и `9`. Для проверки типов FunC это значения **разных** типов. Например, код `(int a, int b, int c) = (2, (3, 9));` не будет скомпилирован.

Частным случаем тензорного типа является тип **unit** `()`. Обычно он используется для обозначения того факта, что функция не возвращает никакого значения или не имеет аргументов. Например, функция `print_int` будет иметь тип `int -> ()`, а функция `random` - тип `() -> int`. У нее есть уникальный пользователь `()`, который занимает 0 записей в стеке.

Тип формы `(A)` рассматривается проверкой типов как тот же тип, что и `A`.

### Типы кортежей

Типы формы `[A, B, ...]` представляют кортежи TVM с определенными длинами и типами компонентов, известными во время компиляции. Например, `[int, cell]` — это тип кортежа TVM, длина которого ровно 2, и где первый компонент — целое число, а второй — ячейка. `[]` — это тип пустых кортежей (у которых есть единственный обитатель - пустой кортеж). Обратите внимание, что в отличие от типа объекта `()`, значение `[]` занимает одну запись стека.

## Полиморфизм с переменной типа

FunC имеет систему типов Миллера-Рабина с поддержкой полиморфных функций. Например, следующая функция:

```func
forall X -> (X, X) duplicate(X value) {
  return (value, value);
}
```

является полиморфной функцией, которая принимает значение (одну запись стека) и возвращает две копии этого значения. `duplicate(6)` создаст значения `6 6`, а `duplicate([])` создаст две копии `[] []` пустого кортежа.

В этом примере `X` — это переменная типа.

Подробнее об этой теме смотрите в разделе [функции](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall).

## Пользовательские типы

В настоящее время FunC не поддерживает определение типов, за исключением конструкций типов, описанных выше.

## Ширина типа

Как вы могли заметить, каждое значение типа занимает некоторое количество записей стека. Если это одно и то же число для всех значений типа, это число называется **шириной типа**. Полиморфные функции в настоящее время могут быть определены только для типов с фиксированной и заранее известной шириной типа.
