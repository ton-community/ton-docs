import Feedback from '@site/src/components/Feedback';

import ThemedImage from '@theme/ThemedImage';

# Ячейки и пакеты ячеек (Cell & Bag of Cells (BoC))

## Cell

Ячейка представляет собой структуру данных в блокчейне TON. Ячейки могут хранить до 1023 бит и иметь до 4 ссылок на другие ячейки.

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-5.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-5-dark.png?raw=true',
}}
/>
<br></br>

## Bag of Cells

Bag of Cells (BoC) - это формат для сериализации ячеек в массивы байтов, который более подробно описан в [схеме TL-B](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-6.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-6-dark.png?raw=true',
}}
/>
<br></br>

В TON все состоит из ячеек, включая код контракта, хранимые данные, блоки, что обеспечивает упрощение и надежную гибкость процесса.

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-4.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-4-dark.png?raw=true',
}}
/>
<br></br>

### Сериализация ячеек

Let’s walk through a basic example of a BoC:

<br></br>
<ThemedImage
alt=""
sources={{
    light: '/img/docs/data-formats/tl-b-docs-7.png?raw=true',
    dark: '/img/docs/data-formats/tl-b-docs-7-dark.png?raw=true',
}}
/>
<br></br>

```json
1[8_] -> {
  24[0AAAAA],
  7[FE] -> {
    24[0AAAAA]
  }
}
```

In this case, we have a 0-bit root cell that references two other cells:

- The first is a 24-bit cell.
- В этом примере у нас есть корневая ячейка размером 1 бит, которая имеет 2 ссылки: первая на 24-битную ячейку, а вторая на 7-битную ячейку, которая имеет 1 ссылку на 24-битную ячейку.

Чтобы эта структура работала так, как задумано, необходимо превратить ячейки в одну последовательность байтов. Для этого, во-первых, мы используем только уникальные типы ячеек, ниже представлены 3 из 4:

```json
1[8_]
24[0AAAAA]
7[FE]
```

:::note
Чтобы оставить только уникальные ячейки, их необходимо сравнить. Чтобы сделать это, нам нужно сравнить [хэши] (#cell-хэш) ячеек.
:::

Next, we arrange the cells in a specific order so that parent cells never reference cells that come before them in the list. In other words, any referenced cell must appear after the cells that reference it. We get:

```json
1[8_]      -> index 0 (root cell)
7[FE]      -> index 1
24[0AAAAA] -> index 2
```

Теперь давайте вычислим описания для каждой из 3 ячеек, упомянутых выше. Эти описания состоят из 2 байт, в которых хранятся флаги, содержащие информацию о длине данных и количестве связей с данными.

1. **Refs descriptor (1st byte)**

  This byte is calculated using the formula: `r + 8·s + 32·l`.

Where:

- `r` is the number of cell's references (links) in the range `0 ≤ r ≤ 4`.
- `s` is the exotic flag (1 for [exotic](#special-exotic-cells) cells, 0 for ordinary ones).
- `l` is the  [level](#cell-level) of the cell in the range `0 ≤ l ≤ 3` .

2. **Bits descriptor (2nd byte)**

Объединяя байты из предыдущих шагов, мы получаем `00080000000f`, а SHA256 из этой строки байтов равен `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9` — это хэш представления ячейки.

Второй - **битовый дескриптор** - равен `floor(b / 8) + ceil (b / 8)`, где `0 <= b <= 1023` - количество бит в ячейке.

Этот дескриптор представляет длину полных 4-битных групп данных ячейки (но не менее 1, если она не пустая).

Результат:

```json
1[8_]      -> 0201 -> 2 refs, length 1
7[FE]      -> 0101 -> 1 ref, length 1
24[0AAAAA] -> 0006 -> 0 refs, length 6
```

Для данных с неполными 4-битными группами в конец последовательности добавляется 1 бит. Это означает, что он обозначает конечный бит группы и используется для определения истинного размера неполных групп. Давайте добавим биты ниже:

```json
1[8_]      -> C0     -> 0b10000000->0b11000000
7[FE]      -> FF     -> 0b11111110->0b11111111
24[0AAAAA] -> 0AAAAA -> do not change (full groups)
```

We now specify which cells each one references:

```json
0 1[8_]      -> 0201 -> refers to 2 cells with such indexes
1 7[FE]      -> 02 -> refers to cells with index 2
2 24[0AAAAA] -> no refs
```

Now we serialize the cells:

```json
0201 C0     0201
0101 FF     02
0006 0AAAAA
```

Далее мы объединяем все, что указано выше, в массив байтов в нашем окончательном BoC:
`b5ee9c7201010301000e000201c002010101ff0200060aaaaa`

Size: 14 bytes.

<details>
  <summary><b>Показать пример</b></summary>

```golang
func (c *Cell) descriptors() []byte {
  ceilBytes := c.bitsSz / 8
  if c.bitsSz%8 ! = 0 {
    ceilBytes++
  }

	// calc size
	ln := ceilBytes + c.bitsSz / 8

	specBit := byte(0)
	if c.special {
	  specBit = 8
	}

	return []byte{byte(len(c.refs)) + specBit + c.level*32, byte(ln)}
}
```

[Источник](https://github.com/xssnick/tonutils-go/blob/3d9ee052689376061bf7e4a22037ff131183afad/tvm/cell/serialize.go#L205)

</details>

### Упаковка Bag of Cells

Now that we've serialized our cells into a flat 14-byte array, it's time to pack them into a complete BoC format by building the appropriate header according to its [schema](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

```
b5ee9c72                      -> id tl-b of the BoC structure
01                            -> flags and size:(## 3), in our case the flags are all 0,
                                 and the number of bytes needed to store the number of cells is 1.
                                 we get - 0b0_0_0_00_001
01                            -> number of bytes to store the size of the serialized cells
03                            -> number of cells, 1 byte (defined by 3 bits size:(## 3), equal to 3.
01                            -> number of root cells - 1
00                            -> absent, always 0 (in current implementations)
0e                            -> size of serialized cells, 1 byte (size defined above), equal to 14
00                            -> root cell index, size 1 (determined by 3 size:(## 3) bits from header),
                                 always 0
0201c002010101ff0200060aaaaa  -> serialized cells
```

We now concatenate the header and the serialized cell content:
`b5ee9c7201010301000e000201c002010101ff0200060aaaaa`

**BoC implementation examples**

- Поэтому мы строим заголовок согласно его [схеме](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).
- Примеры реализации Bag of Cells: [Сериализация](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/serialize.go), [Десериализация](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/parse.go)

## Специальные (экзотические) ячейки

Как правило, ячейки, работающие на TON, делятся на два основных типа: обычные ячейки и специальные ячейки.
Большинство ячеек, с которыми работают пользователи, являются обычными ячейками, отвечающими за перенос информации.

Тем не менее, для реализации внутренней функциональности сети иногда требуются специальные ячейки, которые используются для различных целей в зависимости от их подтипа. Depending on their specific subtype, these cells serve various purposes.

## Уровень ячейки

Каждая ячейка имеет атрибут, называемый `Level`, который представлен целым числом от 0 до 3.

### Уровень обычных ячеек

Уровень обычной ячейки всегда равен максимальному из уровней всех ее ссылок:

```cpp
Lvl(c) = max(Lvl(r_0), ..., Lvl(r_i), ..., Lvl(r_e))
```

Где `i` — это индекс ссылки `c`, `e` — это количество ссылок `c`.

_Уровень обычной ячейки без ссылок равен нулю_

### Уровень экзотических ячеек

У экзотических ячеек есть разные правила установки их уровня, которые описаны в [этой](/v3/documentation/data-formats/tlb/exotic-cells) статье.

## Хэш ячейки

В большинстве случаев пользователи работают с обычными ячейками с уровнем 0, которые имеют только один хэш, называемый хэшем представления (или бесконечным хэшем).

Ячейка `c` с уровнем `Lvl(c) = l`, где `1 ≤ l ≤ 3` имеет хэш представления, а `l` **"более высокий"** хэш.

### Стандартный расчет хэша представления ячейки

To compute the representation hash of a cell, follow these steps:

1. Вычислить байты дескрипторов
2. Добавить сериализованные данные ячейки
3. Для каждой ссылки ячейки добавить ее глубину
4. Для каждой ссылки ячейки добавить ее хэш представления
5. Вычислить хэш SHA256 результата

Давайте проанализируем следующие примеры:

#### Cell without references

```json
32[0000000F]
```

1. **Descriptors computation**

   - Дескриптор ссылки равен `r+8s+32l = 0 + 0 + 0 = 0 = 00`
   - Дескриптор бит равен `floor(b / 8) + ceil (b / 8) = 8 = 08`
   - Combined descriptor bytes: `0008`.

2. Сериализация данных ячейки

   - В этом случае у нас есть полные 4-битные группы, поэтому нам не нужно добавлять биты к данным ячейки.
   - Serialized data: `0000000F`

3. **Refs depth**

   - This cell has no references, so we skip depth and reference hash steps.

4. **Refs hashes**

   - This cell has no references, so we skip depth and reference hash steps.

5. Вычисление SHA256

   - Concatenate the bytes from the previous steps: `00080000000F`.
   - Compute the SHA-256 hash of this byte string: `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`.

   This is the **representation hash** of the cell.

#### Cell with references

```json
24[00000B] -> {
	32[0000000F],
	32[0000000F]
}
```

1. **Descriptors computation**

   - Ссылочный дескриптор равен `r+8s+32l = 2 + 0 + 0 = 0 = 02`
   - Битовый дескриптор равен `floor(b / 8) + ceil (b / 8) = 6 = 06`
   - Combined descriptor bytes: `0206`.

2. Сериализация данных ячейки

   - В этом случае у нас есть полные 4-битные группы, поэтому нам не нужно добавлять биты к данным ячейки.
   - Serialized cell data: `00000B`.

3. **Refs depth**

   - Глубина представлена ​​2 байтами.
   - Наша ячейка имеет 2 ссылки, и глубина каждой из них равна нулю, поэтому результатом этого шага будет `00000000`.

4. **Refs hashes**

   - Each reference contributes its representation hash. From the previous example, the result is:

     `57b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`

5. Вычисление SHA256

   - By concatenating the bytes from the previous steps, we obtain the following byte string:

   `020600000b0000000057b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f957b520dbcb9d135863fc33963cde9f6db2ded1430d88056810a2c9434a3860f9`.

   - The SHA-256 hash of this byte string is:

   `f345277cc6cfa747f001367e1e873dcfa8a936b8492431248b7a3eeafa8030e7`.

   - This is the representation hash of the cell.

### Вычисление более высоких хэшей

Более высокие хэши обычной ячейки `c` вычисляются аналогично хэшу ее представления, но с использованием более высоких хэшей ее ссылок вместо хэшей их представления.

Exotic cells follow separate rules for computing their higher hashes. Экзотические ячейки имеют свои собственные правила вычисления своих более высоких хэшей, которые описаны в [этой](/v3/documentation/data-formats/tlb/exotic-cells) статье.

## См. также

[//]: # "* [Оригинальная статья на RU](https://github.com/xssnick/ton-deep-doc/blob/master/Cells-BoC.md)"

- [Экзотические (специальные) ячейки](/v3/documentation/data-formats/tlb/exotic-cells)
- [Проверка доказательства Меркла](/v3/documentation/data-formats/tlb/proofs)

<Feedback />
