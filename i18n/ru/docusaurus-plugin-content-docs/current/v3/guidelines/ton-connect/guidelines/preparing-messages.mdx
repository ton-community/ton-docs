import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Подготовка сообщений

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

При использовании TON Connect вам следует создать тело сообщения для полезной нагрузки, используемой в различных транзакциях. На этой странице вы найдете наиболее подходящие примеры полезной нагрузки для использования с TON Connect SDK.

:::info
Ожидается, что вы изучите основы создания соединения TON Connect. Узнайте больше в [руководстве по интеграции](/v3/guidelines/ton-connect/guidelines/integration-with-javascript-sdk).
:::

## Ячейки и сериализация сообщений

Прежде чем погрузиться в создание сообщений, давайте познакомимся с концепцией ячеек, из которых состоят тела сообщений.

### Что такое ячейка?

Ячейка — это базовая структура данных в блокчейне TON. Она может хранить до `1023` бит и содержать до `4` ссылок на другие ячейки, что позволяет хранить более сложные структуры данных. Такие библиотеки, как `@ton/core` и `@ton-community/assets-sdk`, предоставляют эффективные способы обработки ячеек.

Подробнее о ячейках можно прочитать [здесь](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage).

### Создание ячейки

Чтобы создать ячейку, используйте функцию `beginCell()`. Пока ячейка "открыта", вы можете хранить различные типы данных с помощью функций `store...()`. Когда работа закончена, закройте ячейку с помощью функции `endCell()`.

```ts
import { Address, beginCell } from "@ton/ton";

const cell = beginCell()
  .storeUint(99, 64) // Stores uint 99 in 64 bits
  .storeAddress(Address.parse('[SOME_ADDR]')) // Stores an address
  .storeCoins(123) // Stores 123 as coins
  .endCell() // Closes the cell
```

### Анализ ячейки

Чтобы прочитать или проанализировать данные из ячейки, вызывается функция `beginParse()`. Вы считываете данные в том же порядке, в котором они были сохранены, используя аналогичные функции `load...()`:

```ts
const slice = cell.beginParse();
const uint = slice.loadUint(64);
const address = slice.loadAddress();
const coins = slice.loadCoins();
```

### Большие объемы данных

Каждая ячейка имеет ограничение в 1023 бита. Если вы превысите его, возникнет ошибка:

```ts
// This will fail due to overflow
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeUint(3, 256)
  .storeUint(4, 256) // Exceeds 1023-bit limit (256 + 256 + 256 + 256 = 1024)
  .endCell()
```

Чтобы сохранить больше данных, ячейки могут ссылаться на другие ячейки. Вы можете использовать функцию storeRef() для создания вложенных ячеек:

```ts
const cell = beginCell()
  .storeUint(1, 256)
  .storeUint(2, 256)
  .storeRef(beginCell()
    .storeUint(3, 256)
    .storeUint(4, 256)
    .endCell())
  .endCell()
```

Чтобы загрузить ячейку, на которую есть ссылка (вложенную), используйте loadRef():

```ts
const slice = cell.beginParse();
const uint1 = slice.loadUint(256);
const uint2 = slice.loadUint(256);
const innerSlice = slice.loadRef().beginParse(); // Load and parse nested cell
const uint3 = innerSlice.loadUint(256);
const uint4 = innerSlice.loadUint(256);
```

### Необязательные ссылки и значения

Ячейки могут хранить необязательные значения (которые могут быть нулевыми). Они сохраняются с помощью функций `storeMaybe...()`:

```ts
const cell = beginCell()
  .storeMaybeInt(null, 64) // Optionally stores an int
  .storeMaybeInt(1, 64)
  .storeMaybeRef(null) // Optionally stores a reference
  .storeMaybeRef(beginCell()
    .storeCoins(123)
    .endCell());
```

Вы можете анализировать необязательные значения с помощью соответствующих функций loadMaybe...(). Возвращаемые значения могут быть нулевыми, поэтому не забудьте проверить их на нулевое значение!

```ts
const slice = cell.beginParse();
const maybeInt = slice.loadMaybeUint(64);
const maybeInt1 = slice.loadMaybeUint(64);
const maybeRef = slice.loadMaybeRef();
const maybeRef1 = slice.loadMaybeRef();
if (maybeRef1) {
  const coins = maybeRef1.beginParse().loadCoins();
}
```

### Использование assets sdk для упрощения сериализации и десериализации

Ручная обработка ячеек может быть утомительной, поэтому `@ton-community/assets-sdk` предоставляет удобные методы сериализации и десериализации сообщений.

Использование `@ton-community/assets-sdk` более читабельно и менее подвержено ошибкам.

<Tabs groupId="Сериализация/Десериализация">

<TabItem value="@ton-community/assets-sdk" label="@ton-community/assets-sdk">

```ts
import {Address, beginCell} from "@ton/core";
import {storeJettonTransferMessage, loadJettonTransferMessage} from "@ton-community/assets-sdk";

// serialization
const cell = beginCell()
  .store(storeJettonTransferMessage({
    queryId: 42n,
    amount: 100n,
    destination: Address.parse('[DESTINATION]'),
    responseDestination: Address.parse('[RESPONSE_DESTINATION]'),
    customPayload: null,
    forwardAmount: 1n,
    forwardPayload: null,
  }))
  .endCell()

// deserialization
const transferMessage = loadJettonTransferMessage(cell.beginParse());
```

</TabItem>

<TabItem value="@ton/ton" label="@ton/ton">

```ts
import {Address, beginCell} from "@ton/core";

// serialization
const cell = beginCell()
  .storeUint(260734629, 32)
  .storeUint(42, 64)
  .storeCoins(100)
  .storeAddress(Address.parse('[DESTINATION]'))
  .storeAddress(Address.parse('[RESPONSE_DESTINATION]'))
  .storeMaybeRef(null)
  .storeCoins(1)
  .storeMaybeRef(null)
  .endCell();

// deserialization
const slice = cell.beginParse();
const op = slice.loadUint(32);
const queryId = slice.loadUint(64);
const amount = slice.loadCoins();
const destination = slice.loadAddress();
const responseDestination = slice.loadAddress();
const customPayload = slice.loadMaybeRef();
const fwdAmount = slice.loadCoins();
const fwdPayload = slice.loadMaybeRef();

const transferMessage = { op, queryId, amount, destination, responseDestination, customPayload, fwdAmount, fwdPayload };
```

</TabItem>
</Tabs>

## Примеры TON Connect JS SDK

### Шаблон транзакции

Независимо от того, какой уровень задачи решает разработчик, обычно необходимо использовать сущность коннектора из `@tonconnect/sdk` или `@tonconnect/ui`. Примеры, созданные на основе `@tonconnect/sdk` и `@tonconnect/ui`:

<Tabs groupId="Шаблон TON Connect">

<TabItem value="tonconnect-react" label="@tonconnect/ui-react">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';

const transaction = {
    //transaction body
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>
<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui';

const tonConnectUI = new TonConnectUI({ //connect application
    manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
    buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
});

const transaction = {
    //transaction body
}

const result = await tonConnectUI.sendTransaction(transaction)

```

</TabItem>
<TabItem value="tonconnect-js" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
const connector = new TonConnect();

await connector.sendTransaction({
    //transaction body
})

```

</TabItem>

</Tabs>

### Обычный перевод TON

TON Connect SDK включают оболочки для отправки сообщений, что упрощает подготовку обычных переводов Toncoins между двумя кошельками в качестве транзакции по умолчанию без полезной нагрузки.

Обычный перевод TON с использованием TON Connect JS SDK может быть выполнен следующим образом:

<Tabs groupId="Обычный перевод">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
const [tonConnectUI] = useTonConnectUI();

const transaction = {
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]

}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(transaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui';

const tonConnectUI = new TonConnectUI({ //connect application
    manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json',
    buttonRootId: '<YOUR_CONNECT_BUTTON_ANCHOR_ID>'
});

const transaction = {
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
const connector = new TonConnect();

await connector.sendTransaction({
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]
})

```

</TabItem>
</Tabs>

:::tip
Узнайте больше об [адресах смарт-контрактов TON](/v3/documentation/smart-contracts/addresses).
:::

Для конкретной пользовательской транзакции необходимо определить определенную полезную нагрузку.

### Передача с комментарием

Самый простой пример включает добавление полезной нагрузки с комментарием. Подробнее см. [этой странице](/v3/documentation/smart-contracts/message-management/internal-messages#simple-message-with-comment).
Перед транзакцией необходимо подготовить ячейку `body` [cell](/v3/documentation/data-formats/tlb/cell-boc) с помощью библиотеки JavaScript [@ton/ton](https://github.com/ton-org/ton).

```js
import { beginCell } from '@ton/ton'

const body = beginCell()
  .storeUint(0, 32) // write 32 zero bits to indicate that a text comment will follow
  .storeStringTail("Hello, TON!") // write our text comment
  .endCell();
```

Тело транзакции создается следующим образом:

<Tabs groupId="Передача с комментарием">

<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: destination,
            amount: toNano("0.05").toString(),
            payload: body.toBoc().toString("base64") // payload with comment in body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: destination,
            amount: toNano("0.05").toString(),
            payload: body.toBoc().toString("base64") // payload with comment in body
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
import { toNano } from '@ton/ton'

const connector = new TonConnect();

await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: destination,
      amount: toNano("0.05").toString(),
      payload: body.toBoc().toString("base64") // payload with comment in body
    }
  ]
})
```

</TabItem>
</Tabs>

### Отправка жетонов

`body` для отправки жетона основано на стандарте ([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)). Обратите внимание, что количество знаков после запятой может различаться в зависимости от токена: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

:::info
Вы можете использовать библиотеку `assets-sdk` с методами из коробки (даже с `ton-connect`)
:::

<Tabs groupId="Отправка жетонов">
<TabItem value="@ton/ton" label="@ton/ton">

```js
    import { beginCell, toNano, Address } from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)                 // jetton transfer op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(toNano("0.001"))              // amount:(VarUInteger 16) -  Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(Address.parse(Wallet_DST))  // destination:MsgAddress
        .storeAddress(Address.parse(Wallet_SRC))  // response_destination:MsgAddress
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano("0.05"))                 // forward_ton_amount:(VarUInteger 16) - if >0, will send notification message
        .storeUint(0,1)                           // forward_payload:(Either Cell ^Cell)
        .endCell();
```

Далее выполняется отправка транзакции с этим телом в jettonWalletContract отправителя:

<Tabs groupId="Jetton Transfer">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // sender jetton wallet
            amount: toNano("0.05").toString(), // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with jetton transfer body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract,  // sender jetton wallet
            amount: toNano("0.05").toString(),         // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with jetton transfer body
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
import TonConnect from '@tonconnect/sdk';
import { toNano } from '@ton/ton'

const connector = new TonConnect();
//...
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,            // sender jetton wallet
      amount: toNano("0.05").toString(),                   // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64")  // payload with jetton transfer body
    }
  ]
})
```

</TabItem>
</Tabs>

- `validUntil` - UNIX-время до сообщения valid
- `jettonWalletAddress` - Адрес JettonWallet, который определен на основе контрактов JettonMaser и Wallet
- `balance` - Целое число, количество Toncoin для оплаты газа в nanotons.
- `body` - полезная нагрузка для jettonContract

<details>
    <summary>Пример инициализации и подготовки адреса состояния кошелька жетона</summary>

```js
import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

async function main() {
    const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'put your api key'
    })

    const jettonWalletAddress = Address.parse('Sender_Jetton_Wallet');
    let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
    jettonWalletDataResult.stack.readNumber();
    const ownerAddress = jettonWalletDataResult.stack.readAddress();
    const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
    const jettonCode = jettonWalletDataResult.stack.readCell();
    const jettonData = beginCell()
        .storeCoins(0)
        .storeAddress(ownerAddress)
        .storeAddress(jettonMasterAddress)
        .storeRef(jettonCode)
        .endCell();

    const stateInit: StateInit = {
        code: jettonCode,
        data: jettonData
    }

    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    console.log(new Address(0, stateInitCell.hash()));
}
```

</details>
</TabItem>
<TabItem value="assets/sdk" label="assets/sdk">

:::tip
Примечание: Для браузера вам необходимо установить полифилл для `Buffer`.
:::

```js
const NETWORK = "testnet";
const api = await createApi(NETWORK);
const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const storage: PinataStorageParams = {
  pinataApiKey: process.env.PINATA_API_KEY!,
  pinataSecretKey: process.env.PINATA_SECRET!,
};

const sdk = AssetsSDK.create({
  api,
  storage,
  sender,
});

const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));
const RECEIVER_ADDRESS = Address.parse("RECIEVER_ADDRESS");

jetton.send(sender, RECEIVER_ADDRESS, toNano(10));
```

Или вы можете использовать контракт жетона со встроенными методами:

```ts
const provider = tonConnectUi;

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const client = new TonClient({
  endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
});

const jettonMaster = client.open(
  JettonMinter.createFromAddress(
    Address.parse("[JETTON_WALLET]"),
    new DefaultContentResolver()
  )
);

const jettonWalletAddress = await jettonMaster.getWalletAddress(
  sender.address!
);
const jettonContent = await jettonMaster.getContent();
const jettonDecimals = jettonContent.decimals ?? 9;

const jetton = client.open(JettonWallet.createFromAddress(jettonWalletAddress));

await jetton.send(
  sender,
  Address.parse("[SENDER_WALLET]"),
  BigInt(1 * 10 ** jettonDecimals)
);

```

</TabItem>
</Tabs>

### Отправка жетона с комментарием

<Tabs groupId="Отправка жетона с комментарием">
<TabItem value="@ton/ton" label="@ton/ton">

`messageBody` для отправки жетона ([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) с комментарием. Мы должны дополнительно к обычному `body` перевода сериализовать комментарий и упаковать его в `forwardPayload`. Обратите внимание, что количество десятичных знаков может различаться в разных токенах: например, USDT использует 6 десятичных знаков (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 десятичных знаков (1 TON = 1 \* 10 \*\* 9).

```js
    import { beginCell, toNano, Address } from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const destinationAddress = Address.parse('put destination wallet address');

    const forwardPayload = beginCell()
        .storeUint(0, 32) // 0 opcode means we have a comment
        .storeStringTail('Hello, TON!')
        .endCell();

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32) // opcode for jetton transfer
        .storeUint(0, 64) // query id
        .storeCoins(toNano("5")) // Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(destinationAddress) // TON wallet destination address
        .storeAddress(destinationAddress) // response excess destination
        .storeBit(0) // no custom payload
        .storeCoins(toNano("0.02")) // forward amount (if >0, will send notification message)
        .storeBit(1) // we store forwardPayload as a reference
        .storeRef(forwardPayload)
        .endCell();

```

Далее выполняется отправка транзакции с этим телом в jettonWalletContract отправителя:

<Tabs groupId="Отправка жетонов">
  <TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
    import { useTonConnectUI } from '@tonconnect/ui-react';
	import { toNano } from '@ton/ton'


    const jettonWalletContract = Address.parse('put your jetton wallet address');

    const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
  {
    address: jettonWalletContract, // sender jetton wallet
    amount: toNano("0.05").toString(), // for commission fees, excess will be returned
    payload: body.toBoc().toString("base64") // payload with jetton transfer and comment body
  }
    ]
  }

    export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
    <div>
    <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
    Send transaction
  </button>
</div>
);
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
  import TonConnectUI from '@tonconnect/ui'
  import { toNano } from '@ton/ton'

  const transaction = {
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
{
  address: jettonWalletContract,  // sender jetton wallet
  amount: toNano("0.05").toString(),         // for commission fees, excess will be returned
  payload: body.toBoc().toString("base64") // payload with jetton transfer and comment body
}
  ]
}

  const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
  import TonConnect from '@tonconnect/sdk';
  import { toNano } from '@ton/ton'

  const connector = new TonConnect();
  //...
  await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
{
  address: jettonWalletContract,            // sender jetton wallet
  amount: toNano("0.05").toString(),                   // for commission fees, excess will be returned
  payload: body.toBoc().toString("base64")  // payload with jetton transfer and comment body
}
  ]
})
```

</TabItem>
</Tabs>

- `validUntil` - UNIX-время до получения сообщения valid
- `jettonWalletAddress` - Адрес JettonWallet, определенный на основе контрактов JettonMaser и кошелька
- `balance` - целое число, сумма в тоннах монет для оплаты газа в nanotons.
- `body` - полезная нагрузка для jettonContract

<details>
  <summary>Пример инициализации и подготовки адреса Jetton Wallet</summary>

```js
  import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

  async function main() {
  const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
  apiKey: 'put your api key'
})

  const jettonWalletAddress = Address.parse('Sender_Jetton_Wallet');
  let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
  jettonWalletDataResult.stack.readNumber();
  const ownerAddress = jettonWalletDataResult.stack.readAddress();
  const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
  const jettonCode = jettonWalletDataResult.stack.readCell();
  const jettonData = beginCell()
  .storeCoins(0)
  .storeAddress(ownerAddress)
  .storeAddress(jettonMasterAddress)
  .storeRef(jettonCode)
  .endCell();

  const stateInit: StateInit = {
  code: jettonCode,
  data: jettonData
}

  const stateInitCell = beginCell()
  .store(storeStateInit(stateInit))
  .endCell();

  console.log(new Address(0, stateInitCell.hash()));
}
```

</details>
</TabItem>
<TabItem value="assets/sdk" label="assets/sdk">

:::tip
Примечание: для браузера необходимо установить полифил для `Buffer`.
:::

```js
const NETWORK = "testnet";
const api = await createApi(NETWORK);
const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const storage: PinataStorageParams = {
  pinataApiKey: process.env.PINATA_API_KEY!,
  pinataSecretKey: process.env.PINATA_SECRET!,
};

const sdk = AssetsSDK.create({
  api,
  storage,
  sender,
});

const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));

const forwardPayload = beginCell()
        .storeUint(0, 32) // 0 opcode means we have a comment
        .storeStringTail('Hello, TON!')
        .endCell();

jetton.send(sender, RECEIVER_ADDRESS, toNano(10), { notify: { payload: forwardPayload } });
```

</TabItem>
</Tabs>

### Сжигание жетонов

<Tabs groupId="Сжигание жетонов">
<TabItem value="@ton/ton" label="@ton/ton">

`body` для сжигатие жетона основано на стандарте ([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)). Обратите внимание, что количество знаков после запятой может различаться в зависимости от токена: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

```js
    import { beginCell, Address } from '@ton/ton'
// burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
//               response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//               = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x595f07bc, 32)                // jetton burn op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(toNano("0.001"))              // amount:(VarUInteger 16) - Jetton amount in decimal (decimals = 6 - USDT, 9 - default). Function toNano use decimals = 9 (remember it)
        .storeAddress(Address.parse(Wallet_SRC))  // response_destination:MsgAddress - owner's wallet
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell) - w/o payload typically
        .endCell();
```

Сообщение помещается в следующий запрос:

<Tabs groupId="Сжигание жетонов">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // owner's jetton wallet
            amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a jetton burn body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract,  // owner's jetton wallet
            amount: toNano("0.05").toString(),         // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a jetton burn body
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract, // owner's jetton wallet
      amount: toNano("0.05").toString(), // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64") // payload with a jetton burn body
    }
  ]
})
```

</TabItem>
</Tabs>

- `jettonWalletAddress` - адрес контракта etton Wallet, который определяется на основе контрактов JettonMaser и Wallet
- `amount` - целое число, количество Toncoin для оплаты газа в nanotons.
- `body` - полезная нагрузка для кошелька jetton с кодом операции `burn#595f07bc`

</TabItem>
<TabItem value="assets/sdk" label="assets/sdk">

:::tip
Примечание: для браузера необходимо установить полифил для `Buffer`.
:::

```js
const NETWORK = "testnet";
const api = await createApi(NETWORK);
const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const storage: PinataStorageParams = {
  pinataApiKey: process.env.PINATA_API_KEY!,
  pinataSecretKey: process.env.PINATA_SECRET!,
};

const sdk = AssetsSDK.create({
  api,
  storage,
  sender,
});

const jetton = sdk.openJettonWallet(Address.parse("JETTON_ADDRESS"));

jetton.sendBurn(sender, toNano(10));
```

Или вы можете использовать контракт жетона со встроенными методами:

```ts
const provider = tonConnectUi;

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const client = new TonClient({
  endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
});

const jettonMaster = client.open(
  JettonMinter.createFromAddress(
    Address.parse("[JETTON_WALLET]"),
    new DefaultContentResolver()
  )
);

const jettonWalletAddress = await jettonMaster.getWalletAddress(
  sender.address!
);
const jettonContent = await jettonMaster.getContent();
const jettonDecimals = jettonContent.decimals ?? 9;

const jetton = client.open(JettonWallet.createFromAddress(jettonWalletAddress));

await jetton.sendBurn(
  sender,
  BigInt(1 * 10 ** jettonDecimals)
);

```

</TabItem>
</Tabs>

### Передача NFT

<Tabs groupId="NFT Transfer">
<TabItem value="@ton/ton" label="@ton/ton">
Сообщение `body` должно быть выполнено следующим образом:

```js
import { beginCell, toNano } from '@ton/ton'

//  transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//   forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x5fcc3d14, 32)               // NFT transfer op code 0x5fcc3d14
        .storeUint(0, 64)                        // query_id:uint64
        .storeAddress(Address.parse(NEW_OWNER_WALLET)) // new_owner:MsgAddress
        .storeAddress(Address.parse(Wallet_DST))       // response_destination:MsgAddress
        .storeUint(0, 1)                         // custom_payload:(Maybe ^Cell)
        .storeCoins(1)                           // forward_amount:(VarUInteger 16) (1 nanoTon = toNano("0.000000001"))
        .storeUint(0,1)                          // forward_payload:(Either Cell ^Cell)
        .endCell();
```

`WALLET_DST` - Address - Адрес первоначального владельца NFT для получения избыточного перевода `NFTitem `новому владельцу `NEW_OWNER_WALLET`.

<Tabs groupId="Передача NFT">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: jettonWalletContract, // NFT Item address, which will be transferred
            amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a NFT transfer body
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: NFTitem,  // NFT Item address, which will be transferred
            amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
            payload: body.toBoc().toString("base64") // payload with a NFT transfer body
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem, // NFT Item address, which will be transferred
      amount: toNano("0.05").toString(),  // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64") // payload with a NFT transfer body
    }
  ]
})
```

</TabItem>
</Tabs>

- `NFTitem` - Address - Адрес смарт-контракта элемента NFT, который мы хотим передать новому владельцу `NEW_OWNER_WALLET`.
- `balance` - Целое число, количество Toncoin для оплаты газа в nanotons.
- `body` - полезная нагрузка для контракта NFT

</TabItem>

<TabItem value="assets/sdk" label="assets/sdk">

:::tip
Примечание: для браузера необходимо установить полифил для `Buffer`.
:::

```js
const NETWORK = "testnet";
const api = await createApi(NETWORK);
const provider = new TonConnectUI(); // OR you can use tonConnectUI as a provider from @tonconnect/ui-react

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);

const storage: PinataStorageParams = {
  pinataApiKey: process.env.PINATA_API_KEY!,
  pinataSecretKey: process.env.PINATA_SECRET!,
};

const sdk = AssetsSDK.create({
  api,
  storage,
  sender,
});

const nft = sdk.openNftItem(Address.parse("NFT_ADDRESS"));
const RECEIVER_ADDRESS = Address.parse("RECIEVER_ADDRESS");

nft.send(sender, RECEIVER_ADDRESS);
```

Или вы можете использовать контракт жетона со встроенными методами:

```ts
const client = new TonClient({
  endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
});
const provider = tonConnectUi;
const nftItem = client.open(
  NftItem.createFromAddress(Address.parse("[NFT_WALLET]"))
);

// https://github.com/ton-community/assets-sdk/blob/main/examples/use-tonconnect.ts
const sender = new TonConnectSender(provider);
await nftItem.send(sender, Address.parse("[SENDER_WALLET]"));

// TIP: NFTs can include royalties, allowing creators to earn a percentage from each sale.
// Here is an example of how to get it.
const royalty = await nftItem.getRoyaltyParams();
const royaltyPercent =
  Number(royalty.numerator) / Number(royalty.denominator);
```

</TabItem>
</Tabs>

### Продажа NFT (GetGems)

Вот пример подготовки сообщения и транзакции для продажи на торговой площадке GetGems, согласно контракту [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc).

Чтобы разместить NFT в контракте продажи GetGems, мы должны подготовить специальное тело сообщения `transferNftBody`, которое будет передавать NFT в специальный контракт продажи NFT.

```js
    const transferNftBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
        .storeUint(0, 64) // query_id
        .storeAddress(Address.parse(destinationAddress)) // new_owner - GetGems sale contracts deployer, should never change for this operation
        .storeAddress(Address.parse(walletAddress)) // response_destination for excesses
        .storeBit(0) // we do not have custom_payload
        .storeCoins(toNano("0.2")) // forward_amount
        .storeBit(0) // we store forward_payload is this cell
        .storeUint(0x0fe0ede, 31) // not 32, because previous 0 will be read as do_sale opcode in deployer
        .storeRef(stateInitCell)
        .storeRef(saleBody)
        .endCell();
```

Поскольку сообщение требует много шагов, весь алгоритм огромен и его можно найти здесь:

<details> 
<summary>Показать весь алгоритм для создания тела сообщения о продаже NFT</summary>

```js
import { Address, beginCell, StateInit, storeStateInit, toNano, Cell } from '@ton/ton'

async function main() {
    // func:0.4.4 src:op-codes.fc, imports/stdlib.fc, nft-fixprice-sale-v3r3.fc
    // If GetGems updates its sale smart contract, you will need to obtain the new smart contract from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/nft-fixprice-sale-v3/NftFixpriceSaleV3.source.ts.
    const NftFixPriceSaleV3R3CodeBoc = 'te6ccgECDwEAA5MAART/APSkE/S88sgLAQIBYgIDAgLNBAUCASANDgL30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppj+mfmBg4KYVjgGAASpiFaY+F7xDhgEoYBWmfxwjFsxsLcxsrZBZjgsk5mW8oBfEV4ADJL4dwEuuk4QEWQIEV3RXgAJFZ2Ngp5OOC2HGBFWAA+WjKFkEINjYQQF1AYHAdFmCEAX14QBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkCH6RFtwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhtQRSH6RFtwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWoMAGQwMWyy1DDQ0wchgCCw8tGVIsMAjhSBAlj4I1NBobwE+CMCoLkTsPLRlpEy4gHUMAH7AATwU8fHBbCOXRNfAzI3Nzc3BPoA+gD6ADBTIaEhocEB8tGYBdD6QPoA+kD6ADAwyDICzxZY+gIBzxZQBPoCyXAgEEgQNxBFEDQIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVOCz4wIwMTcowAPjAijAAOMCCMACCAkKCwCGNTs7U3THBZJfC+BRc8cF8uH0ghAFE42RGLry4fX6QDAQSBA3VTIIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVADiODmCEAX14QAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFwVBcAXjMQNBAjCMjLABfLH1AFzxZQA88WAc8WAfoCzMsfyz/J7VQAGDY3EDhHZRRDMHDwBQAgmFVEECQQI/AF4F8KhA/y8ADsIfpEW3CAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FMjLH1Iwyz8kzxZQBM8WE8oAggnJw4D6AhLKAMlxgBjIywUnzxZw+gLLaswl+kRbyYMG+wBxVWD4IwEIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVACHvOFnaiaGmAaY/9IH0gfSB9AGppj+mfmC3ofSB9AH0gfQAYKaFQkNDggPlozJP9Ii2TfSItkf0iLcEIIySsKAVgAKrAQAgb7l72omhpgGmP/SB9IH0gfQBqaY/pn5gBaH0gfQB9IH0AGCmxUJDQ4ID5aM0U/SItlH0iLZH9Ii2F4ACFiBqqiU'
    const NftFixPriceSaleV3R3CodeCell = Cell.fromBoc(Buffer.from(NftFixPriceSaleV3R3CodeBoc, 'base64'))[0]

    const marketplaceAddress = Address.parse('EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS'); // GetGems Address
    const marketplaceFeeAddress = Address.parse('EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS'); // GetGems Address for Fees
    const destinationAddress = Address.parse("EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR"); // GetGems sale contracts deployer

    const walletAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const royaltyAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const nftAddress = Address.parse('EQCUWoe7hLlklVxH8gduCf45vPNocsjRP4wbX42UJ0Ja0S2f');
    const price = toNano("5"); // 5 TON

    const feesData = beginCell()
        .storeAddress(marketplaceFeeAddress)
        // 5% - GetGems fee
        .storeCoins(price / BigInt(100) * BigInt(5))
        .storeAddress(royaltyAddress)
        // 5% - Royalty, can be changed
        .storeCoins(price / BigInt(100) * BigInt(5))
        .endCell();

    const saleData = beginCell()
        .storeBit(0) // is_complete
        .storeUint(Math.round(Date.now() / 1000), 32) // created_at
        .storeAddress(marketplaceAddress) // marketplace_address
        .storeAddress(nftAddress) // nft_address
        .storeAddress(walletAddress) // previous_owner_address
        .storeCoins(price) // full price in nanotons
        .storeRef(feesData) // fees_cell
        .storeUint(0, 32) // sold_at
        .storeUint(0, 64) // query_id
        .endCell();

    const stateInit: StateInit = {
        code: NftFixPriceSaleV3R3CodeCell,
        data: saleData
    };
    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    // not needed, just for example
    const saleContractAddress = new Address(0, stateInitCell.hash());

    const saleBody = beginCell()
        .storeUint(1, 32) // just accept coins on deploy
        .storeUint(0, 64)
        .endCell();

    const transferNftBody = beginCell()
        .storeUint(0x5fcc3d14, 32) // Opcode for NFT transfer
        .storeUint(0, 64) // query_id
        .storeAddress(destinationAddress) // new_owner
        .storeAddress(walletAddress) // response_destination for excesses
        .storeBit(0) // we do not have custom_payload
        .storeCoins(toNano("0.2")) // forward_amount
        .storeBit(0) // we store forward_payload is this cell
        .storeUint(0x0fe0ede, 31) // not 32, because we stored 0 bit before | do_sale opcode for deployer
        .storeRef(stateInitCell)
        .storeRef(saleBody)
        .endCell();
}
```

</details>

Подготовленный `transferNftBody` должен быть отправлен в контракт NFT Item с не менее чем 1,08 TON, для успешной обработки. Излишки будут возвращены в кошелек отправителя.

<Tabs groupId="Проджажа NFT по фиксированной цене">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: NFTitem, //address of the NFT Item contract, that should be placed on market
            amount: toNano("0.3").toString(), // amount that will require on gas fees, excess will be return
            payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: NFTitem, //address of NFT Item contract, that should be placed on market
            amount: toNano("0.3").toString(), // amount that will require on gas fees, excess will be return
            payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>

<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem, //address of NFT Item contract, that should be placed on market
      amount: toNano("0.3").toString(), // amount that will require on gas fees, excess will be return
      payload: transferNftBody.toBoc().toString("base64") // payload with the transferNftBody message
    }
  ]
})
```

</TabItem>
</Tabs>

### Покупка NFT (GetGems)

<Tabs groupId="NFT Buy tabs">
<TabItem value="@ton/ton" label="@ton/ton">

Процесс покупки NFT для контракта продажи [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc) может быть выполнен с помощью обычного перевода без полезной нагрузки, единственное, что важно — это точная сумма TON, которая рассчитывается следующим образом: `buyAmount = Nftprice TON + 1.0 TON`.

<Tabs groupId="Покупка NFT">
<TabItem value="tonconnect-react-ui" label="@tonconnect/react-ui">

```js
import { useTonConnectUI } from '@tonconnect/ui-react';
import { toNano } from '@ton/ton'

const myTransaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
            amount: toNano(buyAmount).toString(), // NFT Price + exactly 1 TON, excess will be returned
        }
    ]
}

export const Settings = () => {
    const [tonConnectUI, setOptions] = useTonConnectUI();

    return (
        <div>
            <button onClick={() => tonConnectUI.sendTransaction(myTransaction)}>
                Send transaction
            </button>
        </div>
    );
};
```

</TabItem>

<TabItem value="tonconnect-ui" label="@tonconnect/ui">

```js
import TonConnectUI from '@tonconnect/ui'
import { toNano } from '@ton/ton'

const transaction = {
    validUntil: Math.floor(Date.now() / 1000) + 360,
    messages: [
        {
            address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
            amount: toNano(buyAmount).toString(), // NFT Price + exactly 1 TON, excess will be returned
        }
    ]
}

const result = await tonConnectUI.sendTransaction(transaction)
```

</TabItem>
<TabItem value="tonconnect-sdk" label="@tonconnect/sdk">

```js
await connector.sendTransaction({
validUntil: Math.floor(Date.now() / 1000) + 360,
messages: [
    {
        address: nftSaleContract,  // NFT Sale contract, that is current desired NFT Item
        amount: toNano(buyAmount).toString(), // NFT Price + exactly 1 TON, excess will be returned
    }
]
})
```

</TabItem>
</Tabs>

</TabItem>
<TabItem value="assets/sdk" label="assets/sdk">

:::tip
Примечание: для браузера необходимо установить полифил для `Buffer`.
:::

```js
const nft = sdk.openNftSale(Address.parse("NFT_ADDRESS"));
nft.sendBuy(sdk.sender!, { queryId: BigInt(1) })
```

</TabItem>
</Tabs>

## TON Connect Python SDK

В качестве примеров на Python можно использовать [PyTonConnect](https://github.com/XaBbl4/pytonconnect) и [pytoniq](https://github.com/yungwine/pytoniq).

```python
    from pytoniq_core import Address
    from pytonconnect import TonConnect
```

:::tip
Прочитать примеры [исходного кода](https://github.com/yungwine/ton-connect-examples/blob/master/main.py).
:::

### Обычный перевод TON

```python
connector = TonConnect(
    manifest_url='https://raw.githubusercontent.com/XaBbl4/pytonconnect/main/pytonconnect-manifest.json')
is_connected = await connector.restore_connection()

transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        {
            'address' :'0:0000000000000000000000000000000000000000000000000000000000000000', # destination address
            'amount' : 1000000000,  # amount should be specified in nanocoins, 1 TON
        }
    ]
}
```

### Перевод с комментарием

В первую очередь реализуйте сообщение с комментарием с помощью следующей функции:

```python
    def get_comment_message(destination_address: str, amount: int, comment: str) -> dict:

        data = {
            'address': destination_address,
            'amount': str(amount),
            'payload': urlsafe_b64encode(
                begin_cell()
                .store_uint(0, 32)  # op code for comment message
                .store_string(comment)  # store comment
                .end_cell()  # end cell
                .to_boc()  # convert it to boc
            )
            .decode()  # encode it to urlsafe base64
        }

        return data
```

Конечное тело транзакции для перевода с комментарием:

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        get_comment_message(
            destination_address='0:0000000000000000000000000000000000000000000000000000000000000000',
            amount=int(0.01 * 10**9),  # amount should be specified in nanocoins
            comment='hello world!'
        )
    ]
}
```

:::tip
Узнайте больше об [адресах смарт-контрактов TON](/v3/documentation/smart-contracts/addresses).
:::

### Перевод жетонов

Пример функции для построения транзакции перевода жетонов. Обратите внимание, что количество знаков после запятой может различаться в разных токенах: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

```python
from pytoniq_core import begin_cell
from base64 import urlsafe_b64encode

def get_jetton_transfer_message(jetton_wallet_address: str, recipient_address: str, transfer_fee: int, jettons_amount: int, response_address: str = None) -> dict:
    data = {
        'address': jetton_wallet_address,
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
        begin_cell()
        .store_uint(0xf8a7ea5, 32)  # op code for jetton transfer message
        .store_uint(0, 64)  # query_id
        .store_coins(jettons_amount) # Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Exapmple: 1 USDT = 1 * 10**6 and 1 TON = 1 * 10**9
        .store_address(recipient_address)  # destination address
        .store_address(response_address or recipient_address)  # address send excess to
        .store_uint(0, 1)  # custom payload
        .store_coins(1)  # forward amount
        .store_uint(0, 1)  # forward payload
        .end_cell()  # end cell
        .to_boc()  # convert it to boc
        )
        .decode()  # encode it to urlsafe base64
    }

    return data
```

Окончательное тело транзакции:

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        get_jetton_transfer_message(
        jetton_wallet_address='EQCXsVvdxTVmSIvYv4tTQoQ-0Yq9mERGTKfbsIhedbN5vTVV',
        recipient_address='0:0000000000000000000000000000000000000000000000000000000000000000',
        transfer_fee=int(0.07 * 10**9),
        jettons_amount=int(0.01 * 10**9),  # replace 9 for jetton decimal. For example for USDT it should be (amount * 10**6)
        response_address=wallet_address
        ),
    ]
}

```

### Сжигание жетонов

Пример функции для построения транзакции сжигания жетонов. Обратите внимание, что количество знаков после запятой может различаться в разных токенах: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

```python
from pytoniq_core import begin_cell
from base64 import urlsafe_b64encode

def get_jetton_burn_message(jetton_wallet_address: str, transfer_fee: int, jettons_amount: int, response_address: str = None) -> dict:
    data = {
        'address': jetton_wallet_address,
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
            begin_cell()
            .store_uint(0x595f07bc, 32)  # op code for jetton burn message
            .store_uint(0, 64)  # query_id
            .store_coins(jettons_amount) # Jetton amount in decimal (decimals = 6 - USDT, 9 - default)
            .store_address(response_address)  # address send excess to
            .end_cell()  # end cell
            .to_boc()  # convert it to boc
        )
        .decode()  # encode it to urlsafe base64
    }
    return data
```

Окончательное тело транзакции:

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        get_jetton_burn_message(
            jetton_wallet_address='EQCXsVvdxTVmSIvYv4tTQoQ-0Yq9mERGTKfbsIhedbN5vTVV',
            transfer_fee=int(0.07 * 10 ** 9),
            jettons_amount=int(0.01 * 10 ** 9),  # replace 9 for jetton decimal. For example for jUSDT it should be (amount * 10**6)
            response_address=wallet_address
        ),
    ]
}
```

### Передача NFT

Пример функции для транзакции перевода NFT:

```python
from pytoniq_core import begin_cell
from base64 import urlsafe_b64encode


def get_nft_transfer_message(nft_address: str, recipient_address: str, transfer_fee: int, response_address: str = None) -> dict:
    data = {
        'address': nft_address,
        'amount': str(transfer_fee),
        'payload': urlsafe_b64encode(
            begin_cell()
            .store_uint(0x5fcc3d14, 32)  # op code for nft transfer message
            .store_uint(0, 64)  # query_id
            .store_address(recipient_address)  # new owner
            .store_address(response_address or recipient_address)  # address send excess to
            .store_uint(0, 1)  # custom payload
            .store_coins(1)  # forward amount (0.000000001 * 10 ** 9) = 1 nanoTon
            .store_uint(0, 1)  # forward payload
            .end_cell()  # end cell
            .to_boc()  # convert it to boc
        )
        .decode()  # encode it to urlsafe base64
    }
    return data

```

Окончательное тело транзакции:

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        get_nft_transfer_message(
            nft_address='EQDrA-3zsJXTfGo_Vdzg8d07Da4vSdHZllc6W9qvoNoMstF-',
            recipient_address='0:0000000000000000000000000000000000000000000000000000000000000000',
            transfer_fee=int(0.07 * 10**9),
            response_address=wallet_address
        ),
    ]
}
```

### Продажа NFT (GetGems)

Вот пример подготовки сообщения и транзакции для продажи на торговой площадке GetGems в соответствии с контрактом [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc).

Чтобы разместить NFT на контракте продажи GetGems, мы должны подготовить специальное тело сообщения `transferNftBody`, которое будет переводить NFT на специальный контракт продажи NFT.

<details> 
<summary>Пример создания тела продажи NFT</summary>

```python
import time
from base64 import urlsafe_b64encode

from pytoniq_core.boc import Cell, begin_cell, Address
from pytoniq_core.tlb import StateInit


def get_sale_body(wallet_address: str, royalty_address: str, nft_address: str, price: int, amount: int):
    # func:0.4.4 src:op-codes.fc, imports/stdlib.fc, nft-fixprice-sale-v3r3.fc
    # If GetGems updates its sale smart contract, you will need to obtain the new smart contract from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/nft-fixprice-sale-v3/NftFixpriceSaleV3.source.ts.
    nft_sale_code_cell = Cell.one_from_boc('te6ccgECDwEAA5MAART/APSkE/S88sgLAQIBYgIDAgLNBAUCASANDgL30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppj+mfmBg4KYVjgGAASpiFaY+F7xDhgEoYBWmfxwjFsxsLcxsrZBZjgsk5mW8oBfEV4ADJL4dwEuuk4QEWQIEV3RXgAJFZ2Ngp5OOC2HGBFWAA+WjKFkEINjYQQF1AYHAdFmCEAX14QBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkCH6RFtwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhtQRSH6RFtwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWoMAGQwMWyy1DDQ0wchgCCw8tGVIsMAjhSBAlj4I1NBobwE+CMCoLkTsPLRlpEy4gHUMAH7AATwU8fHBbCOXRNfAzI3Nzc3BPoA+gD6ADBTIaEhocEB8tGYBdD6QPoA+kD6ADAwyDICzxZY+gIBzxZQBPoCyXAgEEgQNxBFEDQIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVOCz4wIwMTcowAPjAijAAOMCCMACCAkKCwCGNTs7U3THBZJfC+BRc8cF8uH0ghAFE42RGLry4fX6QDAQSBA3VTIIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVADiODmCEAX14QAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFwVBcAXjMQNBAjCMjLABfLH1AFzxZQA88WAc8WAfoCzMsfyz/J7VQAGDY3EDhHZRRDMHDwBQAgmFVEECQQI/AF4F8KhA/y8ADsIfpEW3CAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FMjLH1Iwyz8kzxZQBM8WE8oAggnJw4D6AhLKAMlxgBjIywUnzxZw+gLLaswl+kRbyYMG+wBxVWD4IwEIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVACHvOFnaiaGmAaY/9IH0gfSB9AGppj+mfmC3ofSB9AH0gfQAYKaFQkNDggPlozJP9Ii2TfSItkf0iLcEIIySsKAVgAKrAQAgb7l72omhpgGmP/SB9IH0gfQBqaY/pn5gBaH0gfQB9IH0AGCmxUJDQ4ID5aM0U/SItlH0iLZH9Ii2F4ACFiBqqiU')

    # fees cell

    marketplace_address = Address('EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS')
    marketplace_fee_address = Address('EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS')
    destination_address = Address('EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR')

    wallet_address = Address(wallet_address)
    royalty_address = Address(royalty_address)
    nft_address = Address(nft_address)

    marketplace_fee = int(price * 5 / 100)  # 5%
    royalty_fee = int(price * 5 / 100)  # 5%

    fees_data_cell = (begin_cell()
                      .store_address(marketplace_fee_address)
                      .store_coins(marketplace_fee)
                      .store_address(royalty_address)
                      .store_coins(royalty_fee)
                      .end_cell())


    sale_data_cell = (begin_cell()
                      .store_bit_int(0) # is_complete
                      .store_uint(int(time.time()), 32) # created_at
                      .store_address(marketplace_address)
                      .store_address(nft_address)
                      .store_address(wallet_address)
                      .store_coins(price)
                      .store_ref(fees_data_cell)
                      .store_uint(0, 32) # sold_at
                      .store_uint(0, 64) # query_id
                      .end_cell())

    # not needed, just for example
    state_init_cell = StateInit(code=nft_sale_code_cell, data=sale_data_cell).serialize()

    sale_body = (begin_cell()
                 .store_uint(1, 32) # just accept coins on deploy
                 .store_uint(0, 64)
                 .end_cell())

    transfer_nft_body = (begin_cell()
                         .store_uint(0x5fcc3d14, 32) # Opcode for NFT transfer
                         .store_uint(0, 64) # query_id
                         .store_address(destination_address)
                         .store_address(wallet_address)
                         .store_bit_int(0) # we do not have custom_payload
                         .store_coins(int(0.2 * 10**9)) # forward_amount
                         .store_bit_int(0) # we store forward_payload is this cell
                         .store_uint(0x0fe0ede, 31) # not 32, because we stored 0 bit before | do_sale opcode for deployer
                         .store_ref(state_init_cell)
                         .store_ref(sale_body)
                         .end_cell())

    data = {
        'address': nft_address.to_str(),
        'amount': str(amount),
        'payload': urlsafe_b64encode(transfer_nft_body.to_boc()).decode()
    }

    return data
```

</details>

Окончательное тело транзакции:

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        get_sale_body(
            nft_address='EQDrA-3zsJXTfGo_Vdzg8d07Da4vSdHZllc6W9qvoNoMstF-',
            wallet_address='0:0000000000000000000000000000000000000000000000000000000000000000',
            royalty_address='0:0000000000000000000000000000000000000000000000000000000000000000',
            price=int(5 * 10**9),
            amount=int(0.3 * 10**9)
        ),
    ]
}
```

### Покупка NFT (GetGems)

Процесс покупки NFT для контракта продажи [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc) может быть выполнен с помощью обычного перевода без полезной нагрузки, важна только точная сумма TON, которая рассчитывается следующим образом: `buyAmount = Nftprice TON + 1.0 TON`.

```python
transaction = {
    'valid_until': int(time.time() + 3600),
    'messages': [
        {
            'address': nft_address,
            'amount': buyAmount,
        }
    ]
}
```

## TON Connect Go SDK

Примеры Go используют [tonconnect](https://github.com/cameo-engineering/tonconnect) и [tonutils-go](https://github.com/xssnick/tonutils-go).

```go
import "github.com/cameo-engineering/tonconnect"
import "github.com/xssnick/tonutils-go/address"
```

:::tip
Прочитайте примеры [tonconnect](https://github.com/cameo-engineering/tonconnect/blob/master/examples/basic/main.go) и [tonutils-go](https://github.com/xssnick/tonutils-go?tab=readme-ov-file#how-to-use).
:::

Там вы можете узнать, как создать сеанс tonconnect и отправить транзакцию, созданную с помощью сообщений.

```go
s, _ := tonconnect.NewSession()
// create ton links
// ...
// create new message msg and transaction
boc, _ := s.SendTransaction(ctx, *tx)
```

В дальнейших примерах будут созданы только сообщения и транзакции.

### Обычный перевод TON

Пример функции для создания обычного сообщения о переводе TON:

```go
import (
	"fmt"

	"github.com/cameo-engineering/tonconnect"
)

func Transfer(dest string, amount uint64) (*tonconnect.Message, error) {
	msg, err := tonconnect.NewMessage(
		dest,
		fmt.Sprintf("%d", amount), // nanocoins to transfer/compute message
	)
	return msg, err
}
```

Окончательное тело транзакции:

```go
msg, err := Transfer("0QBZ_35Wy144n2GBM93YpcV4KOKcIjDJk8DdX4kyXEEHcbLZ", uint64(math.Pow(10, 9)))
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

### Перевод с комментарием

Пример функции для создания сообщения о переводе с комментарием:

```go
import (
	"fmt"

	"github.com/cameo-engineering/tonconnect"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

func TransferWithComment(dest string, amount uint64, comment string) (*tonconnect.Message, error) {
	payload, _ := cell.BeginCell().
		MustStoreUInt(0, 32).
		MustStoreStringSnake(comment).
		EndCell().MarshalJSON()
	msg, err := tonconnect.NewMessage(
		dest,
		fmt.Sprintf("%d", amount), // nanocoins to transfer/compute message
		tonconnect.WithPayload(payload))
	return msg, err
}
```

Окончательное тело транзакции:

```go
msg, err := TransferWithComment("0QBZ_35Wy144n2GBM93YpcV4KOKcIjDJk8DdX4kyXEEHcbLZ", uint64(math.Pow(10, 9)), "new comment")
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

### Перевод жетонов

Пример функции для сообщения о переводе жетонов. Обратите внимание, что количество знаков после запятой может различаться в зависимости от токена: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

```go
import (
	"fmt"

	"github.com/cameo-engineering/tonconnect"
	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

func JettonTransferMessage(jetton_wallet_address string, amount uint64,
	jettons_amount uint64, recipient_address, response_address string,
	fwd_amount uint64, fwd_payload *cell.Cell) (*tonconnect.Message, error) {
	payload, _ := cell.BeginCell().
		MustStoreUInt(0xf8a7ea5, 32). // op code for jetton transfer message (op::transfer)
		MustStoreUInt(0, 64).         // query_id
		MustStoreCoins(jettons_amount). // Jetton amount for transfer (decimals = 6 - USDT, 9 - default). Exapmple: 1 USDT = 1 * 10**6 and 1 TON = 1 * 10**9
		MustStoreAddr(address.MustParseAddr(recipient_address)). // address send excess to
		MustStoreAddr(address.MustParseAddr(response_address)).
		MustStoreUInt(0, 1).        // custom payload
		MustStoreCoins(fwd_amount). // set 0 if don't want transfer notification
		MustStoreMaybeRef(fwd_payload).
		EndCell().MarshalJSON()

	msg, err := tonconnect.NewMessage(
		jetton_wallet_address,
		fmt.Sprintf("%d", amount), // nanocoins to transfer/compute message
		tonconnect.WithPayload(payload))

	if err != nil {
		return nil, err
	}

	return msg, nil
}
```

Окончательное тело транзакции:

```go
msg, err := JettonTransferMessage("kQA8Q7m_pSNPr6FcqRYxllpAZv-0ieXy_KYER2iP195hBXiX",
                                    uint64(math.Pow(10, 9)),
                                    uint64(10),
                                    "0QBZ_35Wy144n2GBM93YpcV4KOKcIjDJk8DdX4kyXEEHcbL2",
                                    "EQBuObr2M7glm08w6cBGjIuuCbmvBFGwuVs6qb3AQpac9XpX",
                                    uint64(0), nil)
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

### Сжигание жетонов

Пример функции для сообщения о сжигани жетона. Обратите внимание, что количество знаков после запятой может различаться в зависимости от токена: например, USDT использует 6 знаков после запятой (1 USDT = 1 \* 10 \*\* 6), а TON использует 9 знаков после запятой (1 TON = 1 \* 10 \*\* 9).

```go
import (
	"fmt"

	"github.com/cameo-engineering/tonconnect"
	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

func JettonBurnMessage(jetton_wallet_address string, amount uint64,
	jettons_amount uint64, response_address string) (*tonconnect.Message, error) {

	payload, _ := cell.BeginCell().
		MustStoreUInt(0xf8a7ea5, 32).                           // op code for jetton burn message (op::burn)
		MustStoreUInt(0, 64).                                   // query_id
		MustStoreCoins(jettons_amount).                         // Jetton amount in decimal (decimals = 6 - USDT, 9 - default)
		MustStoreAddr(address.MustParseAddr(response_address)). // address send excess to
		EndCell().MarshalJSON()

	msg, err := tonconnect.NewMessage(
		jetton_wallet_address,
		fmt.Sprintf("%d", amount), // nanocoins to transfer/compute message
		tonconnect.WithPayload(payload))

	if err != nil {
		return nil, err
	}

	return msg, nil
}
```

Окончательное тело транзакции:

```go
msg, err := JettonBurnMessage("kQA8Q7m_pSNPr6FcqRYxllpAZv-0ieXy_KYER2iP195hBXiX",
                                uint64(math.Pow(10, 9)),
                                uint64(10),
                                "EQBuObr2M7glm08w6cBGjIuuCbmvBFGwuVs6qb3AQpac9XpX")
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

### Передача NFT

Пример функции для сообщения о передаче NFT:

```go
import (
	"fmt"

	"github.com/cameo-engineering/tonconnect"
	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

func NftTransferMessage(nft_address string, amount uint64, recipient_address, response_address string,
	fwd_amount uint64, fwd_payload *cell.Cell) (*tonconnect.Message, error) {

	payload, _ := cell.BeginCell().
		MustStoreUInt(0x5fcc3d14, 32).                           // op code for nft transfer message (op::transfer())
		MustStoreUInt(0, 64).                                    // query_id
		MustStoreAddr(address.MustParseAddr(recipient_address)). // new owner
		MustStoreAddr(address.MustParseAddr(response_address)).  // address send excess to
		MustStoreUInt(0, 1).                                     // custom payload
		MustStoreCoins(fwd_amount).                              // set 0 if don't want transfer notification
		MustStoreMaybeRef(fwd_payload).
		EndCell().MarshalJSON()

	msg, err := tonconnect.NewMessage(
		nft_address,
		fmt.Sprintf("%d", amount), // nanocoins to transfer/compute message
		tonconnect.WithPayload(payload))

	if err != nil {
		return nil, err
	}

	return msg, nil
}
```

Окончательное тело транзакции:

```go
msg, err := NftTransferMessage("EQDrA-3zsJXTfGo_Vdzg8d07Da4vSdHZllc6W9qvoNoMstF-",
                                uint64(math.Pow(10, 9)),
                                "0QBZ_35Wy144n2GBM93YpcV4KOKcIjDJk8DdX4kyXEEHcbL2",
                                "0QBZ_35Wy144n2GBM93YpcV4KOKcIjDJk8DdX4kyXEEHcbL2",
                                uint64(0), nil)
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

### Продажа NFT (GetGems)

Вот пример подготовки сообщения и транзакции для продажи на торговой площадке GetGems в соответствии с контрактом [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc).

Чтобы разместить NFT на контракте продажи GetGems, мы должны подготовить специальное тело сообщения `transferNftBody`, которое будет переводить NFT на специальный контракт продажи NFT.

```go
transferNftBody := cell.BeginCell().
    MustStoreUInt(0x5fcc3d14, 32).        // opcode for NFT transfer
    MustStoreUInt(0, 64).                 // query_id
    MustStoreAddress(destinationAddress). // new_owner - GetGems sale contracts deployer, should never change for this operation
    MustStoreAddress(walletAddress).      // response_destination for excesses
    MustStoreUInt(0, 1).                  // we do not have custom_payload
    MustStoreCoins(0.2*math.Pow(10, 9)).  // forward_amount
    MustStoreUInt(0, 1).                  // we store forward_payload is this cell
    MustStoreUInt(0x0fe0ede, 31).         // not 32, because previous 0 will be read as do_sale opcode in deployer (op::do_sale)
    MustStoreRef(stateInitCell).
    MustStoreRef(saleBody).
    EndCell()
```

Поскольку сообщение требует много шагов, весь алгоритм огромен и его можно найти здесь:

<details> 
<summary>Показать весь алгоритм для создания тела сообщения о продаже NFT</summary>

```go
import (
	"fmt"
	"math"
	"time"

	"github.com/cameo-engineering/tonconnect"
	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/tlb"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

func NftSaleMessage(wallet, royalty, nft string, amount, price uint64) (*tonconnect.Message, error) {
    // func:0.4.4 src:op-codes.fc, imports/stdlib.fc, nft-fixprice-sale-v3r3.fc
    // If GetGems updates its sale smart contract, you will need to obtain the new smart contract from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/nft-fixprice-sale-v3/NftFixpriceSaleV3.source.ts.
	fixPriceV3R3Code := new(cell.Cell)
	fixPriceV3R3Code.UnmarshalJSON([]byte("te6ccgECDwEAA5MAART/APSkE/S88sgLAQIBYgIDAgLNBAUCASANDgL30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppj+mfmBg4KYVjgGAASpiFaY+F7xDhgEoYBWmfxwjFsxsLcxsrZBZjgsk5mW8oBfEV4ADJL4dwEuuk4QEWQIEV3RXgAJFZ2Ngp5OOC2HGBFWAA+WjKFkEINjYQQF1AYHAdFmCEAX14QBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkCH6RFtwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhtQRSH6RFtwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWoMAGQwMWyy1DDQ0wchgCCw8tGVIsMAjhSBAlj4I1NBobwE+CMCoLkTsPLRlpEy4gHUMAH7AATwU8fHBbCOXRNfAzI3Nzc3BPoA+gD6ADBTIaEhocEB8tGYBdD6QPoA+kD6ADAwyDICzxZY+gIBzxZQBPoCyXAgEEgQNxBFEDQIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVOCz4wIwMTcowAPjAijAAOMCCMACCAkKCwCGNTs7U3THBZJfC+BRc8cF8uH0ghAFE42RGLry4fX6QDAQSBA3VTIIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVADiODmCEAX14QAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFwVBcAXjMQNBAjCMjLABfLH1AFzxZQA88WAc8WAfoCzMsfyz/J7VQAGDY3EDhHZRRDMHDwBQAgmFVEECQQI/AF4F8KhA/y8ADsIfpEW3CAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FMjLH1Iwyz8kzxZQBM8WE8oAggnJw4D6AhLKAMlxgBjIywUnzxZw+gLLaswl+kRbyYMG+wBxVWD4IwEIyMsAF8sfUAXPFlADzxYBzxYB+gLMyx/LP8ntVACHvOFnaiaGmAaY/9IH0gfSB9AGppj+mfmC3ofSB9AH0gfQAYKaFQkNDggPlozJP9Ii2TfSItkf0iLcEIIySsKAVgAKrAQAgb7l72omhpgGmP/SB9IH0gfQBqaY/pn5gBaH0gfQB9IH0AGCmxUJDQ4ID5aM0U/SItlH0iLZH9Ii2F4ACFiBqqiU"))

	marketplaceAddress := address.MustParseAddr("EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS")    // GetGems Address
	marketplaceFeeAddress := address.MustParseAddr("EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS") // GetGems Address for Fees
	destinationAddress := address.MustParseAddr("EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR")    // GetGems sale contracts deployer

	walletAddress := address.MustParseAddr(wallet)
	royaltyAddress := address.MustParseAddr(royalty)
	nftAddress := address.MustParseAddr(nft)

	feesData := cell.BeginCell().
		MustStoreAddr(marketplaceFeeAddress).
		// 5% - GetGems fee
		MustStoreCoins(price * 100 * 5).
		MustStoreAddr(royaltyAddress).
		// 5% - Royalty, can be changed
		MustStoreCoins(price / 100 * 5).
		EndCell()

	saleData := cell.BeginCell().
		MustStoreUInt(0, 1).                                // is_complete
		MustStoreUInt(uint64(time.Now().UTC().Unix()), 32). // created_at
		MustStoreAddr(marketplaceAddress).                  // marketplace_address
		MustStoreAddr(nftAddress).                          // nft_address
		MustStoreAddr(walletAddress).                       // previous_owner_address
		MustStoreCoins(price).                              // full price in nanotons
		MustStoreRef(feesData).                             // fees_cell
		MustStoreUInt(0, 32).                               // sold_at
        MustStoreUInt(0, 64).                               // query_id
		EndCell()

	stateInit := &tlb.StateInit{
		Data: saleData,
		Code: fixPriceV3R3Code,
	}

	stateInitCell, err := tlb.ToCell(stateInit)
	if err != nil {
		return nil, err
	}

	// not needed, just for example
	// saleContractAddress := address.NewAddress(0, 0, stateInitCell.Hash())

	saleBody := cell.BeginCell().
		MustStoreUInt(1, 32). // just accept coins on deploy
		MustStoreUInt(0, 64).
		EndCell()

	transferNftBody, err := cell.BeginCell().
		MustStoreUInt(0x5fcc3d14, 32).             // opcode for NFT transfer
		MustStoreUInt(0, 64).                      // query_id
		MustStoreAddr(destinationAddress).         // new_owner - GetGems sale contracts deployer, should never change for this operation
		MustStoreAddr(walletAddress).              // response_destination for excesses
		MustStoreUInt(0, 1).                       // we do not have custom_payload
		MustStoreCoins(uint64(0.2*math.Pow(10, 9))). // forward_amount
		MustStoreUInt(0, 1).                       // we store forward_payload is this cell
		MustStoreUInt(0x0fe0ede, 31).              // not 32, because previous 0 will be read as do_sale opcode in deployer (op::do_sale)
		MustStoreRef(stateInitCell).
		MustStoreRef(saleBody).
		EndCell().MarshalJSON()

	if err != nil {
		return nil, err
	}

	msg, err := tonconnect.NewMessage(
		nftAddress.String(),
		fmt.Sprintf("%d", amount),
		tonconnect.WithPayload(transferNftBody))

	if err != nil {
		return nil, err
	}

	return msg, nil
}
```

Окончательное тело транзакции:

```go
msg, err := NftSaleMessage("EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162",
                            "EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162",
                            "EQCUWoe7hLlklVxH8gduCf45vPNocsjRP4wbX42UJ0Ja0S2f",
                            uint64(0.3*math.Pow(10, 9)), uint64(5*math.Pow(10, 9)))
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

</details>

### Покупка NFT (GetGems)

Процесс покупки NFT для контракта продажи [nft-fixprice-sale-v3r3](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r3.fc) может быть выполнен с помощью обычного перевода без полезной нагрузки, важна только точная сумма TON, которая рассчитывается следующим образом: `buyAmount = Nftprice TON + 1.0 TON`.

```go
msg, err := tonconnect.NewMessage(nftAddress, buyAmount)
if err != nil {
    log.Fatal(err)
}
tx, err := tonconnect.NewTransaction(
    tonconnect.WithTimeout(10*time.Minute),
    tonconnect.WithTestnet(),
    tonconnect.WithMessage(*msg),
)
if err != nil {
    log.Fatal(err)
}
```

## Авторы

- Примеры JavaScript, предоставленные [@aSpite](https://t.me/aspite)
- Примеры на Python предоставлены [@yunwine](https://t.me/yungwine)
- Примеры Go предоставлены [@gleb498](https://t.me/gleb498)

## См. также

- [TON Connect SDK](/v3/guidelines/ton-connect/guidelines/developers)
- [TON Connect - Отправка сообщений](/v3/guidelines/ton-connect/guidelines/sending-messages)
- [Разработка смарт-контрактов — отправка сообщений (низкий уровень)](/v3/documentation/smart-contracts/message-management/sending-messages)
- [Обработка жетонов TON](/v3/guidelines/dapps/asset-processing/jettons)
- [Обработка NFT на TON](/v3/guidelines/dapps/asset-processing/nft-processing/nfts)
