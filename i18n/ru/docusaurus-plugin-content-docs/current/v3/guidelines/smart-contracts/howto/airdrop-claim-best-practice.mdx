import Feedback from '@site/src/components/Feedback';

# Руководство Airdrop Claiming

В этой статье мы рассмотрим вымышленное _решение_ для клейма, попытаемся выявить его проблемы с производительностью и решить их. Мы сосредоточимся на взаимодействии контрактов и их влиянии на общую производительность и не будем затрагивать код, аспекты безопасности и другие нюансы. Code, security aspects, and other nuances are beyond the scope of this discussion.

## Claim Machine

:::info
Как работает практически любое решение для клейма? Давайте подумаем.
:::

Пользователь отправляет некое доказательство, пруф того, что он имеет право на клейм. Разработанный алгоритм решения осуществляет проверку доказательства и при ее успешности отправляет жетоны. В данном случае используется [доказательство Меркла](/v3/documentation/data-formats/tlb/exotic-cells#доказательство-меркла), но это вполне могут быть просто подписанные данные или любой другой метод авторизации. Отправка жетонов осуществляется с помощью Jetton wallet и Jetton minter. Также, нужно убедиться, что хитрые пользователи не смогут клеймить дважды – для этого необходим контракт с защитой от двойного списания. И, наверное, заработать немного денег, не так ли? Значит потребуется, по меньшей мере, один кошелек для клейма. Подведем итог:

### Дистрибьютор

Принимает доказательство от пользователя, проверяет его, выпускает жетоны.
State init: `(merkle_root, admin, fee_wallet_address)`.

### Двойное списание

Получает входящее сообщение, возвращает отказ в случае попытки повторного использования. Если проверка пройдена, передает сообщение дальше

### Jetton wallet

Jetton wallet, с которого токены будут отправлены _дистрибьютором_.
Jetton minter выходит за рамки этой статьи.

### Кошелек для комиссии

Любой тип контракта кошелька.

## Архитектура

### V1

The initial design that comes to mind is as follows:

1. Пользователь отправляет доказательство дистрибьютору
2. The distributor verifies the proof and deploys a `double spend` contract.
3. Дистрибьютор передает сообщение контракту двойного списания
4. Контракт двойного списания отправляет `claim_ok` дистрибьютору, если он не был развернут ранее
5. The distributor sends the claim fee to the fee wallet.
6. Дистрибьютор отпускает жетоны пользователю

**NAIVE ART AHEAD!**

Что здесь не так?
Похоже, что цикл избыточен.

### V2

Линейная структура намного лучше:

1. Пользователь разворачивает контракт `двойного списания`, который в свою очередь передает доказательство дистрибьютору
2. Дистрибьютор проверяет адрес отправки смарт-контракта `двойного списания` по state init `(distributor_address, user_address?)`
3. Дистрибьютор проверяет доказательство и выпускает жетоны. В данном случае индекс пользователя должен быть частью доказательства.
4. Дистрибьютор отправляет комиссию на кошелек для оплаты комиссии

**More naive art**

## Оптимизация шардов

Хорошо, у нас что-то получается, однако что насчет оптимизации шардов?

### Что это такое?

Для того чтобы получить базовое представление, рекомендуется ознакомиться со статьей [Создание кошелька для разных шардов](/v3/guidelines/dapps/asset-processing/payments-processing/#создание-кошелька-для-разных-шардов). Вкратце, шард – это четырехбитный префикс адреса контракта. Как в сетевых технологиях. Когда контракт находится в одном сегменте сети, сообщения обрабатываются без маршрутизации, а значит гораздо быстрее.

### Идентификация адресов, которые мы можем контролировать

#### Адрес дистрибьютора

Мы полностью контролируем данные дистрибьютора, поэтому должны иметь возможность поместить их в любой шард. Как это сделать? Помните, что адрес смарт-контракта [определяется его состоянием](/v3/documentation/smart-contracts/addresses#идентификатор-аккаунта). Нужно использовать некоторые поля данных контракта в качестве nonce и продолжать попытки до тех пор, пока не получим желаемый результат. Примером хорошего nonce в реальных контрактах может быть (subwalletId/publicKey) для смарт-контракта кошелька. Любое поле, которое можно изменить после развертывания или которое не влияет на логику контракта (как subwalletId), подойдет для этого. Можно даже создать неиспользуемое поле специально для этой цели, как это делает [vanity-contract](https://github.com/ton-community/vanity-contract).

#### Адрес Jetton wallet

Мы не можем контролировать адрес полученного jetton wallet напрямую. Однако, если мы контролируем адрес дистрибьютора, то можем подобрать его таким образом, чтобы jetton wallet для дистрибьютора оказался в том же шарде. Но как это сделать? Для этого существует [данная библиотека](https://github.com/Trinketer22/turbo-wallet)! В настоящее время она поддерживает только кошельки, но добавить поддержку произвольных контрактов достаточно просто. Посмотрите, как это сделано для [Highload-кошелька V3](https://github.com/Trinketer22/turbo-wallet/blob/44fe7ee4300e37e052871275be8dd41035d45c3a/src/lib/contracts/HighloadWalletV3.ts#L20).

### Смарт-контракт двойное списание

Контракт двойного списания должен быть уникальным для каждого доказательства, поэтому сможем ли мы настроить его на шарде? Let's think about it. Если подумать, то это зависит от структуры доказательства. Первое, что приходит на ум, это та же структура, что и у [mintless jetton](https://github.com/tonkeeper/TEPs2/blob/mintles/text/0177-mintless-jetton-standard.md#handlers):

```
_ amount:Coins start_from:uint48 expired_at:uint48 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;

```

К сожалению, такая настройка не подходит потому, что распределение адресов происходит случайным образом, а все поля будут иметь значимые данные. Но ничто не мешает нам попробовать такой вариант:

```
_ amount:Coins start_from:uint48 expired_at:uint48 nonce:uint64 = AirdropItem;

_ _(HashMap 267 AirdropItem) = Airdrop;
```

или даже:

```
_ amount:Coins start_from:uint48 expired_at:uint48 addr_hash: uint256 = AirdropItem;

_ _(HashMap 64 AirdropItem) = Airdrop;

```

где 64-битный индекс может быть использован в качестве nonce, а адрес становится частью данных для верификации. Таким образом, если данные смарт-контракта двойного списания строятся из `(distributor_address, index)`, где индекс является частью данных, мы по-прежнему имеем исходную надежность, но теперь шард адреса может настраиваться с помощью параметра index.

#### Адрес пользователя

Очевидно, что мы не контролируем адреса пользователей, не так ли? Да, **НО** мы можем сгруппировать их таким образом, чтобы шард пользовательских адресов совпадал с шардом дистрибьюторов. В таком случае каждый дистрибьютор будет обрабатывать _merkle root_, состоящий исключительно из пользователей его шарда.

Here's the improved and more polished version of your text:

#### Резюме

Мы можем поместить `double_spend -> dist -> dist_jetton` часть цепочки в один шард. Для других шардов останется только `dist_jetton -> user_jetton -> user_wallet`.

### Как же развернуть такую установку

Давайте выполним по шагам: Давайте выполним по шагам: Давайте выполним по шагам: Одно из требований заключается в том, чтобы контракт _дистрибьютора_ имел обновляемый _merkle root_.

1. Разверните смарт-контракт дистрибьютора в каждом шарде (0-15) – в пределах тех же шардов, что и их jetton wallet, используя начальный `merkle_root` в качестве nonce
2. Group users by their distributor shard.
3. Для каждого пользователя найдите такой индекс, чтобы контракт _двойного списания_ `(distributor, index)` оказался в том же шарде, что и адрес пользователя
4. Сгенерируйте _merkle roots_ с индексами из шага выше
5. Обновите _дистрибьюторов_ в соответствии с _merkle roots_

Теперь все должно быть в порядке!

### V3

1. Index tuning enables users to deploy the _double spend_ contract in the same shard.
2. Дистрибьютор в шарде пользователя проверяет адрес отправки `двойного списания` по state init `(distributor_address, index)`
3. Дистрибьютор отправляет комиссию на кошелек для оплаты комиссии
4. Дистрибьютор проверяет доказательство и выпускает жетоны через jetton wallet на том же шарде.

**More naive art**

Is there anything wrong with this approach? Давайте посмотрим внимательно.\
...\
Давайте посмотрим внимательно.\
...\
Yes, there is! Существует только один кошелек для комиссии – таким образом сборы комиссий скапливаются в очередь на одном шарде. Это могло бы стать катастрофой! (Интересно, случалось ли такое в реальности?)

### V4

1. То же самое, что и в V3, но теперь 16 кошельков для получения комиссии, каждый из которых находится в том же шарде, что и его _дистрибьютор_
2. Придется сделать адрес _кошелька для комиссии_ обновляемым

**A bit more art**

Как вам теперь? LGTM.

## Что дальше?

Мы всегда можем пойти еще дальше. Ознакомьтесь с кастомным смарт-контрактом [jetton wallet](https://github.com/ton-community/mintless-jetton/blob/main/contracts/jetton-utils.fc#L142), который имеет встроенную оптимизацию шардов. В результате пользовательский jetton wallet оказывается на том же шарде, что и пользователь, с вероятностью 87%. Но это все еще довольно-таки неизведанная территория, так что вам придется действовать самостоятельно. Удачи с TGE!

<Feedback />
