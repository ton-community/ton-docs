import Feedback from '@site/src/components/Feedback';
import { BlockMath} from 'react-katex';
import 'katex/dist/katex.min.css';
import Button from '@site/src/components/button';

# Основы блокчейна

В этом разделе разобраны основные концепции, на которых основана работа транзакций в TON. Вы узнаете, как взаимодействуют аккаунты и смарт-контракты, как сообщения запускают асинхронные транзакции и как мультичейн-структура TON записывает эти транзакции.

## Модель выполнения

### Актор

**Актор** — это абстрактная поведенческая модель. Она формализована как вычислительный объект, который реагирует на входящие сообщения, изменяет свое внутреннее состояние, отправляет сообщения акторам и создаёт новых. Акторы изолированы: у них нет доступа к состояниям друг друга, они взаимодействуют только сообщениями.

Другими словами:

Актор — независимая сущность с состоянием и поведением. Акторы взаимодействуют, обмениваясь сообщениями. Каждый актор может:

- менять своё состояние
- отправлять сообщения другим акторам
- порождать новых акторов

![](/img/docs/blockchain-fundamentals/actor.svg)

### Модель акторов

**Модель акторов** — это модель параллельных вычислений, в которой система описывается как совокупность акторов, взаимодействующих с помощью передачи сообщений.

Ключевые свойства модели:

- изоляция акторов
- асинхронная связь
- любая вычислительная абстракция может быть реализована как актор

Модель используется для точного описания и анализа распределённых систем. Например,

- Электронная почта может быть смоделирована как система акторов: пользователи представлены как акторы, чьими адресами служат адреса электронной почты.
- Веб-сервисы с эндпоинтами (например, SOAP) можно воспринимать как акторов, обрабатывающих сообщения, отправленные на их адреса.

### Аккаунт

**Аккаунт** в TON — это актор, характеризующийся следующими компонентами:

- **Свойства аккаунта** — общие свойства любого аккаунта: *ID, баланс, статус и последняя транзакция (`last_tx`)*
- **Данные** — определяемые пользователем данные
- **Код** — логика, определяющая поведение конкретного аккаунта

В TON общее состояние полностью определяет все типы аккаунтов. Примеры:

- `(ID1, 0 TON, unexist)`
- `(ID2, 10 TON, uninit, last_tx)`
- `(ID3, -0.5 TON, frozen)`

![](/img/docs/blockchain-fundamentals/account_eng.svg)

### Смарт-контракт

**Смарт-контракт** — это аккаунт, чьи *код* и *данные* уже развёрнуты в блокчейне в дополнение к его общему состоянию.

![](/img/docs/blockchain-fundamentals/smart_contract_eng.svg)

#### Разница между аккаунтом и смарт-контрактом

- **Аккаунт** — это актор, который имеет общее состояние (такое, как баланс, адрес и статус), а также может дополнительно включать код и данные.

Пример: `(ID1, 0 TON, unexist)` или `(ID2, 2 TON, inited, last_tx, data, code)`

- - **Смарт-контракт** — это актор с **развёрнутыми** кодом и данными, которые определяют его поведение.

Пример: `(ID2, 2 TON, inited, data, code)`

#### Структура сущностей в блокчейне TON

![](/img/docs/blockchain-fundamentals/structure_eng.svg)

### Асинхронность

В TON контракты (акторы) не вызывают друг друга напрямую. Вместо этого они общаются, отправляя сообщения, каждое из которых обрабатывается независимо от других. Всё взаимодействие происходит посредством асинхронной передачи сообщений.

**Асинхронность** — это свойство коммуникации, означающее, что сообщение не требуется обрабатывать немедленно. Из этого следуют такие вещи:

1. *Немедленный ответ не гарантируется*. Получатель может отложить ответ или не ответить вовсе.
2. *Отправитель не ждёт ответа*. После отправки сообщения актор продолжает обрабатывать другие сообщения или задачи, не блокируясь и не ожидая ответа на предыдущее — даже если этот ответ никогда не придёт.
3. *Порядок сообщений сохраняется*. Все входящие сообщения обрабатываются в порядке их получения. Однако, если сообщение искажено или неполно, оно пропускается, и следующее сообщение обрабатывается без задержки.

Это отличается от синхронных моделей, где поток таков: вызов → ожидание ответа → продолжение.
В TON результат можно получить только в виде отдельного сообщения — и только если оно целенаправленно отправлено.

![](/img/docs/blockchain-fundamentals/asynchrony.gif)

### Сообщение

Сообщение — это набор инструкций, предназначенных для одного актора.

### Транзакция

Транзакция представляет собой обновление состояния аккаунта, вызванное входящим сообщением.
Она также может создавать одно или несколько исходящих сообщений, в зависимости от логики контракта.

В TON транзакция требуется для обновления состояния аккаунта в ответ на входящее сообщение и, при необходимости, для продолжения взаимодействия с другими аккаунтами с помощью отправки исходящих сообщений.

### Асинхронные транзакции

В TON аккаунты взаимодействуют исключительно через сообщения — это основа связи между акторами.
Каждое сообщение запускает транзакцию, которая записывает весь контекст: инициирующее сообщение, обновления состояния и любые сгенерированные исходящие сообщения.

Транзакции обрабатываются **асинхронно**, то есть обновления каждого отдельного аккаунта и обработка сообщений происходят независимо с течением времени.

## Структура данных

### Структура аккаунта

Ранее мы упоминали, что аккаунт — это актор, которого определяют такие компоненты:

- Свойства аккаунта (ID, баланс, статус, `last_tx`)
- Данные
- Код

На практике реальная структура данных сложнее, но различие между аккаунтом и смарт-контрактом остаётся тем же. Для описания структур данных в TON используются схемы TL-B. Они определяют, как данные располагаются на уровне битов.

Давайте посмотрим, как определяется аккаунт.
Его структура состоит из нескольких вложенных объектов:

```tlb
account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```

- Адрес — `MsgAddressInt`
- Баланс — `CurrencyCollection`
- Состояние — `AccountState`, оно определяет поведение аккаунта
- Логическое время последней примененной транзакции аккаунта — `last_trans_lt`
- Статистика хранения — `StorageInfo`

<details>
  ```tlb

  account_none$0 = Account;
  account$1 addr:MsgAddressInt storage_stat:StorageInfo
  storage:AccountStorage = Account;

  account_storage$_ last_trans_lt:uint64
  balance:CurrencyCollection state:AccountState
  = AccountStorage;

  account_uninit$00 = AccountState;
  account_active$1 _:StateInit = AccountState;
  account_frozen$01 state_hash:bits256 = AccountState;

  acc_state_uninit$00 = AccountStatus;
  acc_state_frozen$01 = AccountStatus;
  acc_state_active$10 = AccountStatus;
  acc_state_nonexist$11 = AccountStatus;


  _ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

  ```
</details>

Давайте проясним, какие из этих свойств являются **свойствами аккаунта**, согласно схеме TL-B:

- ID → `MsgAddressInt`
- Баланс → `CurrencyCollection`
- Статус → `AccountState`
- Логическое время последней транзакции (`last_trans_lt`) — также часть общего состояния

А данные и код определяются в поле состояния: `AccountState`.

Теперь давайте подробнее рассмотрим свойства аккаунта и то, как они представлены в структуре данных.

### Состояние аккаунта

TON определяет состояния аккаунта `AccountState` следующим образом:

| Статус   | Код TL-B | Описание                                                                                                                                                                                                                                    |
| -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `uninit` | `00`     | Аккаунт существует, но не содержит кода или данных. Он может иметь ненулевой баланс, но ещё не инициализирован.                                                                                                                             |
| `frozen` | `01`     | Аккаунт заморожен: его код и данные удалены, но хеш предыдущего состояния сохранен. Его нельзя использовать, но можно восстановить. У аккаунта нулевой или отрицательный баланс, или он не соответствует минимальным требованиям воркчейна. |
| `active` | `10`     | Аккаунт включает `StateInit`, что означает «состояние инициализировано», с развёрнутыми кодом и данными. Это означает, что он уже инициализирован. Это активный смарт-контракт, готовый к обработке входящих сообщений.                     |

```tlb
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;
```

Диаграмма ниже иллюстрирует жизненный цикл аккаунта в блокчейне TON, показывая, как его состояние меняется в различных условиях.

![](/img/docs/blockchain-fundamentals/account_states.svg)

### Структура смарт-контракта

Смарт-контракты — это набор обещаний в цифровой форме, включая протоколы, которые регулируют, как стороны выполняют эти обещания.

В TON под смарт-контрактом обычно понимают:

- Программный код, выполняемый в блокчейне и написанный на языке FunC, Tact или Tolk.
- Аккаунт, который реализует код для бизнес-логики и контента.

Техническое определение смарт-контракта в TON — это `аккаунт` в активном состоянии (`AccountState = active`), у которого:

- инициализировано поле `code` в `StateInit` — содержащее исполняемую логику
- инициализировано поле `data` в `StateInit` — хранящее постоянное состояние контракта

### Адрес

Адрес в TON — это уникальный идентификатор смарт-контракта, необходимый для взаимодействия между участниками сети.
У аккаунта самого по себе есть адрес, но мы определяем адрес только для произвольного использования через смарт-контракт.
Он состоит из следующих компонентов:

- **ID воркчейна** — 32-битное целое число со знаком, указывающее на WorkChain, к которому принадлежит аккаунт (например, -1 для мастерчейна, 0 для бейсчейна).
- **ID аккаунта** — 256-битный хеш структуры `StateInit`, которая включает инициализированные свойства контракта `code`, `data` и, опционально, `library`.

:::important
`StateInit` (сокращение от *state initialized*) может меняться за время существования контракта.
А `account_id` никогда не меняется, потому что это хеш самого первого `StateInit`, записанного при развёртывании.
:::

Адрес определяется как:

<BlockMath math="{Address} := ({workchain_id},{account_id})" />

, где

<BlockMath math="{account_id}:= {HASH(StateInit)}" />

Адрес соответствует первому инициализированному состоянию контракта и может быть вычислен даже **до** развёртывания контракта.
Это позволяет использовать адрес заранее — например, для получения токенов или настройки взаимодействий.

Адрес зависит только от `StateInit`, использованного *в момент первого развёртывания контракта*. Даже небольшое изменение в `code`, `data` или `library` в этом инициализированном состоянии приводит к совершенно другому `account_id` — и, следовательно, к другому **адресу**.

На самом деле, во время обработки сообщений валидаторы проверяют адрес отправителя — и если он оказывается неверным, они молча заменяют его на правильный.

## Структура блокчейна

### Блокчейн

**Блокчейн** — это распределённый реестр, состоящий из блоков, в каждом из которых содержится набор данных. Эти блоки криптографически связаны друг с другом через хеши, образуя неизменяемую цепь. Вся эта цепь реплицируется и последовательно поддерживается всеми участниками сети.

### AccountChain

**AccountChain** — это цепочка транзакций с одним аккаунтом в блокчейне TON.
Она образует линейную последовательность: `Tx1 → Tx2 → Tx3 → …`, где каждая транзакция ссылается на предыдущую.

Для эффективной обработки и консенсуса транзакции группируют в блоки, например, так:
`[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]`. Эти блоки также включают очереди входящих и исходящих сообщений, записывая все события и изменения состояния для аккаунта в течение этого периода блока.

Другими словами, AccountChain — это *микро-блокчейн*, ограниченный одним аккаунтом.
Как и обычный блокчейн, это линейная последовательность транзакций, позволяющая только дописывать данные — но посвящённая только одному аккаунту.
Она хранит и упорядочивает всю историю операций и взаимодействий этого аккаунта, обеспечивая прозрачность и отслеживаемость.

На сетевом уровне многие такие цепочки группируются в **ShardChain** или просто **шард**, в который входит целый набор аккаунтов. Эта абстракция поддерживает логическую группировку *AccountChains* по физической инфраструктуре *ShardChain ↔ Валидатор*.

Диаграмма ниже представляет графическое представление цепочки AccountChain и её структуры.
![](/img/docs/blockchain-fundamentals/accountchain.svg)

### ShardChain

**ShardChain** — это блокчейн, который группирует несколько AccountChain.

В то время как AccountChain представляет историю транзакций одного аккаунта, ShardChain обрабатывает и хранит данные для группы аккаунтов, у которых совпадает префикс двоичных адресов (например, все адреса, начинающиеся с `0b00101`).
ShardChains также облегчают маршрутизацию сообщений между аккаунтами, обеспечивая как доставку, так и порядок: если одно сообщение отправлено раньше другого, оно прибудет первым.

Каждый валидатор отвечает за определённый ShardChain или группу из них, что позволяет сети обрабатывать транзакции одновременно в разных шардах.

![](/img/docs/blockchain-fundamentals/shardchain.svg)

### WorkChain

**WorkChain** — это более высокий уровень блокчейна, который группирует различные ShardChain в *единую рабочую группу*.

В то время как каждый ShardChain управляет набором аккаунтов с общим префиксом двоичного адреса, WorkChain определяет общие правила (такие как ценообразование на газ и конфигурация шардинга), которым должен следовать каждый шард этого воркчейна. Другими словами, он служит областью определённых правил, управляющей своими шардами по одному и тому же протоколу.

TON поддерживает до 2³² воркчейнов, каждый из которых может быть разделён на до 2⁶⁰ шардчейнов.

В настоящее время в TON работают два воркчейна: **BaseChain** и **MasterChain**.

### MasterChain и BaseChain

**BaseChain** — это основная цепочка для исполнения повседневных транзакций и смарт-контрактов.
Она оптимизирована для низких комиссий, что делает её подходящей для обычных пользователей и разработчиков.

![](/img/docs/blockchain-fundamentals/basechain.svg)

**MasterChain** — это основной координирующий блокчейн, состоящий из одного шардчейна. Он содержит:

- параметры протокола
- текущий набор валидаторов и их доли
- цепочки аккаунтов валидаторов
- метаданные обо всех активных воркчейнах и шардчейнах
- хеши последних блоков из всех других цепочек

Затраты на газ в мастерчейне намеренно высоки для обеспечения стабильности, приоритезации критических операций и предотвращения спама.

Благодаря иерархической структуре воркчейнов и шардчейнов, TON образует **блокчейн из блокчейнов** — масштабируемую архитектуру, в которой каждая цепочка работает независимо, и все блоки ссылаются на своих предшественников через криптографические хеши.

![](/img/docs/blockchain-fundamentals/chain-of-chains.svg)

### Testnet и Mainnet

#### Mainnet (основная сеть)

**Мейннет** — это активная продакшн-сеть, где:

- все транзакции реальны
- используются реальные токены (например, настоящий Toncoin)

Все пользователи и проекты, работающие в продакшне, используют мейннет.

#### Testnet (тестовая сеть)

**Тестнет** — это независимая сеть блокчейнов, которая копирует функциональность основной сети, но использует монеты без ценности. В тестнете:

- используются тестовые монеты, не имеющие реальной ценности
- можно безопасно тестировать контракты, транзакции, DApps и ошибки
- блокчейн может быть сброшен или изменён в любое время

Тестнет необходим для безопасной разработки и отладки перед запуском в основную сеть.

## Следующий шаг

Вы изучили основы транзакций — теперь давайте посмотрим, **что заставляет их происходить.**

<Button href="/v3/guidelines/dapps/transactions/message-driven-execution" colorType={'primary'} sizeType={'sm'}>
  Узнайте, как сообщения приводят к транзакциям
</Button>

<Feedback />
