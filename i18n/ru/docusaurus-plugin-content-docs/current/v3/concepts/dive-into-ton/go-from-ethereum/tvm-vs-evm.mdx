import Feedback from '@site/src/components/Feedback';

# TVM и EVM

## Введение

**Ethereum Virtual Machine (EVM)** и **TON Virtual Machine (TVM)** — это две стековые виртуальные машины, разработанные для запуска кода смарт-контрактов. Несмотря на наличие общих черт, между ними есть и заметные различия.

## Различия TVM и EVM

### Представление данных

#### EVM

1. Основные единицы данных
   - EVM работает в основном с 256-битными целыми числами, так как она была спроектирована для удобной работы с криптографическими функциями Ethereum (например, хеширование Keccak-256 и операции с эллиптическими кривыми).
   - Типы данных в основном ограничены целыми числами, байтами и иногда массивами этих типов, но все они должны соответствовать 256-битным правилам обработки.
2. Хранилище состояний
   - Всё состояние блокчейна Ethereum представляет собой сочетание 256-битных адресов с 256-битными значениями. Это отображение поддерживается структурой данных, известной как **Merkle Patricia Trie (MPT)**.
   - MPT позволяет Ethereum эффективно доказывать согласованность и целостность состояния блокчейна с помощью криптографических проверок, что жизненно важно для децентрализованных систем вроде Ethereum.
3. Ограничения структуры данных
   - Упрощение до 256 бит означает, что EVM изначально не предназначена для обработки сложных или пользовательских структур данных напрямую.
     Разработчикам часто требуется внедрять дополнительную логику в смарт-контракты для имитации более сложных структур данных, что может привести к увеличению затрат на газ и увеличению сложности.

#### TVM

1. Архитектура на основе ячеек
   - TVM использует уникальную модель «[bag of cells»](/v3/documentation/data-formats/tlb/cell-boc/)» для представления данных. Каждая ячейка может содержать до 128 байтов данных и до 4 ссылок на другие ячейки.
   - Эта структура позволяет TVM изначально поддерживать произвольные алгебраические типы данных и более сложные конструкции, такие как деревья или направленные ациклические графы (DAG), непосредственно в своей модели хранения.
2. Гибкость и эффективность
   - Модель ячеек обеспечивает значительную гибкость, позволяя TVM обрабатывать широкий спектр структур данных более естественно и эффективно, чем EVM.
   - Например, возможность создания связанных структур с помощью ссылок на ячейки позволяет создавать динамические и потенциально бесконечные структуры данных, которые важны для определённых типов приложений, таких как децентрализованные социальные сети или сложные децентрализованные финансовые протоколы (DeFi).
3. Обработка сложных данных
   - Возможность управлять сложными типами данных, изначально заложенная в архитектуре виртуальной машины, снижает необходимость их имитации в смарт-контрактах, что потенциально снижает стоимость и увеличивает скорость выполнения.
     Конструкция TVM особенно выгодна для приложений, требующих сложного управления состоянием или взаимосвязанных структур данных. Она предоставляет разработчикам надёжную основу для создания сложных и масштабируемых децентрализованных приложений.

### Стековая машина

#### EVM

- EVM работает как традиционная стековая машина, используя принцип «последним пришёл — первым вышел» (LIFO) для управления вычислениями.
- Она обрабатывает операции, помещая и выталкивая 256-битные целые числа (стандартный размер для всех элементов в стеке).

#### TVM

- TVM также функционирует как стековая машина, но с ключевым отличием: она поддерживает как 257-битные целые числа, так и ссылки на ячейки.
- Это позволяет TVM помещать и выводить эти два различных типа данных в стек/из стека, обеспечивая повышенную гибкость в прямом управлении данными.

#### Пример операций со стеком

Предположим, мы хотим сложить в EVM два числа: `2` и `2`. Процесс будет включать помещение чисел в стек и последующий вызов инструкции `ADD`. Результат `4` останется наверху стека.

Мы можем выполнить эту операцию таким же образом и в TVM. Но давайте рассмотрим другой пример с более сложными структурами данных, такими как хеш-таблицы и ссылки на ячейки. Предположим, у нас есть хеш-таблицы с парами ключ-значение, где ключи являются целыми числами, а значения — либо целыми числами, либо ссылками на ячейки. Допустим, эта структура содержит следующие записи:

```js
{
    1: 10
    2: cell_a (which contains 10)
}
```

Мы хотим сложить значения, связанные с ключами `1` и `2`, и сохранить результат с ключом `3`. Давайте рассмотрим операции, происходящие в стеке:

1. Поместить ключ `1` в стек: `stack = (1)`
2. Вызвать `DICTGET` для ключа `1` (извлечь значение, связанное с ключом наверху стека): Извлекает значение 10. `stack = (10)`
3. Поместить ключ `2` в стек: `stack = (10, 2)`
4. Вызвать `DICTGET` для ключа `2`: Извлекает ссылку на Cell_A. `stack = (10, Cell_A)`
5. Загрузить значение из Cell_A: Выполняется инструкция по загрузке значения из ссылки на ячейку. `stack = (10, 10)`
6. Вызвать инструкцию `ADD`: При выполнении инструкции `ADD` TVM извлечёт два верхних элемента из стека, сложит их и поместит результат обратно в стек. В этом случае верхние два элемента — 10 и 10. После сложения стек будет содержать результат: `stack` = (20)
7. Поместить ключ 3 в стек: `stack = (20, 3)`
8. Вызвать `DICTSET`: Сохраняет 20 с ключом 3. Обновлённая хеш-таблица:

```js
{
    1: 10,
    2: cell_a,
    3: 20
}
```

Чтобы сделать то же самое в EVM, нам нужно задать mapping, хранящий пары ключ-значение, а также функцию, в которой мы будем работать напрямую с 256-битными целыми числами из маппинга.
Важно отметить, что EVM поддерживает сложные структуры данных с помощью языка Solidity, но эти структуры построены поверх более простой модели данных EVM, которая принципиально отличается от более выразительной модели данных TVM.

### Арифметические операции

#### EVM

- **Виртуальная машина Ethereum (EVM)** обрабатывает арифметику с использованием 256-битных целых чисел. Это означает, что операции — сложение, вычитание, умножение, деление — адаптированы под этот размер данных.

#### TVM

- **Виртуальная машина TON (TVM)** поддерживает более широкий спектр арифметических операций, включая 64-битные, 128-битные и 256-битные целые числа, как беззнаковые, так и знаковые, а также операции по модулю. TVM дополнительно расширяет свои арифметические возможности с помощью таких операций, как умножение-затем-сдвиг и сдвиг-затем-деление, которые особенно полезны для реализации арифметики с фиксированной точкой. Это разнообразие позволяет разработчикам выбирать наиболее эффективные арифметические операции на основе конкретных требований их смарт-контрактов, предлагая потенциальные оптимизации на основе размера и типа данных.

### Проверки переполнения

#### EVM

- В EVM проверки переполнения не выполняются самой виртуальной машиной. С введением Solidity 0.8.0 автоматические проверки переполнения и недополнения были интегрированы в язык для повышения безопасности. Эти проверки помогают предотвратить распространённые уязвимости, связанные с арифметическими операциями, но требуют более новых версий Solidity, поскольку более ранние версии требуют ручной реализации этих мер безопасности.

#### TVM

- Напротив, TVM автоматически выполняет проверки переполнения для всех арифметических операций, с помощью функций, встроенных непосредственно в виртуальную машину. Такая реализация упрощает разработку смарт-контрактов, изначально снижая риск ошибок и повышая общую надёжность и безопасность кода.

### Криптография и хеш-функции

#### EVM

- EVM поддерживает специфичные для Ethereum схемы криптографии, вроде эллиптической кривой secp256k1 и хеш-функции keccak256. Однако EVM не имеет встроенной поддержки доказательств Меркла — криптографических доказательств, используемыми для проверки принадлежности элемента к множеству.

#### TVM

- TVM поддерживает 256-битную криптографию на эллиптических кривых (ECC) для предопределённых кривых, подобных Curve25519. Он также поддерживает пары Вейля на некоторых эллиптических кривых, полезных для быстрой реализации zk-SNARK (доказательств с нулевым разглашением). Также поддерживаются популярные хеш-функции вроде sha256, давая больше возможностей для криптографических операций. Кроме того, TVM может работать с доказательствами Меркла, предоставляя дополнительные криптографические функции, полезные для определённых сценариев: к примеру, проверки включения транзакции в блок.

### Высокоуровневые языки

#### EVM

- EVM в качестве высокоуровневого языка в первую очередь использует Solidity: объектно-ориентированный статически типизированный язык, похожий на JavaScript и C++. Также существуют другие языки для написания смарт-контрактов Ethereum, такие, как Vyper и Yul.

#### TVM

- TVM использует FunC в качестве высокоуровневого языка, предназначенного для написания смарт-контрактов TON. Это процедурный язык со статическими типами и поддержкой алгебраических типов данных. FunC компилируется в Fift, который, в свою очередь, компилируется в байт-код TVM.

## Заключение

Подводя итог, можно сказать, что хотя и EVM, и TVM являются стековыми машинами для выполнения смарт-контрактов, TVM предлагает бо́льшую гибкость, поддержку более широкого спектра типов и структур данных, встроенные проверки переполнения, расширенные криптографические возможности.

Поддержка в TVM смарт-контрактов, созданных с учётом шардинга, и уникальный подход к представлению данных делают эту виртуальную машину более подходящей для определённых вариантов использования и масштабируемых блокчейн-сетей.

## См. также

- [Solidity vs FunC](/v3/concepts/dive-into-ton/go-from-ethereum/solidity-vs-func/)
- [Обзор TVM](/v3/documentation/tvm/tvm-overview/)

<Feedback />
