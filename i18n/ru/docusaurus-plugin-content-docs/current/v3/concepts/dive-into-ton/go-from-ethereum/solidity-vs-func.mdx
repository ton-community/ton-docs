import Feedback from '@site/src/components/Feedback';

# Solidity vs FunC

## Introduction

Smart contract development involves using predefined languages such as Solidity for Ethereum and FunC for TON.
Solidity is an object-oriented, high-level, strictly typed language influenced by C++, Python, and JavaScript. It is designed explicitly to write smart contracts on Ethereum blockchain platforms.

Разработка смарт-контрактов предполагает знание таких языков, как Solidity для Ethereum и FunC для TON. Solidity - это объектно-ориентированный, высокоуровневый, строго типизированный язык, основанный на C++, Python и JavaScript, и специально разработанный для написания смарт-контрактов, которые выполняются на блокчейн-платформе Ethereum.

В следующих разделах будет приведен краткий анализ и сравнение двух языков по типам данных, хранилищам, функциям, структурам управления потоком и словарям, хеш-картам.

## Сравнение Solidity и FunC

### Схема хранения

#### Solidity

Solidity обеспечивает плоскую модель хранения, которая означает, что все переменные состояния хранятся в едином непрерывном блоке памяти, называемом хранилищем. Хранилище состоит из набора данных типа ключ-значение, где каждый ключ есть 256-битное (32-байтовое) целое число, представляющее собой номер ячейки хранения, а каждое значение – это 256-битное слово, хранящееся в этой ячейке. Ячейки нумеруются последовательно, начиная с нуля, и в каждой ячейке может храниться только одно слово. Solidity позволяет разработчику сформировать структуру хранилища, используя ключевое слово storage для определения переменных состояния. Порядок, в котором задаются переменные, определяет их положение в хранилище.

#### FunC

Данные постоянного хранилища в блокчейне TON хранятся в виде ячеек. Ячейки играют роль памяти в стековой TVM. Ячейка может быть преобразована в фрагмент, Slice, а затем биты данных и ссылки на другие ячейки из ячейки могут быть получены путем их загрузки из этого фрагмента. Биты данных и ссылки на другие ячейки могут быть сохранены в компоновщике, Builder'e, а затем компоновщик может быть преобразован в новую ячейку.

### Типы данных

#### Solidity

Solidity включает следующие базовые типы данных:

- **Signed** and **Unsigned** integers
- **Boolean**
- Адреса — используются для хранения адресов кошельков Ethereum или смарт-контрактов, обычно около 20 байт. Тип адреса может быть дополнен ключевым словом `payable`, что ограничивает его использование хранением только адресов кошельков, а также только использованием функций передачи и отправки криптовалюты.
- Массивы байтов — объявляются ключевым словом "bytes", представляют собой массив фиксированного размера, используемый для хранения предопределенного количества байтов до 32, обычно задаются вместе с ключевым словом.
- Литералы – неизменяемые значения, такие как адреса, рациональные и целые числа, строки, юникод и шестнадцатеричные числа, которые могут храниться в переменной.
- **Enums**
- **Arrays** fixed or dynamic
- **Structs**
- **Mappings**

#### FunC

В случае FunC основными типами данных являются:

- **Integers**
- Cell — базовая для TON непрозрачная структура данных, которая содержит до 1023 бит и до 4 ссылок на другие ячейки
- Slice и Builder — специальные объекты для чтения и записи в ячейки
- Continuation — еще одна разновидность ячейки, которая содержит готовый к выполнению байт-код TVM
- Tuples — упорядоченная коллекция из до 255 компонентов, имеющих произвольные типы значений, возможно, различные.
- Tensors — это упорядоченная коллекция, готовая к массовому присвоению типа: (int, int) a = (2, 4). Частным случаем тензорного типа является тип unit (). Он означает, что функция не возвращает никакого значения или не имеет аргументов.

В настоящее время FunC не поддерживает определение пользовательских типов. Read more about types in the [Statements](/v3/documentation/smart-contracts/func/docs/statements/) page.

### Объявление и использование переменных

#### Solidity

Solidity - это язык со статической типизацией, что означает, что тип каждой переменной должен быть указан при ее объявлении.

```js
uint test = 1; // Declaring an unsigned variable of integer type
bool isActive = true; // Logical variable
string name = "Alice"; // String variable
```

#### FunC

FunC - более абстрактный и функционально-ориентированный язык, он поддерживает динамическую типизацию и функциональный стиль программирования. It supports dynamic typing and functional programming styles.

```func
(int x, int y) = (1, 2); // A tuple containing two integer variables
var z = x + y; // Dynamic variable declaration 
```

[Операторы](/v3/documentation/smart-contracts/func/docs/statements)

### Циклы

#### Solidity

Solidity поддерживает циклы `for`, `while` и `do { ... } while`.

Если вы хотите сделать что-то 10 раз, вы можете сделать это следующим образом:

```js
uint x = 1;

for (uint i; i < 10; i++) {
    x *= 2;
}

// x = 1024
```

#### FunC

FunC, в свою очередь, поддерживает циклы `repeat`, `while` и `do { ... } until`. Цикл for не поддерживается. Если вы хотите выполнить тот же код, что и в примере выше, но на Func, вы можете использовать `repeat`

```func
int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024
```

[Операторы](/v3/documentation/smart-contracts/func/docs/statements)

### Функции

#### Solidity

Подход Solidity к объявлениям функций является сочетанием ясности и контроля. В этом языке программирования каждая функция инициируется ключевым словом "function", за которым следует имя функции и ее параметры. Тело функции заключено в фигурные скобки, явно определяющие область действия. Кроме того, возвращаемые значения указываются с помощью ключевого слова "returns".Основное отличие Solidity заключается в определении области видимости функций. 

What sets Solidity apart is its categorization of function visibility—you can designate functions as `public`, `private`, `internal`, or `external`. Они могут быть обозначены как `public`, `private`, `internal` или `external`, тем самым описывая условия, при которых к ним может быть получен доступ и осуществлен вызов из других частей смарт-контракта или внешних сущностей. Ниже приведен пример, в котором мы задаем глобальную переменную `num` в языке Solidity: 

```js
function set(uint256 _num) public returns (bool) {
    num = _num;
    return true;
}
```

#### FunC

В свою очередь программа, написанная на FunC, по сути представляет собой список объявляемых функций и глобальных переменных. Объявление функции в FunC обычно начинается с необязательного декларатора, за которым следует возвращаемый тип и имя функции. 

Parameters are listed next, and the declaration ends with a selection of specifiers—such as `impure`, `inline/inline_ref`, and `method_id`. These specifiers adjust the function's visibility, ability to modify contract storage, and inlining behavior. Below is an example in which we store a storage variable as a cell in persistent storage in the Func language: 

```func
() save_data(int num) impure inline {
  set_data(begin_cell()
            .store_uint(num, 32)
           .end_cell()
          );
}
```

[Функции](/v3/documentation/smart-contracts/func/docs/functions)

### Flow control structures

#### Solidity

Большинство операторов из известных языков с фигурными скобками доступны и в Solidity, включая: `if`, `else`, `while`, `do`, `for`, `break`, `continue`, `return`, с обычной семантикой, известной из C или JavaScript.

#### FunC

FunC поддерживает классические операторы `if-else`, а также циклы `ifnot`, `repeat`, `while` и `do/until`.  Также с версии v0.4.0 поддерживаются операторы `try-catch`.

[Операторы](/v3/documentation/smart-contracts/func/docs/statements)

### Словари

Словари, hashmap/mapping, крайне важны для разработки контрактов Solidity и FunC, так как позволяют разработчикам эффективно хранить и извлекать данные в смарт-контрактах. В частности данные, связанные с определенным ключом, к примеру, баланс счета пользователя или факт владения активом.

#### Solidity

Mapping — это хэш-таблица в Solidity, которая хранит данные в виде пар ключ-значение, где ключ может принимать значение любого из встроенных типов данных, кроме ссылочного. Mapping чаще всего используются в Solidity и блокчейне Ethereum для соединения уникального адреса Ethereum с соответствующим типом значения. В любом другом языке программирования Mapping является эквивалентом словарю.

В Solidity структура Mapping не имеет размера и не имеет функционала задания ключа или значения. Mapping применим только к переменным состояния, которые служат типами ссылок на хранилище. Когда происходит инициализация Mapping структуры, он включает в себя все возможные ключи, которые соединены с значениями, байтовые представления которых состоят из одних нулей.

#### FunC

Аналогом Mapping в FunC являются словари или TON hashmap. В контексте TON, hashmap представляет собой структуру данных, представленную деревом ячеек. Hashmap маппит ключи в значения произвольного типа, чтобы обеспечить возможность их быстрого поиска и изменения. Абстрактное представление hashmap в TVM — это дерево Patricia или компактное двоичное дерево.Работа с потенциально большими деревьями ячеек может содержать несколько сложностей. 

Working with potentially large cell trees can create several problems. Каждая операция обновления создает значительное количество ячеек, а каждая построенная ячейка стоит 500 единиц газа, что в свою очередь означает, что эти операции могут исчерпать имеющиеся ресурсы, если их использовать неосторожно.Чтобы избежать превышения лимита газа, ограничьте количество обновлений словаря за одну транзакцию. To avoid exceeding the gas limit, limit the number of dictionary updates in a single transaction. 

Кроме того, двоичное дерево для `N` пар ключ-значение содержит `N-1` форков, что означает в общей сложности не менее `2N-1` ячеек. Хранилище смарт-контракта ограничено `65536` уникальными ячейками, поэтому максимальное количество записей в словаре составляет `32768` или чуть больше, если есть повторяющиеся ячейки.

[Словари в TON](/v3/documentation/smart-contracts/func/docs/dictionaries)

### Взаимодействие смарт-контрактов

Solidity и FunC предоставляют разные подходы к взаимодействию со смарт-контрактами. Основное различие заключается в механизмах вызова и взаимодействия между контрактами.

#### Solidity

Solidity использует объектно-ориентированный подход, при котором контракты взаимодействуют друг с другом посредством вызовов методов. Это похоже на вызовы методов в традиционных объектно-ориентированных языках программирования.

```js
// External contract interface
interface IReceiver {
    function receiveData(uint x) external;
}

contract Sender {
    function sendData(address receiverAddress, uint x) public {
        IReceiver receiver = IReceiver(receiverAddress);
        receiver.receiveData(x);  // Direct call of the contract function
    }
}
```

#### FunC

FunC, используемый в экосистеме блокчейна TON, работает с сообщениями для вызова и взаимодействия между смарт-контрактами. Вместо прямого вызова методов контракты отправляют друг другу сообщения, которые могут содержать данные и код для выполнения. 

Рассмотрим пример, в котором отправитель смарт-контракта должен отправить сообщение с номером, а получатель смарт-контракта должен получить этот номер и выполнить над ним некоторые манипуляции. 

Изначально получатель смарт-контракта должен описать, как он будет получать сообщения.

```func
() recv_internal(int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
    int op = in_msg_body~load_uint(32);
    
    if (op == 1) {
        int num = in_msg_body~load_uint(32);
        ;; do some manipulations
        return ();
    }

    if (op == 2) {
        ;;...
    }
}
```

**Receiving message flow:**

1. `recv_internal()` - эта функция выполняется, когда к контракту обращаются напрямую в блокчейне. Например, когда контракт обращается к нашему контракту.
2. Функция принимает сумму баланса контракта, сумму входящего сообщения, ячейку с исходным сообщением и срез `in_msg_body`, в котором хранится только тело полученного сообщения. 
3. Наше тело сообщения будет хранить два целых числа. Первое число — это 32-битное беззнаковое целое число `op`, определяющее операцию, которую нужно выполнить, или `method` смарт-контракта, который нужно вызвать. Можно провести аналогию с Solidity и представить себе `op` как сигнатуру функции. 
4. Чтобы прочитать из полученного Slice `op` и `наше число`, мы используем `load_uint()`.
5. Next, we execute business logic for a given operation. Note that we omitted this functionality in this example.

Далее смарт-контракт отправителя должен корректно отправить сообщение. Для этого используется `send_raw_message`, который ожидает сериализованное сообщение в качестве аргумента.

```func
int num = 10;
cell msg_body_cell = begin_cell().store_uint(1,32).store_uint(num,32).end_cell();

var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; in the example, we hardcode the recipient's address
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body_cell)
        .end_cell();

send_raw_message(msg, mode);
```

**Sending message flow:**

1. Сначала нам нужно построить наше сообщение. Полную структуру отправки можно найти [здесь](/v3/documentation/smart-contracts/message-management/sending-messages). 
2. Тело сообщения представляет собой ячейку. В `msg_body_cell` мы делаем: `begin_cell()` - создает `Builder` для будущей ячейки, сначала `store_uint` - сохраняет первый `uint` в `Builder` (1 - это наш `op`), затем `store_uint` - сохраняет второй `uint` в `Builder` (num - это наш номер, которым мы будем манипулировать в контракте-получателе), `end_cell()` - создает ячейку.
3. Чтобы прикрепить тело, которое придет в `recv_internal` в сообщении, мы ссылаемся на собранную ячейку в самом сообщении с помощью `store_ref`.
4. Отправка сообщения.

В этом примере показано, как смарт-контракты могут общаться друг с другом. 

[Внутренние сообщения](/v3/documentation/smart-contracts/message-management/internal-messages)

## См. также

- [TON documentation](/v3/documentation/ton-documentation/)
- [Операторы](/v3/documentation/smart-contracts/func/docs/statements)

<Feedback />
