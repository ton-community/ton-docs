import Feedback from '@site/src/components/Feedback';

# Блокчейн блокчейнов

:::tip
Термины **смарт-контракт**, **аккаунт** и **актор** в этом документе используются взаимозаменяемо, описывая одну и ту же сущность в блокчейне.
:::

## Отдельный актор

Рассмотрим отдельный смарт-контракт.

В TON это *сущность* со свойствами вроде `address`, `code`, `data`, `balance` и другими. Другими словами, это объект, который имеет *хранилище* и определённое *поведение*.
Это поведение следует такой схеме:

- контракт получает сообщение
- контракт обрабатывает это событие в соответствии со своими свойствами, исполняя свой `код` в виртуальной машине TON
- контракт изменяет свои свойства (в их число могут входить `data`, `code` и другие)
- контракт при необходимости генерирует исходящие сообщения
- контракт переходит в режим ожидания, пока не произойдёт следующее событие

Комбинация этих шагов называется **транзакцией**. Важно, чтобы события обрабатывались одно за другим, поэтому *транзакции* в блокчейне строго упорядочены и не могут прерывать друг друга.

Этот поведенческий паттерн хорошо известен, его называют **актором**.

### Самый низкий уровень: AccountChain

Последовательность *транзакций* `Tx1 → Tx2 → Tx3 → …` можно назвать **цепочкой** (chain). Когда эта последовательность относится к одному аккаунту, мы можем использовать термин `AccountChain`.

Ноды, которые обрабатывают эти транзакции, периодически должны синхронизировать состояние, чтобы достигнуть консенсуса, транзакции объединяют в группы под названием **блоки**. Например, такие:

```
[Tx1 → Tx2] → [Tx3 → Tx4 → Tx5] → [] → [Tx6]
```

Это группирование никак не видоизменяет саму последовательность. Каждая транзакция в ней по-прежнему ссылается ровно на одну предшествующую, и у неё может быть не более одной следующей. Группирование просто делит эту последовательность на блоки, удобные для задачи достижения консенсуса.

Также каждый блок может содержать очереди входящих и исходящих сообщений. Так в блоке окажется полный набор событий и изменений состояния, произошедших со смарт-контрактом во время исполнения этого блока.

## Множество AccountChains: шарды

Теперь давайте рассмотрим множество аккаунтов. Мы можем получить несколько цепочек *AccountChain* и хранить их вместе. Подобный набор *AccountChains* называется **ShardChain**. По аналогии с уже описанным выше, мы можем разбить такой **шардчейн** на **«шардблоки»**, которые будут являться совокупностью отдельных *AccountBlock*.

### Динамическое разделение и объединение шардчейнов

Важно отметить: поскольку *ShardChain* состоит из явно различимых *AccountChain*, мы можем его легко разделять. Представим, что у нас есть шардчейн, который описывает события, происходящие с миллионом аккаунтов. И с ними начинает происходить слишком много транзакций в секунду для обработки и хранения в одном узле. Тогда мы можем просто разделить эту цепочку на два меньших *шардчейна*, каждый будет работать с полумиллионом аккаунтов и обрабатываться на отдельном подмножестве узлов.

Аналогично, если некоторые шарды станут слишком свободными, их можно **объединить** в один более крупный шард.

Очевидно, что есть два предельных случая: когда шард содержит только один аккаунт (и, следовательно, не может быть разделён дальше) и когда шард содержит все аккаунты.

Аккаунты могут взаимодействовать друг с другом, отправляя сообщения.  Существует специальный механизм маршрутизации, который перемещает сообщения из исходящих очередей в соответствующие входящие очереди и гарантирует:

1. Что все сообщения будут доставлены
2. Что они будут доставлены последовательно (сообщение, отправленное раньше, достигнет получателя раньше)

:::info ПРИМЕЧАНИЕ
Чтобы разделение и слияние происходили детерминированным образом, объединение AccountChains по шардам основано на битовом представлении адресов аккаунтов. В один шард попадают аккаунты, чьи адреса начинаются одинаково (например, все адреса, которые начинаются с `0b00101`). Таким образом, все аккаунты в шарде будут иметь точно такой же двоичный префикс (например, все адреса будут начинаться с `0b00101`).
:::

## Блокчейн

Объединение всех шардов, содержащее все аккаунты, работающие по одному набору правил, называется **блокчейном**.

В TON может действовать много разных наборов правил и, следовательно, могут работать одновременно много блокчейнов. Они могут взаимодействовать друг с другом, отправляя сообщения таким же образом, как аккаунты одного блокчейна могут взаимодействовать друг с другом.

### WorkChain: блокчейн с вашими собственными правилами

Если вы хотите настроить свои правила группы шардчейнов, вы можете создать **Воркчейн**. Хороший пример: создать воркчейн, который работает на базе EVM, чтобы запускать в TON смарт-контракты, написанные на языке Solidity.

Теоретически любой в сообществе может создать собственный воркчейн. На деле же это крайне трудоёмкая задача. Более того, для его создания необходимо заплатить ощутимую цену, а также получить 2/3 голосов от валидаторов, которые необходимы для одобрения создания вашего воркчейна.

TON позволяет создавать до `2^32` воркчейнов, каждый из которых может подразделяться на шарды числом до `2^60`.

В настоящее время в TON есть только два воркчейна: мастерчейн (masterchain) и бейсчейн (basechain).

В бейсчейне транзакции дешевле, поэтому он используется для повседневных транзакций между участниками, а мастерчейн выполняет важную для TON функцию.

### MasterChain: блокчейн блокчейнов

Необходимо синхронизировать маршрутизацию сообщений и выполнение транзакций. Другими словами, узлам сети нужен способ зафиксировать некоторую «точку» в состоянии всех «чейнов», и достичь консенсуса относительно этого состояния. В TON для этой цели используется так называемый **«Мастерчейн»**. Его блоки содержат дополнительную информацию, вроде хэшей свежих блоков, обо всех других цепочках в этой системе. Таким образом, любой наблюдатель однозначно может определить состояние всех систем мультичейна по одному блоку мастерчейна.

## См. также

- [Адреса смарт-контрактов](/v3/concepts/dive-into-ton/ton-blockchain/smart-contract-addresses)

<Feedback />
