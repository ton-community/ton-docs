# Блокчейн из блокчейнов

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::tip
Термины "**умный контракт**", "**аккаунт**" и "**актор**" используются в этом документе как взаимозаменяемые для описания сущности блокчейна.
:::

## Одиночный актер

Давайте рассмотрим один смарт-контракт.

В TON это *вещь* с такими свойствами, как `адрес`, `код`, `данные`, `баланс` и другими. Другими словами, это объект, который обладает некоторым *хранилищем* и *поведением*.
Это поведение имеет следующий вид:

- Что-то происходит (наиболее распространенная ситуация - контракт получает сообщение)
- Контракт обрабатывает это событие в соответствии со своими свойствами, выполняя свой `код` в виртуальной машине TON.
- контракт изменяет свои собственные свойства (`код`, `данные` и другие)
- контракт опционально генерирует исходящие сообщения
- контракт переходит в режим ожидания до наступления следующего события

Комбинация этих шагов называется **транзакцией**. Важно, чтобы события обрабатывались поочередно, поэтому *транзакции* строго упорядочены и не могут прерывать друг друга.

Эта модель поведения хорошо известна и называется "Актер".

### Самый низкий уровень: Цепочка счетов

Последовательность *транзакций* `Tx1 -> Tx2 -> Tx3 -> ....` можно назвать **цепочкой**. А в рассматриваемом случае она называется **AccountChain**, чтобы подчеркнуть, что это *цепочка* одного счета транзакций.

Теперь, поскольку узлам, обрабатывающим транзакции, необходимо время от времени согласовывать состояние смарт-контракта (чтобы достичь *консенсуса* по поводу состояния), эти *транзакции* разбиваются на блоки:
`[Tx1 -> Tx2] -> [Tx3 -> Tx4 -> Tx5] -> [] -> [Tx6]`.
Пакетирование не вмешивается в последовательность, каждая транзакция по-прежнему имеет только один "предыдущий tx" и максимум один "следующий tx", но теперь эта последовательность разбита на **блоки**.

Также целесообразно включить в *блоки* очереди входящих и исходящих сообщений. В этом случае *блок* будет содержать полный набор информации, определяющей и описывающей, что произошло со смарт-контрактом во время этого блока.

## Множество AccountChains: Осколки

Теперь рассмотрим множество аккаунтов. Мы можем получить несколько *AccountChains* и хранить их вместе, такой набор *AccountChains* называется **ShardChain**. Таким же образом мы можем разрезать **ShardChain** на **ShardBlocks**, которые представляют собой совокупность отдельных *AccountBlocks*.

### Динамическое разделение и объединение цепочек шардов

Обратите внимание, что поскольку *ShardChain* состоит из легко различимых *AccountChain*, мы можем легко разделить его. Таким образом, если у нас есть 1 *ShardChain*, которая описывает события, происходящие с 1 миллионом аккаунтов, и в ней слишком много транзакций в секунду для обработки и хранения на одном узле, мы просто разделим (или **разделим**) эту цепочку на две меньшие *ShardChain*, каждая из которых будет учитывать полмиллиона аккаунтов, и каждая цепочка будет обрабатываться на отдельном подмножестве узлов.

Аналогичным образом, если некоторые осколки стали слишком незанятыми, они могут быть **слиты** в один больший осколок.

Очевидно, что существует два предельных случая: когда осколок содержит только одну учетную запись (и поэтому не может быть разделен дальше) и когда осколок содержит все учетные записи.

Учетные записи могут взаимодействовать друг с другом, посылая сообщения. Существует специальный механизм маршрутизации, который перемещает сообщения из исходящих очередей в соответствующие входящие очереди и гарантирует, что 1) все сообщения будут доставлены 2) сообщения будут доставлены последовательно (сообщение, отправленное раньше, достигнет места назначения раньше).

:::info БОКОВОЕ ПРИМЕЧАНИЕ
Чтобы сделать разделение и объединение детерминированным, объединение цепочек счетов в шарды основано на битовом представлении адресов счетов. Например, адрес выглядит как `(префикс шарда, адрес)`. Таким образом, все аккаунты в шард-цепочке будут иметь абсолютно одинаковый двоичный префикс (например, все адреса будут начинаться с `0b00101`).
:::

## Блокчейн

Совокупность всех шардов, содержащая все аккаунты, ведущие себя в соответствии с одним набором правил, называется **Блокчейн**.

В TON может быть множество наборов правил и, соответственно, множество блокчейнов, которые работают одновременно и могут взаимодействовать друг с другом, отправляя сообщения кросс-чейн таким же образом, как счета одной цепи могут взаимодействовать друг с другом.

### Workchain: Блокчейн с вашими собственными правилами

Если Вы хотите настроить правила группы шардчейнов, Вы можете создать **Workchain**. Хороший пример - создать воркчейн, работающий на базе EVM, чтобы запускать на нем смарт-контракты Solidity.

Теоретически, каждый член сообщества может создать свой собственный воркчейн. На самом деле, это довольно сложная задача - создать его, затем заплатить (дорогую) цену за его создание и получить 2/3 голосов от валидаторов, чтобы одобрить создание Вашего Workchain.

TON позволяет создавать до `2^32` рабочих цепочек, каждая из которых подразделяется на до `2^60` шардов.

В настоящее время в TON существует только 2 рабочих цепочки: MasterChain и BaseChain.

BaseChain используется для повседневных транзакций между участниками, потому что он довольно дешевый, а MasterChain выполняет важнейшую функцию для TON, так что давайте рассмотрим, что он делает!

### Мастерчейн: Блокчейн из блокчейнов

Существует необходимость в синхронизации маршрутизации сообщений и выполнения транзакций. Другими словами, узлам сети нужен способ зафиксировать некоторую "точку" в состоянии мультицепочки и прийти к консенсусу относительно этого состояния. В TON для этой цели используется специальная цепочка, называемая **MasterChain**. Блоки *masterchain* содержат дополнительную информацию (последние хэши блоков) обо всех остальных цепочках в системе, поэтому любой наблюдатель однозначно определяет состояние всех мультичейн-систем по одному блоку masterchain.
