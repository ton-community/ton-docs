import Feedback from '@site/src/components/Feedback';

# Tolk vs FunC: 상세 비교

A huge list is below. Will anyone have enough patience to read it up to the end?..

:::tip There is a compact version
여기에서 보실 수 있습니다: [Tolk vs FunC: 요약](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)
:::

<h3 className="cmp-func-tolk-header">
  ✅ 전통적인 주석 :)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{';; comment'}</code></td>
    <td><code>{'// comment'}</code></td>
  </tr>
  <tr>
    <td><code>{'{- multiline comment -}'}</code></td>
    <td><code>{'/* multiline comment */'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `2+2`는 식별자가 아닌 4입니다. 식별자는 알파벳과 숫자만 가능합니다
</h3>

In FunC, almost any character can be a part of the identifier.
For example, `2+2` (without a space) is an identifier.
You can even declare a variable with such a name.

Tolk에서는 공백이 필수가 아닙니다. `2+2`는 예상대로 4입니다. `3+~x`는 `3 + (~ x)`이고, 이런 식입니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'return 2+2;  ;; undefined function `2+2`'}</code></td>
    <td><code>{'return 2+2;  // 4'}</code></td>
  </tr>
  </tbody>
</table>

More precisely, an identifier can start from <code style={{display: 'inline-block'}}>{'[a-zA-Z$_]'}</code>
and be continued with <code style={{display: 'inline-block'}}>{'[a-zA-Z0-9$_]'}</code>. Note that `?`, `:`, and others are not valid symbols, and `found?` and `op::increase` are invalid identifiers.

Note, that `cell`, `slice`, etc. are valid identifiers: `var cell = ...` or even `var cell: cell = ...` is okay. (like in TypeScript, `number` is a valid identifier)

You can use backticks to surround an identifier, and then it can contain any symbols (similar to Kotlin and some other languages). This potential usage is to allow keywords to be used as identifiers in case of code generation by a scheme, for example.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'const op::increase = 0x1234;'}</code></td>
    <td><code>{'const OP_INCREASE = 0x1234;'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: ';; even 2%&!2 is valid<br>int 2+2 = 5;'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '// don\'t do like this :)<br>var \`2+2\` = 5;'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ 기본적으로 impure, 컴파일러는 사용자 함수 호출을 삭제하지 않습니다
</h3>

FunC has an `impure` function specifier. When absent, a function is treated as pure. If its result is unused, its call is deleted by the compiler.

Though this behavior is documented, it is very unexpected to newcomers.
For instance, various functions that don't return anything (throw an exception on mismatch, for example)
are silently deleted. This situation is spoilt by FunC not checking and validating the function body,
allowing impure operations inside pure functions.

Tolk에서는 모든 함수가 기본적으로 impure입니다. 어노테이션으로 함수를 pure로 표시할 수 있으며,
그런 경우 그 본문에서 impure 연산(예외, 전역 수정, non-pure 함수 호출 등)이 금지됩니다.

<h3 className="cmp-func-tolk-header">
  ✅ Structures <code>{'struct A { ...
}'}</code>
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'cell parse_data(slice cs) { }'}</code></td>
    <td><code>{'fun parse_data(cs: slice): cell { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell, int) load_storage() { }'}</code></td>
    <td><code>{'fun load_storage(): (cell, int) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'() main() { ... }'}</code></td>
    <td><code>{'fun main() { ... }'}</code></td>
  </tr>
  </tbody>
</table>

변수의 타입도 오른쪽에:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'slice cs = ...;'}</code></td>
    <td><code>{'var cs: slice = ...;'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell c, int n) = parse_data(cs);'}</code></td>
    <td><code>{'var (c: cell, n: int) = parse_data(cs);'}</code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`inline`과 다른 수정자들은 어노테이션으로:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>int f(cell s) inline {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline<br>fun f(s: cell): int {'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() load_data() impure inline_ref {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline_ref<br>fun load_data() {'}}></code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`forall`은 이렇게:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'forall X -> tuple cons(X head, tuple tail)'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'fun cons&amp;amp;lt;X&amp;amp;gt;(head: X, tail: tuple): tuple'}}></code></td>
  </tr>
  </tbody>
</table>

`asm` 구현은 FunC와 비슷하지만, 적절히 정렬되어 더 보기 좋습니다:

```tolk
@pure
fun third<X>(t: tuple): X
    asm "THIRD";

@pure
fun iDictDeleteGet(dict: cell, keyLen: int, index: int): (cell, slice, int)
    asm(index dict keyLen) "DICTIDELGET NULLSWAPIFNOT";

@pure
fun mulDivFloor(x: int, y: int, z: int): int
    builtin;
```

컴파일에는 영향을 미치지 않지만 사람과 IDE를 위한 `@deprecated` 속성도 있습니다.

<h3 className="cmp-func-tolk-header">
  ✅ `method_id` 대신 `get`
</h3>

In FunC, `method_id` (without arguments) declared a get method. In Tolk, you use a straightforward syntax:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int seqno() method_id { ... }'}</code></td>
    <td><code>{'get seqno(): int { ... }'}</code></td>
  </tr>
  </tbody>
</table>

`get methodName()`과 `get fun methodName()` 모두 허용됩니다.

`method_id(xxx)`의 경우(실제로는 드물지만 유효함), 속성이 있습니다:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() after_code_upgrade(cont old_code) impure method_id(1666)'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@method_id(1666)<br>fun afterCodeUpgrade(oldCode: continuation)'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ 매개변수의 타입 선언이 필수입니다(로컬 변수는 선택사항)
</h3>

```tolk
// not allowed
fun do_smth(c, n)
// types are mandatory
fun do_smth(c: cell, n: int)
```

If parameter types are mandatory, the return type is not (it's often obvious or verbose). If omitted, it's auto-inferred:

```tolk
fun x() { ... }  // auto infer from return statements
```

로컬 변수의 경우에도 타입은 선택사항입니다:

```tolk
var i = 10;                      // ok, int
var b = beginCell();             // ok, builder
var (i, b) = (10, beginCell());  // ok, two variables, int and builder

// types can be specified manually, of course:
var b: builder = beginCell();
var (i: int, b: builder) = (10, beginCell());
```

Defaults for parameters are supported:

```tolk
fun increment(x: int, by: int = 1) {
    return x + by
}
```

<h3 className="cmp-func-tolk-header">
  ✅ 같은 스코프에서 변수를 재선언할 수 없습니다
</h3>

```tolk
var a = 10;
...
var a = 20;  // error, correct is just `a = 20`
if (1) {
    var a = 30;  // it's okay, it's another scope
}
```

결과적으로 부분 재할당은 허용되지 않습니다:

```tolk
var a = 10;
...
var (a, b) = (20, 30);  // error, releclaration of a
```

이는 `loadUint()`와 같은 메서드에는 문제가 되지 않습니다. FunC에서는 수정된 객체를 반환했기 때문에 `var (cs, int value) = cs.load_int(32)` 패턴이 매우 일반적이었습니다. Tolk에서는 이러한 메서드가 객체를 변형시킵니다: `var value = cs.loadInt(32)`, 따라서 재선언이 필요할 가능성이 낮습니다.

```tolk
fun send(msg: cell) {
    var msg = ...;  // error, redeclaration of msg

    // solution 1: intruduce a new variable
    var msgWrapped = ...;
    // solution 2: use `redef`, though not recommended
    var msg redef = ...;
```

<h3 className="cmp-func-tolk-header">
  ✅ String postfixes removed, compile-time functions introduced
</h3>

Tolk removes the old FunC-style string postfixes (`"..."c`, etc.) in favor of a **more transparent and more flexible approach**.

<table className="cmp-func-tolk-table">
    <thead>
    <tr>
        <th>FunC</th>
        <th>Tolk</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><code>{'"..."c'}</code></td>
        <td><code>{'stringCrc32("...")'}</code></td>
    </tr>
    <tr>
        <td>—</td>
        <td><code>{'stringCrc16("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."H'}</code></td>
        <td><code>{'stringSha256("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."h'}</code></td>
        <td><code>{'stringSha256_32("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."a'}</code></td>
        <td><code>{'stringAddressToSlice("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."s'}</code></td>
        <td><code>{'stringHexToSlice("...")'}</code></td>
    </tr>
    <tr>
        <td><code>{'"..."u'}</code></td>
        <td><code>{'stringToBase256("...")'}</code></td>
    </tr>
    </tbody>
</table>

These functions:

- compile-time only
- for constant strings only
- can be used in constant initialization

```tolk
// type will be `slice`
const BASIC_ADDR = stringAddressToSlice("EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF");

// return type will be `int`
fun minihashDemo() {
    return stringSha256_32("transfer(slice, int)");
}
```

The naming highlights that these functions have arrived from string postfixes and operate on string values.
Remember that at runtime, there are no strings, only slices.

<h3 className="cmp-func-tolk-header">
  ✅ Trailing comma support
</h3>

Tolk now supports trailing commas in the following contexts:

- tensors
- tuples
- function calls
- function parameters

```tolk
var items = (
    totalSupply,
    verifiedCode,
    validatorsList,
);
```

Note that `(5)` is not a tensor. It's just the integer `5` in parentheses.
With a trailing comma `(5,)` it's still `(5)`.

<h3 className="cmp-func-tolk-header">
  ✅ Optional semicolon for the last statement in a block
</h3>

In Tolk, you can omit the semicolon after the final statement in a block.
While semicolons are still required between statements, the trailing semicolon on the last statement is now optional.

```tolk
fun f(...) {
	doSomething();
	return result   // <-- valid without semicolon
}

// or
if (smth) {
	return 1
} else {
	return 2
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Function `ton("...")` for human-readable amounts of Toncoins
</h3>

<table className="cmp-func-tolk-table">
    <thead>
    <tr>
        <th>FunC</th>
        <th>Tolk</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><code>{'int cost = 50000000;'}</code></td>
        <td><code>{'val cost = ton("0.05");'}</code></td>
    </tr>
    <tr>
        <td><code>{'const ONE_TON = 1000000000;'}</code></td>
        <td><code>{'const ONE_TON = ton("1");'}</code></td>
    </tr>
    </tbody>
</table>

The function `ton()` only accepts constant values (e.g., `ton(some_var)` is invalid).
Its type is `coins` (not `int`!), although it's still a regular `int` from the TVM point of view.
Arithmetic over `coins` degrade to `int` (for example, `cost << 1` is valid, `cost + ton("0.02")` also).

<h3 className="cmp-func-tolk-header">
  ✅ 타입 시스템의 변경사항
</h3>

FunC의 타입 시스템은 Hindley-Milner를 기반으로 합니다. 이는 단일화를 통해 사용에서 타입을 추론하는 함수형 언어에서 일반적인 접근 방식입니다.

Tolk v0.7에서는 타입 시스템이 처음부터 다시 작성되었습니다.
불리언, 고정 너비 정수, null 가능성, 구조체, 제네릭을 추가하기 위해서는 정적 타입 시스템이 필요합니다(TypeScript나 Rust처럼).
Hindley-Milner는 구조체 메서드와 충돌하고, 적절한 제네릭을 다루는 데 어려움을 겪으며, 유니온 타입에는 완전히 비실용적이기 때문입니다("유니온 타입을 위해 설계되었다"는 주장에도 불구하고).

다음과 같은 타입들이 있습니다:

- `int`, `bool`, `cell`, `slice`, `builder`, 타입이 지정되지 않은 `tuple`
- 타입이 지정된 튜플 `[T1, T2, ...]`
- 텐서 `(T1, T2, ...)`
- callables `(TArgs) -> TResult`
- nullable types `T?`, compile-time null safety
- union types `T1 | T2 | ...`, handled with pattern matching
- `coins` and function `ton("0.05")`
- `int32`, `uint64`, and other fixed-width integers (just int at TVM) [details](https://github.com/ton-blockchain/ton/pull/1559)
- `bytesN` and `bitsN`, similar to `intN` (backed by slices at TVM)
- `address` (internal/external/none, still a slice at TVM)
- `void` (`unit`으로 명명하는 것이 더 정통적이지만 `void`가 더 안정적)
- `self`, 아래에서 설명할 연결 가능한 메서드를 만들기 위함; 실제로는 타입이 아니며 함수의 반환 타입 대신에만 발생할 수 있음
- `never` (an always-throwing function returns `never`, for example; an "impossible type" is also `never`)
- structures and generics

타입 시스템은 다음 규칙을 따릅니다:

- 변수 타입은 수동으로 지정하거나 선언에서 추론될 수 있으며, 선언된 후에는 절대 변경되지 않음
- 함수 매개변수는 반드시 명확한 타입을 가져야 함
- 함수 반환 타입은 지정되지 않은 경우 TypeScript와 유사하게 return 문에서 추론됨; 재귀(직접 또는 간접)의 경우 어딘가에서 반환 타입을 명시적으로 선언해야 함
- 제네릭 함수 지원됨

<h3 className="cmp-func-tolk-header">
  ✅ 타입 불일치 시 명확하고 읽기 쉬운 오류 메시지
</h3>

FunC에서는 Hindley-Milner로 인해 타입 불일치 오류를 이해하기가 매우 어렵습니다:

```
error: previous function return type (int, int)
cannot be unified with implicit end-of-block return type (int, ()):
cannot unify type () with int
```

Tolk에서는 사람이 읽을 수 있습니다:

```
1) can not assign `(int, slice)` to variable of type `(int, int)`
2) can not call method for `builder` with object of type `int`
3) can not use `builder` as a boolean condition
4) missing `return`
...
```

<h3 className="cmp-func-tolk-header">
  ✅ <code>bool</code> 타입, <code>boolVar as int</code> 캐스팅
</h3>

내부적으로 **`bool`은 여전히 TVM 레벨에서 -1과 0입니다**, 하지만 타입 시스템의 관점에서 `bool`과 `int`는 이제 다릅니다.

비교 연산자 `== / >= /...`는 `bool`을 반환합니다. 논리 연산자 `&& ||`는 `bool`을 반환합니다. 상수 `true`와 `false`는 `bool` 타입을 가집니다.
많은 stdlib 함수들이 이제 `int` 대신 `bool`을 반환합니다(런타임에서는 -1과 0):

```tolk
var valid = isSignatureValid(...);    // bool
var end = cs.isEnd();                 // bool
```

연산자 `!x`는 `int`와 `bool` 모두 지원합니다. `if`와 유사한 조건문은 `int`(!= 0)와 `bool` 모두 허용합니다.
논리 연산자 `&&`와 `||`는 정수가 아닌 값에 대한 `a && b` 같은 구문과의 호환성을 위해 `bool`과 `int` 모두 허용합니다.

산술 연산자는 정수로 제한되며, 비트 연산자와 논리 연산자만 불리언에 허용됩니다:

```tolk
valid && end;    // ok
valid & end;     // ok, bitwise & | ^ also work if both are bools
if (!end)        // ok

if (~end)        // error, use !end
valid + end;     // error
8 & valid;       // error, int & bool not allowed
```

논리 연산자 `&& ||`(FunC에서는 누락됨)는 항상 IF/ELSE asm 표현을 사용합니다.
향후 최적화를 위해 안전할 때(예: `a > 0 && a < 10`) 자동으로 `& |`로 대체될 수 있습니다.
가스 소비를 수동으로 최적화하기 위해 여전히 `& |`(bool에 허용됨)를 사용할 수 있지만, 단락 평가가 아니라는 점을 기억하세요.

**`bool`은 `as` 연산자를 통해 `int`로 캐스팅될 수 있습니다**:

```tolk
var i = boolValue as int;  // -1 / 0
```

런타임 변환은 없습니다. `bool`은 TVM 레벨에서 -1/0임이 보장되므로 이는 타입만의 캐스팅입니다.
하지만 일반적으로 이러한 캐스팅이 필요하다면 아마도 잘못된 방식으로 하고 있는 것입니다(까다로운 비트 연산 최적화를 하는 경우 제외).

<h3 className="cmp-func-tolk-header">
  ✅ 제네릭 함수와 <code>f&amp;amp;lt;int&amp;amp;gt;(...)</code> 같은 인스턴스화
</h3>

Tolk는 제대로 만들어진 제네릭 함수를 도입합니다. 구문은 주류 언어들을 연상시킵니다:

```tolk
fun replaceNulls<T1, T2>(tensor: (T1?, T2?), v1IfNull: T1, v2IfNull: T2): (T1, T2) {
    var (a, b) = tensor;
    return (a == null ? v1IfNull : a, b == null ? v2IfNull : b);
}
```

제네릭 매개변수 `T`는 복잡한 것일 수도 있습니다.

```tolk
fun duplicate<T>(value: T): (T, T) {
    var copy: T = value;
    return (value, copy);
}

duplicate(1);         // duplicate<int>
duplicate([1, cs]);   // duplicate<[int, slice]>
duplicate((1, 2));    // duplicate<(int, int)>
```

또는 함수도 가능하며, 이것도 작동합니다:

```tolk
fun callAnyFn<TObj, TResult>(f: TObj -> TResult, arg: TObj) {
    return f(arg);
}

fun callAnyFn2<TObj, TCallback>(f: TCallback, arg: TObj) {
    return f(arg);
}
```

Note that while generic `T` is mostly detected from arguments, there are no such obvious corner cases when `T` does not depend on arguments:

```tolk
fun tupleLast<T>(t: tuple): T
    asm "LAST";

var last = tupleLast(t);    // error, can not deduce T
```

이를 유효하게 만들기 위해서는 `T`를 외부에서 제공해야 합니다:

```tolk
var last: int = tupleLast(t);       // ok, T=int
var last = tupleLast<int>(t);       // ok, T=int
var last = tupleLast(t) as int;     // ok, T=int

someF(tupleLast(t));       // ok, T=(paremeter's declared type)
return tupleLast(t);       // ok if function specifies return type
```

Also note that `T` for asm functions must occupy one stack slot, whereas for a user-defined function, `T` could be of any shape. Otherwise, asm body is unable to handle it properly.

<h3 className="cmp-func-tolk-header">
  ✅ recv_internal / recv_external에 대한 다른 이름
</h3>

```tolk
fun onInternalMessage
fun onExternalMessage
fun onTickTock
fun onSplitPrepare
fun onSplitInstall
```

모든 매개변수 타입과 순서는 그대로이고 이름만 변경되었습니다. `fun main`도 사용 가능합니다.

<h3 className="cmp-func-tolk-header">
  ✅ #include → import. 엄격한 임포트
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'#include "another.fc";'}</code></td>
    <td><code>{'import "another.tolk"'}</code></td>
  </tr>
  </tbody>
</table>

In Tolk, you can not use a symbol from `a.tolk` without importing this file. In other words, "import what you use".

All stdlib functions are available out of the box. Downloading stdlib and \\`#include "stdlib.fc" is unnecessary. See below about embedded stdlib.

There is still a global scope of naming. If `f` is declared in two different files, it's an error. We "import" a whole file with no per-file visibility, and the `export` keyword is now supported but probably will be in the future.

<h3 className="cmp-func-tolk-header">
  ✅ #pragma → 컴파일러 옵션
</h3>

FunC에서는 `allow-post-modifications`와 같은 "실험적" 기능이 .fc 파일의 프라그마로 켜졌습니다(일부 파일에는 있고 일부 파일에는 없어서 발생하는 문제로 이어짐). 실제로는 파일을 위한 프라그마가 아닌 컴파일 옵션입니다.

Tolk에서는 모든 프라그마가 제거되었습니다. `allow-post-modification`과 `compute-asm-ltr`는 Tolk 소스에 병합되었습니다(FunC에서 항상 켜져 있던 것처럼). 프라그마 대신 이제 실험적 옵션을 전달할 수 있습니다.

현재로서는 하나의 실험적 옵션이 도입되었습니다 - `remove-unused-functions`으로, 사용되지 않은 심볼을 Fift 출력에 포함하지 않습니다.

`#pragma version xxx` was replaced by `tolk xxx` (no >=, just a strict version). It's good practice to annotate the compiler version you are using. If it doesn't match, Tolk will show a warning.

```tolk
tolk 0.12
```

<h3 className="cmp-func-tolk-header">
  ✅ 늦은 심볼 해결. AST 표현
</h3>

In FunC, like in С, you can not access a function declared below:

```func
int b() { a(); }   ;; error
int a() { ... }    ;; since it's declared below
```

To avoid an error, a programmer should first create a forward declaration. The reason is that symbol resolution is performed right during parsing.

Tolk compiler separates these two steps. At first, it does parsing, and then it does symbol resolving. Hence, a snippet above would not be erroneous.

It sounds simple, but internally, it's a very huge job. To make this available, I've introduced an intermediate AST representation, which was completely missed in FunC. That's an essential point for future modifications and performing semantic code analysis.

<h3 className="cmp-func-tolk-header">
  ✅ `null` 키워드
</h3>

널 값 생성과 변수의 널 체크가 이제 매우 깔끔해 보입니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'a = null()'}</code></td>
    <td><code>{'a = null'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (null?(a))'}</code></td>
    <td><code>{'if (a == null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ null?(b))'}</code></td>
    <td><code>{'if (b != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ cell_null?(c))'}</code></td>
    <td><code>{'if (c != null)'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `throw`와 `assert` 키워드
</h3>

Tolk dramatically simplifies working with exceptions.

FunC가 `throw()`, `throw_if()`, `throw_arg_if()`와 unless에 대한 같은 것을 가지고 있다면, Tolk는 `throw`와 `assert` 두 가지 기본 요소만 가집니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'throw(excNo)'}</code></td>
    <td><code>{'throw excNo'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_arg(arg, excNo)'}</code></td>
    <td><code>{'throw (excNo, arg)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_unless(excNo, condition)'}</code></td>
    <td><code>{'assert(condition, excNo)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_if(excNo, condition)'}</code></td>
    <td><code>{'assert(!condition, excNo)'}</code></td>
  </tr>
  </tbody>
</table>

논리적 NOT이 가능하므로 `!condition`이 가능하다는 점을 참고하세요.

`assert(condition, excNo)`의 긴(자세한) 구문이 있습니다:

```tolk
assert(condition) throw excNo;
// with a possibility to include arg to throw
```

또한 Tolk는 `catch` 인수를 바꿉니다: `catch (excNo, arg)`이며, 둘 다 선택사항입니다(arg가 대부분 비어있기 때문에).

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'try { } catch (_, _) { }'}</code></td>
    <td><code>{'try { } catch { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (_, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (arg, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo, arg) { }'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `do ... until` → `do ... while`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'do { ... } until (~ condition);'}</code></td>
    <td><code>{'do { ... } while (condition);'}</code></td>
  </tr>
  <tr>
    <td><code>{'do { ... } until (condition);'}</code></td>
    <td><code>{'do { ... } while (!condition);'}</code></td>
  </tr>
  </tbody>
</table>

논리적 NOT이 가능하므로 `!condition`이 가능하다는 점을 참고하세요.

<h3 className="cmp-func-tolk-header">
  ✅ 연산자 우선순위가 C++ / JavaScript와 동일해짐
</h3>

In FunC, such code `if (slices_equal() & status == 1)` is parsed as `if( (slices_equal()&status) == 1 )`. This approach is a reason for various errors in real-world contracts.

In Tolk, `&` has a lower priority, which is identical to C++ and JavaScript.

Moreover, Tolk fires errors on potentially wrong operators' usage to eliminate such errors:

```tolk
if (flags & 0xFF != 0)
```

컴파일 오류가 발생합니다(gcc/clang과 유사):

```
& has lower precedence than ==, probably this code won't work as you expected.  Use parenthesis: either (... & ...) to evaluate it first, or (... == ...) to suppress this error.
```

Hence, you should rewrite the code:

```tolk
// either to evaluate it first (our case)
if ((flags & 0xFF) != 0)
// or to emphasize the behavior (not our case here)
if (flags & (0xFF != 0))
```

비트시프트 연산자에서 흔한 실수에 대한 진단도 추가했습니다: `a << 8 + 1`은 `a << 9`와 동일하며, 아마도 예상치 못한 결과일 것입니다.

```
int result = a << 8 + low_mask;

error: << has lower precedence than +, probably this code won't work as you expected.  Use parenthesis: either (... << ...) to evaluate it first, or (... + ...) to suppress this error.
```

연산자 `~% ^% /% ~/= ^/= ~%= ^%= ~>>= ^>>=`는 더 이상 존재하지 않습니다.

<h3 className="cmp-func-tolk-header">
  ✅ `val`을 통해 선언되는 불변 변수
</h3>

Kotlin처럼: 가변에는 `var`, 불변에는 `val`, 선택적으로 타입이 따라옵니다. FunC에는 `val`의 대응물이 없습니다.

```tolk
val flags = msgBody.loadMessageFlags();
flags &= 1;         // error, modifying an immutable variable

val cs: slice = c.beginParse();
cs.loadInt(32);     // error, since loadInt() mutates an object
cs.preloadInt(32);  // ok, it's a read-only method
```

함수의 매개변수는 가변이지만, 값으로 복사되기 때문에 호출된 인수는 변경되지 않습니다. FunC와 정확히 같으며, 명확히 하기 위함입니다.

```tolk
fun some(x: int) {
    x += 1;
}

val origX = 0;
some(origX);      // origX remains 0

fun processOpIncrease(msgBody: slice) {
    val flags = msgBody.loadInt(32);
    ...
}

processOpIncrease(msgBody);  // by value, not modified
```

Tolk에서 함수는 `mutate` 매개변수를 선언할 수 있습니다. 이는 FunC의 `~` 틸다 함수의 일반화이며, 아래에서 읽어보세요.

<h3 className="cmp-func-tolk-header">
  ✅ 더 이상 사용되지 않는 명령줄 옵션 제거
</h3>

Command-line flags `-A`, `-P`, and others were removed. Default behavior

```
/path/to/tolk {inputFile}
```

이 충분합니다. 버전을 출력하고 종료하려면 `-v`를 사용하세요. 사용 가능한 모든 명령줄 플래그를 보려면 `-h`를 사용하세요.

하나의 입력 파일만 전달할 수 있으며, 다른 파일들은 `import`되어야 합니다.

<h3 className="cmp-func-tolk-header">
  ✅ stdlib 함수들이 ~~장황한~~ 명확한 이름으로 변경됨, camelCase 스타일
</h3>

All names in the standard library were reconsidered. Now, functions are called using longer but clear names.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'cur_lt()<br>car(l)<br>get_balance().pair_first()<br>raw_reserve(count)<br>dict~idict_add?(...)<br>dict~udict::delete_get_max()<br>t~tpush(triple(x, y, z))<br>s.slice_bits()<br>~dump(x)<br>...'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'blockchain.logicalTime()<br>listGetHead(l)<br>contract.getOriginalBalance()<br>reserveToncoinsOnBalance(count)<br>dict.iDictSetIfNotExists(...)<br>dict.uDictDeleteLastAndGet()<br>t.push([x, y, z])<br>s.remainingBitsCount()<br>debug.print(x)<br>...'}}></code></td>
  </tr>
  </tbody>
</table>

이전의 "stdlib.fc"는 여러 파일로 분할되었습니다: common.tolk, tvm-dicts.tolk 등.

여기에서 계속: [Tolk vs FunC: standard library](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).

<h3 className="cmp-func-tolk-header">
  ✅ stdlib가 이제 GitHub에서 다운로드하지 않고 내장됨
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <ol style={{margin: 0}}>
        <li>GitHub에서 stdlib.fc 다운로드</li>
        <li>프로젝트에 저장</li>
        <li>`#include "stdlib.fc";`</li>
        <li>표준 함수 사용</li>
      </ol>
    </td>
    <td>
      <ol style={{margin: 0}}>
        <li>표준 함수 사용</li>
      </ol>
    </td>
  </tr>
  </tbody>
</table>

Tolk에서 stdlib는 배포판의 일부입니다. "언어, 컴파일러, stdlib" 세 가지를 함께 유지하는 것이 릴리스 주기를 유지하는 유일하게 올바른 방법이기 때문에 표준 라이브러리는 분리할 수 없습니다.

다음과 같이 작동합니다. Tolk 컴파일러는 표준 라이브러리를 찾는 방법을 알고 있습니다. 사용자가 apt 패키지를 설치했다면 stdlib 소스도 다운로드되어 하드 디스크에 존재하므로 컴파일러가 시스템 경로로 찾습니다. 사용자가 WASM 래퍼를 사용한다면 tolk-js에 의해 제공됩니다. 등등.

표준 라이브러리는 여러 파일로 나뉩니다: `common.tolk`(가장 일반적인 함수들), `gas-payments.tolk`(가스 수수료 계산), `tvm-dicts.tolk` 등. `common.tolk`의 함수들은 항상 사용 가능합니다(컴파일러가 암묵적으로 임포트). 다른 파일들은 명시적으로 임포트해야 합니다:

```tolk
import "@stdlib/tvm-dicts"   // ".tolk" optional

...
var dict = createEmptyDict();
dict.iDictSet(...);
```

"사용하는 것을 임포트하세요" 규칙을 명심하세요, `@stdlib/...` 파일에도 적용됩니다("common.tolk"만 예외).

JetBrains IDE 플러그인은 stdlib 폴더를 자동으로 발견하고 타이핑할 때 필요한 임포트를 삽입합니다.

<h3 className="cmp-func-tolk-header">
  ✅ 논리 연산자 `&& ||`, 논리 NOT `!`
</h3>

FunC에는 비트 연산자 `~ & | ^`만 있습니다. 처음 시작하는 개발자들은 "좋아, 논리 연산자가 없으니 같은 방식으로 비트 연산자를 사용하면 되겠지"라고 생각하여 자주 오류를 범합니다. 연산자 동작이 완전히 다르기 때문입니다:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition & f()</code></th>
    <th><code>condition && f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code>는 항상 호출됨</td>
    <td><code className="inline">f()</code>는 <code className="inline">condition</code>이 참일 때만 호출됨</td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>condition | f()</code></th>
    <th><code>condition || f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code>는 항상 호출됨</td>
    <td><code className="inline">f()</code>는 <code className="inline">condition</code>이 거짓일 때만 호출됨</td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>`a & b`</th>
    <th>`a && b`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>때로는 동일:</td></tr>
  <tr>
    <td><code>{'0 & X = 0'}</code></td>
    <td><code>{'0 & X = 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'-1 & X = -1'}</code></td>
    <td><code>{'-1 & X = -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>하지만 일반적으로는 그렇지 않음:</td></tr>
  <tr>
    <td><code>{'1 & 2 = 0'}</code></td>
    <td><code>{'1 && 2 = -1 (true)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>`~ found`</th>
    <th>`!found`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>때로는 동일:</td></tr>
  <tr>
    <td><code>{'true (-1) → false (0)'}</code></td>
    <td><code>{'-1 → 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'false (0) → true (-1)'}</code></td>
    <td><code>{'0 → -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>하지만 일반적으로는 그렇지 않음:</td></tr>
  <tr>
    <td><code>{'1 → -2'}</code></td>
    <td><code>{'1 → 0 (false)'}</code></td>
  </tr>
  </tbody>
</table>

Tolk는 논리 연산자를 지원합니다. 이들은 익숙한 대로 정확히 작동합니다(오른쪽 열). 현재로서는 `&&`와 `||`가 때때로 최적화되지 않은 Fift 코드를 생성하지만, 향후 Tolk 컴파일러가 이 경우에 더 똑똑해질 것입니다. 이는 무시할 만하므로 다른 언어처럼 사용하시면 됩니다.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'if (~ found?)'}</code></td>
    <td><code>{'if (!found)'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'if (~ found?) {<br>    if (cs~load_int(32) == 0) {<br>        ...<br>    }<br>}'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'if (!found && cs.loadInt(32) == 0) {<br>    ...<br>}'}}></code></td>
  </tr>
  <tr>
    <td><code>{'ifnot (cell_null?(signatures))'}</code></td>
    <td><code>{'if (signatures != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'elseifnot (eq_checksum)'}</code></td>
    <td><code>{'else if (!eqChecksum)'}</code></td>
  </tr>
  </tbody>
</table>

Keywords `ifnot` and `elseifnot` were removed, since now we have logical not (for optimization, Tolk compiler generates `IFNOTJMP`, btw). The `elseif` keyword  was replaced by the traditional `else if`.

Remember that a boolean `true`, transformed `as int`, is -1, not 1. It's a TVM representation.

<h3 className="cmp-func-tolk-header">
  ✅ Indexed access `tensorVar.0` and `tupleVar.0`
</h3>

Use `tensorVar.{i}` to access i-th component of a tensor. Modifying it will change the tensor.

```tolk
var t = (5, someSlice, someBuilder);   // 3 stack slots
t.0         			// 5
t.0 = 10;   			// t is now (10, ...)
t.0 += 1;               // t is now (11, ...)
increment(mutate t.0);  // t is now (12, ...)
t.0.increment();        // t is now (13, ...)

t.1         // slice
t.100500    // compilation error
```

Use `tupleVar.{i}` to access i-th element of a tuple (does INDEX under the hood). Modifying it will change the tuple (does SETINDEX under the hood).

```tolk
var t = [5, someSlice, someBuilder];   // 1 tuple on a stack with 3 items
t.0                     // "0 INDEX", reads 5
t.0 = 10;               // "0 SETINDEX", t is now [10, ...]
t.0 += 1;               // also works: "0 INDEX" to read 10, "0 SETINDEX" to write 11
increment(mutate t.0);  // also, the same way
t.0.increment();        // also, the same way

t.1         // "1 INDEX", it's slice
t.100500    // compilation error
```

It also works for untyped tuples, though the compiler can't guarantee index correctness.

```tolk
var t = createEmptyTuple();
t.tuplePush(5);
t.0                     // will head 5
t.0 = 10                // t will be [10]
t.100500                // will fail at runtime
```

It works for nesting `var.{i}.{j}`. It works for nested tensor, nested tuples, tuples nested into tensors.
It works for `mutate`. It works for globals.

```tolk
t.1.2 = 10;    // "1 INDEX" + "2 SETINDEX" + "1 SETINDEX"
t.1.2 += 10;   // "1 INDEX" + "2 INDEX" + sum + "2 SETINDEX" + "1 SETINDEX"

globalTuple.1.2 += 10;  // "GETGLOB" + ... + "SETGLOB"
```

<h3 className="cmp-func-tolk-header">
  ✅ 새로운 함수 구문: `fun` 키워드, `@` 속성, 타입은 오른쪽에 (TypeScript, Kotlin, Python 등과 같이)
</h3>

In TVM, all **binary data** is just **a slice.** Same goes for addresses: while TL-B describes the entity `MsgAddress` (internal/external/none/var address),

and TVM assembler has instructions to load/validate addresses, nevertheless: at the low level, it's just a slice.
That's why in FunC's standard library `loadAddress` returned `slice`, and `storeAddress` accepted `slice`.

Tolk introduces the dedicated `address` type. It's still a TVM slice at runtime (internal/external/none),
but it differs from an **abstract slice** from the type system point of view:

1. Integrated with auto-serialization: compiler knows how to pack/unpack it (`LDMSGADDR` and `STSLICE`)
2. Comparable: operators `==` and `!=` work on addresses:

```tolk
if (senderAddress == msg.owner)
```

3. Introspectable: `address.isNone()`, `address.isInternal()`, `address.isExternal()`, `address.getWorkchain()` and `address.getWorkchainAndHash()` (valid for internal addresses)

Passing a slice instead leads to an error:

```tolk
var a: slice = s.loadAddress();  // error, can not assign `address` to `slice`
```

**Embedding a const address into a contract**

Use the built-in `address()` function, which accepts a standard address. In FunC, there was a postfix `"..."a` that returned a slice.

```tolk
address("EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5")
address("0:527964d55cfa6eb731f4bfc07e9d025098097ef8505519e853986279bd8400d8")
```

**Casting `slice` to `address` and vice versa**

If you have a raw slice, which is actually an address, you can cast it via `as` operator.
In practice, this can occur if you've composed an address with a builder, having manually written its binary representation:

```tolk
var b = beginCell()
       .storeUint(0b01)   // addr_extern
       ...;
var s = b.endCell().beginParse();
return s as address;   // `slice` as `address`
```

A reversed cast also is valid: `someAddr as slice` (why would you need it, is an open question, though).

**Different types of addresses**

According to a standard, there are different types of addresses. The most frequently used is a **standard address** — just and address of a smart contract, like `EQ...`. But also, there are **external** and **none** addresses. In a binary TL-B representation,

- `10` (**internal** prefix) + `0` (anycast, always 0) + workchain (8 bits) + hash (256 bits) — that's `EQ...`: it's 267 bits
- `01` (**external** prefix) + len (9 bits) + len bits — external addresses
- `00` (**none** prefix) — address **none**, 2 bits

The `address` type can hold any of these. Most often, it's an internal address. But the type system does not restrict it exactly: this can't be done without heavy runtime checks.

So, if `address` comes from an untrusted input, you should probably validate it:

```tolk
val newOwner = msg.nextOwnerAddress;
assert(newOwner.isInternal()) throw 403;
assert(newOwner.getWorkchain() == BASECHAIN) throw 403;
```

All in all, if you don't trust inputs — you should validate everything: numbers, payload, and addresses particularly.
But if an input comes from a trusted source (your own contract storage, for example) — of course, you can rely on its contents.
The compiler does not insert hidden instructions.
Just remember, that `address` in general can hold all valid types.

<h3 className="cmp-func-tolk-header">
  ✅ Type aliases <code>type NewName = &amp;amp;lt;existing type&amp;amp;gt;</code>
</h3>

Tolk supports type aliases, similar to TypeScript and Rust.
An alias creates a new name for an existing type but **remains interchangeable with it**.

```tolk
type UserId = int32;
type MaybeOwnerHash = bytes32?;

fun calcHash(id: UserId): MaybeOwnerHash { ... }

var id: UserId = 1;       // ok
var num: int = id;        // ok
var h = calcHash(id);
if (h != null) {
    h as slice;           // bytes32 as slice
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Nullable types `T?`, null safety, smart casts, operator `!`
</h3>

Tolk has nullable types: `int?`, `cell?`, and `T?` in general (even for tensors).
Non-nullable types, such as `int` and `cell`, can never hold null values.

The compiler enforces **null safety**: you cannot use nullable types without first checking for null.
Fortunately, these checks integrate smoothly and organically into the code thanks to smart casts.
Smart casts are purely a compile-time feature — they do not consume gas or extra stack space.

```tolk
var value = x > 0 ? 1 : null;  // int?

value + 5;               // error
s.storeInt(value);       // error

if (value != null) {
    value + 5;           // ok, smart cast
    s.storeInt(value);   // ok, smart cast
}
```

Remember that when a variable's type is not specified, it's auto-inferred from the assignment and never changes:

```tolk
var i = 0;
i = null;       // error, can't assign `null` to `int`
i = maybeInt;   // error, can't assign `int?` to `int`
```

Such a code will not work. You must **explicitly declare the variable as nullable**::

```tolk
// incorrect
var i = null;
if (...) {
    i = 0;     // error
}

// correct
var i: int? = null;
// or
var i = null as int?;
```

Smart casts (similar to TypeScript and Kotlin) make it easier to deal with nullable types, allowing code like this:

```tolk
if (lastCell != null) {
    // here lastCell is `cell`, not `cell?`
}
```

```tolk
if (lastCell == null || prevCell == null) {
    return;
}
// both lastCell and prevCell are `cell`
```

```tolk
var x: int? = ...;
if (x == null) {
    x = random();
}
// here x is `int`
```

```tolk
while (lastCell != null) {
    lastCell = lastCell.beginParse().loadMaybeRef();
}
// here lastCell is 100% null
```

```tolk
// t: (int, int)?
t.0                // error
t!.0               // ok
if (t.0 != null) {
    t.0            // ok
}
```

Note that smart casts don't work for globals; they only work for local vars.

Tolk has the `!` operator (non-null assertion, compile-time only), like `!` in TypeScript and `!!` in Kotlin.
If you are certain that a variable is not null,
this operator allows you to skip the compiler's check.

```tolk
fun doSmth(c: cell);

fun analyzeStorage(nCells: int, lastCell: cell?) {
    if (nCells) {           // then lastCell 100% not null
        doSmth(lastCell!);  // use ! for this fact
    }
}
```

In practice, you'll use this operator working with low-level dicts API.
Tolk will have a high-level `map<K,V>` in the future.
For now, working with dicts will require the `!` operator.

```tolk
// it returns either (slice, true) or (null, false)
@pure
fun dict.iDictGet(self, keyLen: int, key: int): (slice?, bool)
    asm(key self keyLen) "DICTIGET" "NULLSWAPIFNOT";

var (cs, exists) = myDict.iDictGet(...);
// if exists is true, cs is not null
if (exists) {
    cs!.loadInt(32);
}
```

You can also declare "always-throwing functions" that return `never`:

```tolk
fun alwaysThrows(): never {
    throw 123;
}

fun f(x: int) {
    if (x > 0) {
        return x;
    }
    alwaysThrows();
    // no `return` statement needed
}
```

The `never` type implicitly occurs when a condition can never happen:

```tolk
var v = 0;
// prints a warning
if (v == null) {
    // v is `never`
    v + 10;   // error, can not apply `+` `never` and `int`
}
// v is `int` again
```

If you encounter `never` in compilation errors, there is most likely a warning in the preceding code.

Non-atomic nullable are also allowed: `(int, int)?`, `(int?, int?)?`, or even `()?`. Then,
a special _value presence_ stack slot is implicitly added.
It holds `0` if a value is null, and not 0 (currently, -1) if not null:

```tolk
// t: (int, int)?
t = (1, 2);    // 1 2 -1
t = (3, 4);    // 3 4 -1
t = null;      // null null 0

// t: ()?
t = ();         // -1
t = null;       // 0
```

All in all, nullability is a significant step forward for type safety and reliability.
Nullable types eliminate runtime errors, enforcing correct handling of optional values.

<h3 className="cmp-func-tolk-header">
  ✅ Union types `T1 | T2 | ...`, operators `match`, `is`, `!is`
</h3>

Union types allow a variable to hold multiple possible types, similar to TypeScript.

```tolk
fun whatFor(a: bits8 | bits256): slice | UserId { ... }

var result = whatFor(...);  // slice | UserId
```

Nullable types `T?` are now formally `T | null`.
Union types have intersection properties. For instance, `B | C` can be passed/assigned to `A | B | C | D`.

The only way to work with unions from code is **pattern matching**:

```tolk
match (result) {
    slice  => { /* result is smart-casted to slice  */ }
    UserId => { /* result is smart-casted to UserId */ }
}
```

Example:

```tolk
match (result) {
    slice => {
        return result.loadInt(32);
    }
    UserId => {
        if (result < 0) {
            throw 123;
        }
        return loadUser(result).parentId;
    }
}
```

`match` must cover all union cases (should be _exhaustive_). It can also be **used as an expression**:

```tolk
type Pair2 = (int, int);
type Pair3 = (int, int, int);

fun getLast(tensor: Pair2 | Pair3) {
    return match (tensor) {
        Pair2 => tensor.1,
        Pair3 => tensor.2,
    }
}
```

Syntax details:

- commas are optional with {} but required for expressions
- a trailing comma is allowed
- semicolon is not required after `match` used as a statement
- for match-expressions, its arm can terminate, then its type is considered `never`:

```tolk
return match (msg) {
    ...
    CounterReset => throw 403,  // forbidden
}
```

Variable declaration inside `match` is allowed:

```tolk
match (val v = getPair2Or3()) {
    Pair2 => {
        // use v.0 and v.1
    }
    Pair3 => {
        // use v.0, v.1, and v.2
    }
}
```

<details>
<summary>How are union types represented on the stack, at the TVM level?</summary>

Internally, at the TVM level, they are stored as tagged unions, like enums in Rust:

- each type is assigned a unique type ID, which is stored alongside the value
- the union occupies N + 1 stack slots, where N is the maximum size of any type in the union
- a nullable type `T?` is just a union with null (type ID = 0); `int?` and other atomics still use 1 stack slot

```tolk
var v: int | slice;    // 2 stack slots: value and typeID
                       // - int:   (100, 0xF831)
                       // - slice: (CS{...}, 0x29BC)
match (v) {
    int =>     // IF TOP == 0xF831 { ... }
        // v.slot1 contains int, can be used in arithmetics
    slice =>   // ELSE { IF TOP == 0x29BC { ... } }
        // v.slot1 contains slice, can be used to loadInt()
}

fun complex(v: int | slice | (int, int)) {
    // Stack representation:
    // - int:        (null, 100, 0xF831)
    // - slice:      (null, CS{...}, 0x29BC)
    // - (int, int): (200, 300, 0xA119)
}

complex(v);   // passes (null, v.slot1, v.typeid)
complex(5);   // passes (null, 5, 0xF831)
```

</details>

Besides `match`, you can test a union type by `is`. Smart casts work as expected:

```tolk
fun f(v: cell | slice | builder) {
    if (v is cell) {
        v.cellHash();
    } else {
        // v is `slice | builder`
        if (v !is builder) { return; }
        // v is `slice`
        v.sliceHash();
    }
    // v is `cell | slice`
    if (v is int) {
        // v is `never`
        // a warning is also printed, condition is always false
    }
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Pattern matching for expressions (switch-like behavior)
</h3>

`match` can also be used for **constant expressions**, similar to `switch`:

```tolk
val nextValue = match (curValue) {
    1 => 0,
    0 => 1,
    else => -1
};
```

Rules:

- only constant expressions are allowed on the left-hand side (1, SOME_CONST, 2 + 3)
- branches can contain `return` and `throw`
- `else` is required for expression form but optional for statement form:

```tolk
// statement form
match (curValue) {
    1 => { nextValue = 0 }
    0 => { nextValue = 1 }
    -1 => throw NEGATIVE_NOT_ALLOWED
}

// expression form, else branch required
val nextValue = match (curValue) {
    ...
    else => <expression>
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Structures <code>{'struct A { ... }'}</code>
</h3>

Looks like TypeScript — but works in TVM!

```tolk
struct Point {
    x: int;
    y: int;
}

fun calcMaxCoord(p: Point) {
    return p.x > p.y ? p.x : p.y;
}

// declared like a JS object
var p: Point = { x: 10, y: 20 };
calcMaxCoord(p);

// called like a JS object
calcMaxCoord({ x: 10, y: 20 });

// works with shorthand syntax
fun createPoint(x: int, y: int): Point {
    return { x, y };
}
```

- a struct is just **a named tensor**
- `Point` is identical to `(int, int)` at the TVM level
- field access `p.x` works like accessing tensor elements `t.0`, for reading and writing

This means **no bytecode overhead** — you can replace unreadable tensors with clean, structured types.

Fields can be separated by `;` or `,` (both are valid, like in TypeScript). Trailing commas are allowed.

When creating a structure, you can specify `StructName { ... }` or simply `{ ... }` if the type is clear from the context (e.g., return type or assignment):

```tolk
var s: StoredInfo = { counterValue, ... };
var s: (int, StoredInfo) = (0, { counterValue, ... });

// also valid, but not preferred
var s = StoredInfo { counterValue, ... };
```

Default values for fields are supported:

```tolk
struct DefDemo {
    f1: int = 0;
    f2: int? = null;
    f3: (int, coins) = (0, ton("0.05"));
}

var d: DefDemo = {};         // ok
var d: DefDemo = { f2: 5 };  // ok
```

Structs can have methods as extension functions, read below.

<h3 className="cmp-func-tolk-header">
  ✅ Generic structs and aliases
</h3>

They exist only at the type level (no runtime cost).

```tolk
struct Container<T> {
    isAllowed: bool;
    element: T?;
}

struct Nothing {}

type Wrapper<T> = Nothing | Container<T>;
```

Example usage:

```tolk
fun checkElement(c: Container<T>) {
    return c.element != null;
}

var c: Container<int32> = { isAllowed: false, element: null };

var v: Wrapper<int> = Nothing {};
var v: Wrapper<int32> = Container { value: 0 };
```

Since it's a generic, you should specify type arguments when using it:

```tolk
fun getItem(c: Container)        // error, specify type arguments
fun getItem(c: Container<int>)   // ok
fun getItem<T>(c: Container<T>)  // ok

var c: Container = { ... }       // error, specify type arguments
var c: Container<int> = { ... }  // ok
```

When you declare a generic function, the compiler can automatically infer type arguments for a call:

```tolk
fun doSmth<T>(value: Container<T>) { ... }

doSmth({ item: 123 });         // T = int
doSmth({ item: cellOrNull });  // T = cell?
```

Demo: `Response<TResult, TError>`:

```tolk
struct Ok<TResult> { result: TResult; }
struct Err<TError> { err: TError; }

type Response<R, E> = Ok<R> | Err<E>;

fun tryLoadMore(slice: slice): Response<cell, int32> {
    return ...
        ? Ok { result: ... }
        : Err { err: ErrorCodes.NO_MORE_REFS };
}

match (val r = tryLoadMore(inMsg)) {
    Ok => { r.result }
    Err => { r.err }
}
```

<h3 className="cmp-func-tolk-header">
  ✅ Methods: for any types, including structures
</h3>

Methods are declared as extension functions, similar to Kotlin.
A method can accept the first `self` parameter (then it's an instance method) or not accept it (then it's a static method).

```tolk
fun Point.getX(self) {
    return self.x
}

fun Point.create(x: int, y: int): Point {
    return { x, y }
}
```

Methods can be created **for any type**, including aliases, unions, and built-in types:

```tolk
fun int.isZero(self) {
    return self == 0;
}

type MyMessage = CounterIncrement | ...;

fun MyMessage.parse(self) { ... }
// this is identical to
// fun (CounterIncrement | ...).parse(self)
```

Methods perfectly work with `asm`, since `self` is just a regular variable:

```tolk
@pure
fun tuple.size(self): int
    asm "TLEN";
```

By default, **`self` is immutable**. It means that you can't modify it or call mutating methods.
To make `self` mutable, you should explicitly declare `mutate self`:

```tolk
fun Point.assignX(mutate self, x: int) {
    self.x = x;   // without mutate, an error "modifying immutable object"
}

fun builder.storeInt32(mutate self, v: int32): self {
    return self.storeInt(v, 32);
}
```

Methods for generic structs created seamlessly.
Note, that no extra `<T>` is required: while parsing the receiver type, compiler treats unknown symbols as generic arguments.

```tolk
struct Container<T> {
    item: T;
}

// compiler treats T (unknown symbol) as a generic parameter
fun Container<T>.getItem(self) {
    return self.item;
}

// and this is a specialization for integer containers
fun Container<int>.getItem(self) {
    ...
}
```

Another example:

```tolk
struct Pair<T1, T2> {
    first: T1;
    second: T2;
}

// both <T1,T2>, <A,B>, etc. work: any unknown symbols
fun Pair<A, B>.create(f: A, s: B): Pair<A, B> {
    return {
        first: f,
        second: s,
    }
}
```

Similarly, any unknown symbol (typically, `T`) can be used to make a method accepting anything:

```tolk
// any receiver
fun T.copy(self): T {
    return self;
}

// any nullable receiver
fun T?.isNull(self): bool {
    return self == null;
}
```

When you call `someObj.method()`, multiple methods with the same name may exist and theoretically be acceptable:

```tolk
fun T.copy(self) { ... }
fun int.copy(self) { ... }

someVar.copy();   // ???
```

So, the compiler performs matching to find as precise method as follows:

1. Search for exact type receiver like `int.copy` (most practical cases finish here)
2. Search for non-generic receivers that are acceptable (like `int32.copy` / `int?.copy`)
3. Search for generic receivers except `T` (like `Container<T>.copy`)
4. Search for `T` receivers (`T.copy`)

```tolk
fun int.copy(self) { ... }
fun T.copy(self) { ... }

6.copy()              // int.copy (rule 1)
(6 as int32).copy()   // int.copy (rule 2)
(6 as int32?).copy()  // T.copy with T=int? (rule 4)
```

```tolk
type MyMessage = CounterIncrement | CounterReset;
fun MyMessage.check() { ... }
fun CounterIncrement.check() { ... }

MyMessage{...}.check()         // first (rule 1)
CounterIncrement{...}.check()  // second (rule 1)
CounterReset{...}.check()      // first (rule 2)
```

In case of ambiguity, an error is printed:

```tolk
fun int?.doSmth(self) { ... }
fun int64.doSmth(self) { ... }

var v: int32;
v.doSmth();   // error: no exact match, but two possible acceptable receivers
```

You can assign a generic function to the variable, but you should explicitly specify types:

```tolk
fun genericFn<T>(v: T) { ... }
fun Container<T>.getItem(self) { ... }

var callable1 = genericFn<slice>;
var callable2 = Container<int32>.getItem;
callable2(someContainer32);   // pass it as self
```

<h3 className="cmp-func-tolk-header">
  ✅ 틸다 `~` 메서드 없음, 대신 `mutate` 키워드
</h3>

이 변경사항은 매우 크기 때문에 별도의 페이지에서 설명됩니다: [Tolk mutability](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability).

요약 버전이 있습니다

Having any struct, you can unpack in from a cell or pack and object to a cell:

```tolk
struct Point {
    x: int8;
    y: int8;
}

var value: Point = { x: 10, y: 20 };

// makes a cell containing "0A14"
var c = value.toCell();
// back to { x: 10, y: 20 }
var p = Point.fromCell(c);
```

Continue reading on a separate page: [Auto-packing to/from cells](/v3/documentation/smart-contracts/tolk/tolk-vs-func/pack-to-from-cells).

<hr />

<h3>Tolk vs FunC 가스 소비</h3>

:::tip The same or slightly less
If you transform FunC code line-by-line (for example, using a [converter](https://github.com/ton-blockchain/convert-func-to-tolk)),
you'll have the same results or even a bit better.
:::

Since Tolk is a fork of FunC, part of its core remains unchanged — particularly the stack manipulation logic.
Yes, Tolk is a completely different language, with its own syntax and semantics,
but its low-level internal representation is exactly the same as FunC's.
As a result, the syntax has no impact on gas consumption.
In fact, it's even slightly lower, since the strict type system
gives the compiler more room for optimizations.

However, once Tolk v1.0 is released, it will be significantly more efficient.
Auto-serialized structures, automatic message construction, and other features will be
noticeably cheaper than manual work with builders and slices — almost always.

<Feedback />
