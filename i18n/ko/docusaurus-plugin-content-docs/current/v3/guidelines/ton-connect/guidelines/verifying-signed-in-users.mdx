import Feedback from '@site/src/components/Feedback';

import ThemedImage from '@theme/ThemedImage';

# Verifying signed-in users on the backend

This page describes a method for the backend to ensure that the user truly owns the declared address.

Note that user verification is not required for all dApps.

It is helpful if you want to verify a user by providing them with their personal information from the backend.

## 작동 방식

- User initiates the sign-in process.
- Backend generates a `ton_proof` entity and sends it to frontend.
- Frontend signs in to wallet using `ton_proof` and receives a signed `ton_proof`.
- Frontend sends signed `ton_proof` to backend for verification.

<br></br>
<ThemedImage
    alt=""
    sources={{
        light: '/img/docs/ton-connect/ton_proof_scheme.svg?raw=true',
        dark: '/img/docs/ton-connect/ton_proof_scheme-dark.svg?raw=true',
    }}
/>
<br></br>

## Structure of the ton_proof

We will use the  `ton_proof`, implemented inside the connector.

```js
type TonProofItemReply = TonProofItemReplySuccess | TonProofItemReplyError;

type TonProofItemReplySuccess = {
  name: "ton_proof";
  proof: {
    timestamp: string; // 64-bit unix epoch time of the signing operation (seconds)
    domain: {
      lengthBytes: number; // AppDomain Length
      value: string;  // app domain name (as url part, without encoding)
    };
    signature: string; // base64-encoded signature
    payload: string; // payload from the request
  }
}

```

## Checking ton_proof on server side

1. 사용자로부터 `TonProofItemReply`를 가져옵니다.
2. Verify that the received domain corresponds to your application's domain.
3. Check if `TonProofItemReply.payload` is permitted by the original server and is still active.
4. `timestamp`가 현재 시점에서 유효한지 확인합니다.
5. [메시지 스킴](/v3/guidelines/ton-connect/guidelines/verifying-signed-in-users#concept-explanation)에 따라 메시지를 조합합니다.
6. API(a)나 백엔드 로직(b)을 통해 `public_key`를 가져옵니다

- 6a:
  - [TON API](https://docs.tonconsole.com/tonapi#:~:text=/v2/-,tonconnect,-/stateinit)의 `POST /v2/tonconnect/stateinit` 메서드로 `walletStateInit`에서 `{public_key, address}`를 가져옵니다.
  - Verify that the address extracted from `walletStateInit` to the wallet `address` declared by the user.
- 6b:
  - 지갑 계약의 [get 메서드](https://github.com/ton-blockchain/wallet-contract/blob/main/func/wallet-v4-code.fc#L174)를 통해 지갑 `public_key`를 얻습니다.
  - If the contract is inactive or lacks the get_method found in older wallet versions (v1-v3), then obtaining the key in this manner will be impossible. Instead, you must parse the walletStateInit provided by the front end. Ensure that TonAddressItemReply.walletStateInit.hash() equals TonAddressItemReply.address.hash(), indicating a BoC hash.

7. Verify that the `signature` from the front end correctly signs the assembled message and matches the `public_key` of the address.

## React example

1. Add a token provider to the root of your app:

```tsx
function App() {
    const [token, setToken] = useState<string | null>(null);

  return (
      <BackendTokenContext.Provider value={{token, setToken}}>
            { /* Your app */ }
      </BackendTokenContext.Provider>
  )
}
```

2. Implement authentication on the front end with backend integration:

<details>
<summary>예시</summary>

```tsx
import {useContext, useEffect, useRef} from "react";
import {BackendTokenContext} from "./BackendTokenContext";
import {useIsConnectionRestored, useTonConnectUI, useTonWallet} from "@tonconnect/ui-react";
import {backendAuth} from "./backend-auth";

const localStorageKey = 'my-dapp-auth-token';
const payloadTTLMS = 1000 * 60 * 20;

export function useBackendAuth() {
    const { setToken } = useContext(BackendTokenContext);
    const isConnectionRestored = useIsConnectionRestored();
    const wallet = useTonWallet();
    const [tonConnectUI] = useTonConnectUI();
    const interval = useRef<ReturnType<typeof setInterval> | undefined>();

    useEffect(() => {
        if (!isConnectionRestored || !setToken) {
            return;
        }

        clearInterval(interval.current);

        if (!wallet) {
            localStorage.removeItem(localStorageKey);
            setToken(null);

            const refreshPayload = async () => {
                tonConnectUI.setConnectRequestParameters({ state: 'loading' });

                const value = await backendAuth.generatePayload();
                if (!value) {
                    tonConnectUI.setConnectRequestParameters(null);
                } else {
                    tonConnectUI.setConnectRequestParameters({state: 'ready', value});
                }
            }

            refreshPayload();
            setInterval(refreshPayload, payloadTTLMS);
            return;
        }

        const token = localStorage.getItem(localStorageKey);
        if (token) {
            setToken(token);
            return;
        }

        if (wallet.connectItems?.tonProof && !('error' in wallet.connectItems.tonProof)) {
            backendAuth.checkProof(wallet.connectItems.tonProof.proof, wallet.account).then(result => {
                if (result) {
                    setToken(result);
                    localStorage.setItem(localStorageKey, result);
                } else {
                    alert('Please try another wallet');
                    tonConnectUI.disconnect();
                }
            })
        } else {
            alert('Please try another wallet');
            tonConnectUI.disconnect();
        }

    }, [wallet, isConnectionRestored, setToken])
}
```

</details>

## Backend example

<details>
<summary>Check if proof valid with [ton-proof-service](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/services/ton-proof-service.ts)</summary>

```tsx
public async checkProof(payload: CheckProofRequestDto, getWalletPublicKey: (address: string) => Promise<Buffer | null>): Promise<boolean> {
  try {
    const stateInit = loadStateInit(Cell.fromBase64(payload.proof.state_init).beginParse());
  
    // 1. First, try to obtain the public key via the get_public_key get-method on the smart contract deployed at Address.
    // 2. If the smart contract is not deployed yet, or the get-method is missing, you need:
    //  2.1. Parse TonAddressItemReply.walletStateInit and get public key from stateInit. You can compare the walletStateInit.code
    //  with the code of standard wallet contracts and parse the data according to the found wallet version.
    let publicKey = tryParsePublicKey(stateInit) ?? await getWalletPublicKey(payload.address);
    if (!publicKey) {
      return false;
    }
  
    // 2.2. Check that TonAddressItemReply.publicKey equals to obtained public key
    const wantedPublicKey = Buffer.from(payload.public_key, 'hex');
    if (!publicKey.equals(wantedPublicKey)) {
      return false;
    }
  
    // 2.3. Check that TonAddressItemReply.walletStateInit.hash() equals to TonAddressItemReply.address. .hash() means BoC hash.
    const wantedAddress = Address.parse(payload.address);
    const address = contractAddress(wantedAddress.workChain, stateInit);
    if (!address.equals(wantedAddress)) {
      return false;
    }
  
    if (!allowedDomains.includes(payload.proof.domain.value)) {
      return false;
    }
  
    const now = Math.floor(Date.now() / 1000);
    if (now - validAuthTime > payload.proof.timestamp) {
      return false;
    }
  
    const message = {
      workchain: address.workChain,
      address: address.hash,
      domain: {
        lengthBytes: payload.proof.domain.lengthBytes,
        value: payload.proof.domain.value,
      },
      signature: Buffer.from(payload.proof.signature, 'base64'),
      payload: payload.proof.payload,
      stateInit: payload.proof.state_init,
      timestamp: payload.proof.timestamp
    };
  
    const wc = Buffer.alloc(4);
    wc.writeUInt32BE(message.workchain, 0);
  
    const ts = Buffer.alloc(8);
    ts.writeBigUInt64LE(BigInt(message.timestamp), 0);
  
    const dl = Buffer.alloc(4);
    dl.writeUInt32LE(message.domain.lengthBytes, 0);
  
    // message = utf8_encode("ton-proof-item-v2/") ++
    //           Address ++
    //           AppDomain ++
    //           Timestamp ++
    //           Payload
    const msg = Buffer.concat([
      Buffer.from(tonProofPrefix),
      wc,
      message.address,
      dl,
      Buffer.from(message.domain.value),
      ts,
      Buffer.from(message.payload),
    ]);
  
    const msgHash = Buffer.from(await sha256(msg));
  
    // signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
    const fullMsg = Buffer.concat([
      Buffer.from([0xff, 0xff]),
      Buffer.from(tonConnectPrefix),
      msgHash,
    ]);
  
    const result = Buffer.from(await sha256(fullMsg));
  
    return sign.detached.verify(result, message.signature, publicKey);
  } catch (e) {
    return false;
  }
}

```

</details>

주요 메서드를 보여주는 [예시](https://github.com/ton-connect/demo-dapp-with-react-ui/tree/master/src/server)를 확인할 수 있습니다:

- [generatePayload](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/generate-payload.ts): Generates a payload for `ton_proof`.
- [checkProof](https://github.com/ton-connect/demo-dapp-with-react-ui/blob/master/src/server/api/check-proof.ts): proof를 확인하고 액세스 토큰 반환

## Concept explanation

If `TonProofItem` is requested, the wallet proves ownership of the selected account’s key. The signed message is bound to:

- 온체인 메시지와 구분하기 위한 고유 접두사 (`ton-connect`) (`ton-connect`)
- 지갑 주소
- 앱 도메인
- 서명 타임스탬프
- 앱의 커스텀 페이로드(서버가 nonce, 쿠키 ID, 만료 시간 등을 넣을 수 있는 곳)

```
message = utf8_encode("ton-proof-item-v2/") ++
          Address ++
          AppDomain ++
          Timestamp ++
          Payload

signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
```

여기서:

- `Address`는 다음 시퀀스로 인코딩된 지갑 주소:
- `workchain`: 32비트 부호있는 정수 빅엔디안
- `hash`: 256비트 부호없는 정수 빅엔디안
- `AppDomain`은 Length ++ EncodedDomainName

<!---->

- `Length`는 utf-8로 인코딩된 앱 도메인 이름의 바이트 길이를 나타내는 32비트 값
- `EncodedDomainName`은 `Length`바이트의 utf-8로 인코딩된 앱 도메인 이름

<!---->

- `Timestamp`는 서명 작업의 64비트 유닉스 에폭 시간
- `Payload`는 가변 길이 바이너리 문자열

참고: payload는 신뢰할 수 없는 가변 길이 데이터입니다. 불필요한 길이 접두사 사용을 피하기 위해 마지막에 배치합니다.

The signature must be verified using the public key:

1. First, try to obtain the public key via the `get_public_key` get-method on the smart contract deployed at `Address`.

2. 스마트 계약이 아직 배포되지 않았거나 get-메서드가 없는 경우:

   1. Parse `TonAddressItemReply.walletStateInit` and get public key from stateInit. You can compare the `walletStateInit.code` with the code of standard wallet contracts and parse the data according to the found wallet version.

   2. `TonAddressItemReply.publicKey`가 얻은 공개키와 일치하는지 확인

   3. Check that `TonAddressItemReply.walletStateInit.hash()` equals `TonAddressItemReply.address`. `.hash()` means BoC hash.

### Verification examples

- [Go 데모 앱](https://github.com/ton-connect/demo-dapp-backend)
- [Rust 데모 앱](https://github.com/liketurbo/demo-dapp-backend-rs)
- [JS 데모 앱](https://github.com/liketurbo/demo-dapp-backend-js)
- [Python 예시](https://github.com/XaBbl4/pytonconnect/blob/main/examples/check_proof.py)
- [PHP 예시](https://github.com/vladimirfokingithub/Ton-Connect-Proof-Php-Check)
- [C# 데모 앱](https://github.com/WinoGarcia/TonProof.NET)

## See also

- [Preparing messages](/v3/guidelines/ton-connect/guidelines/preparing-messages)
- [Sending messages](/v3/guidelines/ton-connect/guidelines/sending-messages)
- [[YouTube] @tonconnect/react-ui의 ton_proof 확인하기 [RU]](https://youtu.be/wIMbkJHv0Fs?list=PLyDBPwv9EPsCJ226xS5_dKmXXxWx1CKz_&t=2971)

<Feedback />
